<!DOCTYPE html>

<!-- [TITLE] Page: public/index.html -->
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>RaveLink Bridge | Hue + WiZ Music Sync Lighting Engine</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta
  name="description"
  content="RaveLink Bridge is a local music-sync lighting engine for Philips Hue and WiZ with Twitch reward hooks, real-time audio reactivity, and a browser control surface."
/>
<meta name="robots" content="index,follow,max-image-preview:large" />
<meta name="theme-color" content="#050507" />
<meta property="og:type" content="website" />
<meta property="og:title" content="RaveLink Bridge | Hue + WiZ Music Sync Lighting Engine" />
<meta
  property="og:description"
  content="Local reactive lighting bridge for Philips Hue and WiZ. Audio-driven effects, scheduler-safe output, and optional Twitch integrations."
/>
<meta property="og:site_name" content="RaveLink Bridge" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="RaveLink Bridge | Hue + WiZ Music Sync Lighting Engine" />
<meta
  name="twitter:description"
  content="Audio-reactive local lighting bridge for Hue + WiZ with optional Twitch reward hooks."
/>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "SoftwareApplication",
  "name": "RaveLink Bridge",
  "applicationCategory": "MultimediaApplication",
  "operatingSystem": "Windows",
  "softwareVersion": "1.3.0",
  "description": "Local music-sync lighting engine for Philips Hue and WiZ with real-time audio reactivity and optional Twitch command hooks."
}
</script>

<style>
:root{
  --bg:#050507;
  --panel:#0b0e18;
  --panel2:#121a2f;
  --accent:#8b001f;
  --accentGlow:#8b001faa;
  --edge:#233055;
  --btn-bg:#14182c;
  --warn:#ffb000;
  --ok:#19ff6a;
  --bad:#ff4444;
  --text:#eaeaea;
}

*{box-sizing:border-box}

body{
  margin:0;
  font-family:"Rajdhani","Trebuchet MS",sans-serif;
  background:
    radial-gradient(1200px 400px at 10% -10%, #1a243f55 0%, transparent 50%),
    radial-gradient(900px 300px at 100% 0%, #2e0b1655 0%, transparent 55%),
    var(--bg);
  color:var(--text);
}

header{
  padding:14px 18px;
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:12px;
}

h1{
  margin:0;
  letter-spacing:6px;
  color:var(--accent);
}

.sub{
  opacity:.85;
  font-size:12px;
  letter-spacing:1px;
}

.quickLinks{
  margin-top:8px;
  display:flex;
  flex-wrap:wrap;
  gap:8px;
}

.quickLinks a{
  color:#c9d8ff;
  text-decoration:none;
  font-size:11px;
  letter-spacing:.8px;
  border:1px solid #2a395f;
  border-radius:999px;
  padding:4px 9px;
  background:#0a1124;
}

.quickLinks a:hover{
  border-color:#45639f;
  color:#ffffff;
}

.headerRight{
  display:flex;
  gap:8px;
  align-items:center;
  position:relative;
}

.headerRight .badge{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
}

#health.badge{
  width:248px;
}

#netBadge.badge{
  width:92px;
}

.iconBtn{
  width:34px;
  min-width:34px;
  min-height:34px;
  padding:0;
  border:1px solid #315089;
  border-radius:999px;
  background:#0f1830;
  color:#b9ccf7;
  font-size:18px;
  line-height:1;
}

.iconBtn:hover{
  border-color:#4f78bf;
  color:#ffffff;
}

.themeWrap{
  position:relative;
}

.themePanel{
  position:absolute;
  top:42px;
  right:0;
  width:min(560px,calc(100vw - 24px));
  border:1px solid #2b406d;
  border-radius:12px;
  background:linear-gradient(180deg,#0d1730,#0a1225);
  padding:10px;
  z-index:1900;
  box-shadow:0 8px 24px #00000070;
}

.themePanel h4{
  margin:0 0 8px;
  font-size:11px;
  letter-spacing:1.4px;
  color:#c8d8ff;
}

.themePresetGrid{
  display:grid;
  grid-template-columns:repeat(2,minmax(0,1fr));
  gap:6px;
}

.themePresetBtn{
  border:1px solid #233055;
  background:#101a33;
  min-height:34px;
  font-size:11px;
  letter-spacing:.8px;
}

.themePresetBtn.active{
  border-color:#4f78bf;
  box-shadow:0 0 10px #315ca355;
}

.themeCustomRow{
  margin-top:8px;
  display:grid;
  grid-template-columns:repeat(2,minmax(0,1fr));
  gap:8px;
}

.themePanel label{
  display:block;
  margin-bottom:4px;
  font-size:10px;
  letter-spacing:.8px;
  color:#c8d8ff;
}

.themeColorPicker{
  width:100%;
  min-height:34px;
  border:1px solid #2b406d;
  border-radius:8px;
  background:#0c152c;
  padding:4px;
}

.themeStatusField{
  width:100%;
  margin-top:8px;
}

.themeDebugDump{
  margin-top:8px;
  width:100%;
  min-height:98px;
  resize:vertical;
  font-size:11px;
  line-height:1.3;
}

.devAckGate{
  position:fixed;
  inset:0;
  background:#02050dcc;
  z-index:6200;
  display:flex;
  align-items:center;
  justify-content:center;
  padding:16px;
}

.devAckCard{
  width:min(560px,96vw);
  border:1px solid #4b2b3a;
  border-radius:12px;
  background:linear-gradient(180deg,#180b13,#100914);
  box-shadow:0 16px 40px #0000008a;
  padding:14px;
}

.devAckTitle{
  margin:0 0 8px;
  font-size:14px;
  letter-spacing:1px;
}

.devAckInput{
  width:100%;
  margin-top:6px;
}

.devAckInput::placeholder{
  color:#f0c7d3;
  opacity:.34;
}

.devAckPhrase{
  margin-top:8px;
  width:100%;
  font-size:11px;
  letter-spacing:.6px;
}

body.obsDockMode .supportPanel{
  display:none !important;
}

body.obsDockMode .quickLinks{
  display:none;
}

body.obsDockMode .sub{
  font-size:11px;
  letter-spacing:.7px;
}

body.obsDockMode .tabs{
  margin:8px 8px 0;
}

body.obsDockMode .panel{
  margin:8px;
  padding:12px;
}

body.obsDockMode .onboardGate{
  display:none !important;
}

.supportPanel{
  margin:0 12px 8px;
  padding:8px 10px;
  border:1px solid #2a3f6b;
  background:linear-gradient(180deg,#0d1730,#091224);
}

.supportPanel .clusterHeaderRow h3{
  margin:0;
  font-size:11px;
  letter-spacing:1.6px;
  color:#b8cdf7;
  opacity:.92;
}

.supportPanel .clusterBody{
  margin-top:6px;
  display:flex;
  align-items:center;
  gap:8px;
  flex-wrap:wrap;
}

.supportMeta{
  font-size:11px;
  color:#c8d5ef;
  opacity:.86;
}

.supportLink{
  display:inline-flex;
  align-items:center;
  border:1px solid #33518c;
  border-radius:999px;
  padding:3px 9px;
  font-size:11px;
  color:#dbe8ff;
  text-decoration:none;
  background:#0b1530;
}

.supportLink:hover{
  border-color:#4c79c5;
  color:#fff;
}

.supportPanel.collapsed{
  margin:0 12px 4px auto;
  width:30px;
  min-height:0;
  padding:2px;
  border-color:transparent;
  background:transparent;
  box-shadow:none;
}

.supportPanel.collapsed .clusterHeaderRow{
  justify-content:flex-end;
  gap:0;
}

.supportPanel.collapsed .clusterHeaderRow h3{
  display:none;
}

.supportPanel.collapsed .collapseBtn{
  min-width:26px;
  width:26px;
  min-height:26px;
  padding:0;
  border-radius:999px;
  border:1px solid #2f4a7b88;
  background:#0f1630a8;
  opacity:.16;
  font-size:0;
  letter-spacing:0;
}

.supportPanel.collapsed .collapseBtn::before{
  content:"+";
  font-size:13px;
  line-height:1;
  color:#99b8f7;
}

.supportPanel.collapsed:hover .collapseBtn{
  opacity:.72;
}

.panel{
  margin:12px;
  padding:16px;
  background:linear-gradient(180deg,#0f1226,#070710);
  border-radius:18px;
  border:1px solid #1b2542;
}

h3{
  margin:18px 0 8px;
  font-size:13px;
  letter-spacing:2px;
  opacity:.85;
}

button{
  background:var(--btn-bg);
  border:none;
  border-radius:clamp(10px,1.1vw,14px);
  color:var(--text);
  padding:clamp(9px,1.2vw,12px) clamp(10px,1.5vw,14px);
  min-height:clamp(40px,5.2vh,48px);
  font-size:clamp(11px,1.05vw,14px);
  line-height:1.14;
  white-space:normal;
  cursor:pointer;
  font-weight:600;
  letter-spacing:.5px;
}

button.active{
  background:var(--accent);
  box-shadow:0 0 18px var(--accentGlow);
}

button.warn{
  background:#2a1d00;
  color:var(--warn);
}

button.bad{
  background:#2d0b0b;
  color:var(--bad);
}
button:disabled{
  opacity:.45;
  filter:saturate(.6);
  cursor:not-allowed;
}

.grid2{display:grid;grid-template-columns:1fr 1fr;gap:10px}
.grid3{display:grid;grid-template-columns:repeat(3,1fr);gap:10px}
.grid4{display:grid;grid-template-columns:repeat(4,1fr);gap:10px}
.grid5{display:grid;grid-template-columns:repeat(5,1fr);gap:10px}
.grid6{display:grid;grid-template-columns:repeat(6,1fr);gap:10px}

.sceneLockRows{
  display:grid;
  gap:10px;
}

.sceneLockRows > .grid2,
.sceneLockRows > .grid3,
.sceneLockRows > .grid4{
  margin-top:0;
}

.sceneSyncGrid{
  margin-top:2px;
}

.grid2 + .grid2,
.grid3 + .grid3,
.grid4 + .grid4,
.grid5 + .grid5,
.grid6 + .grid6{
  margin-top:8px;
}

.tabs{
  margin:12px 12px 0;
  display:flex;
  flex-wrap:wrap;
  gap:8px;
}

.tabBtn{
  flex:1 1 140px;
  padding:10px 12px;
  border:1px solid var(--edge);
  background:linear-gradient(180deg,var(--panel2),var(--btn-bg));
  color:var(--text);
}

.tabBtn:hover{
  border-color:var(--accent);
  box-shadow:inset 0 0 0 1px var(--accentGlow);
}

.tabBtn.active{
  background:linear-gradient(180deg,var(--accent),var(--panel2));
  border-color:var(--accent);
  color:#ffffff;
  box-shadow:0 0 14px var(--accentGlow);
}

.modUiDynamicTab{
  flex:1 1 170px;
  border-style:dashed;
}

.tabPage{
  display:none;
}

.tabPage.active{
  display:block;
}

.cluster{
  margin-top:14px;
  padding:12px;
  border-radius:14px;
  border:1px solid #1c2746;
  background:linear-gradient(180deg,#0f1527,#0b0e18);
}

.clusterHeaderRow{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
}

.clusterHeaderRow h3{
  margin:0;
}

.clusterHeaderActions{
  display:flex;
  align-items:center;
  gap:8px;
}

.clusterBody{
  margin-top:10px;
}

.cluster.collapsed .clusterBody{
  display:none;
}

.subcluster.collapsed .clusterBody{
  display:none;
}

.collapseBtn{
  min-width:94px;
  padding:8px 10px;
  border-radius:10px;
  border:1px solid #2d426f;
  background:linear-gradient(180deg,#17274a,#0f1a33);
  font-size:11px;
  letter-spacing:1.1px;
}

.collapseBtn:hover{
  border-color:#4f78bf;
}

.modReadmeBtn{
  min-width:138px;
  border:1px solid #2d426f;
  background:linear-gradient(180deg,#1d1f34,#141b2d);
  font-size:11px;
  letter-spacing:1px;
}

.modReadmeBtn:hover{
  border-color:#b34f70;
}

body.onboardLock::before{
  content:"";
  position:fixed;
  inset:0;
  z-index:1200;
  background:rgba(3,6,14,0.74);
  backdrop-filter:blur(2px);
}

body.onboardLock .liveMainCluster{
  position:relative;
  z-index:1250;
  border-color:#3b5c9e;
  box-shadow:0 0 0 1px #4f78bf inset, 0 0 32px #18305f99;
}

.onboardGate{
  position:fixed;
  left:50%;
  transform:translateX(-50%);
  bottom:16px;
  width:min(760px, calc(100vw - 24px));
  z-index:1300;
}

.onboardGateCard{
  border:1px solid #2f4a7c;
  border-radius:14px;
  padding:12px;
  background:linear-gradient(180deg,#111d39,#0a1224);
  box-shadow:0 0 28px #203f7a80;
}

.onboardGateTitle{
  font-size:12px;
  letter-spacing:1.3px;
  color:#d7e5ff;
}

.onboardGateText{
  margin-top:6px;
  font-size:12px;
  color:#c9d5f0;
  line-height:1.4;
}

.onboardGateActions{
  margin-top:10px;
  display:grid;
  grid-template-columns:1fr auto;
  gap:8px;
  align-items:center;
}

.onboardGateActions .hint{
  margin:0;
}

.onboardAckBtn{
  border:1px solid #7c2742;
  background:linear-gradient(180deg,#8b001f,#5c0015);
}

body.hueEntGuideLock::before{
  content:"";
  position:fixed;
  inset:0;
  z-index:1400;
  background:rgba(4,8,18,0.78);
  backdrop-filter:blur(2px);
}

body.hueEntGuideLock #fxHueBridgeBlock{
  position:relative;
  z-index:1450;
  border-color:#4f78bf;
  box-shadow:0 0 0 1px #4f78bf inset, 0 0 30px #315ca370;
}

.hueEntGuideGate{
  position:fixed;
  left:50%;
  top:50%;
  transform:translate(-50%,-50%);
  width:min(760px,calc(100vw - 24px));
  z-index:1500;
}

.hueEntGuideCard{
  border:1px solid #3a5692;
  border-radius:14px;
  padding:14px;
  background:linear-gradient(180deg,#0f1b36,#0a1224);
  box-shadow:0 0 34px #2348819a;
}

.hueEntGuideTitle{
  font-size:12px;
  letter-spacing:1.3px;
  color:#d7e5ff;
}

.hueEntGuideText{
  margin-top:8px;
  font-size:12px;
  color:#c9d5f0;
  line-height:1.45;
}

.hueEntGuideSteps{
  margin:10px 0 0;
  padding-left:18px;
  color:#d8e6ff;
  font-size:12px;
  line-height:1.4;
}

.hueEntGuideSteps li + li{
  margin-top:4px;
}

.hueEntGuideActions{
  margin-top:12px;
  display:flex;
  justify-content:flex-end;
}

.hueEntGuideAckBtn{
  min-width:180px;
  border:1px solid #7c2742;
  background:linear-gradient(180deg,#8b001f,#5c0015);
}

body.guidedTourLock::before{
  content:"";
  position:fixed;
  inset:0;
  z-index:1560;
  background:rgba(4,7,16,0.76);
  backdrop-filter:blur(2px);
}

.guidedTourFocus{
  position:relative;
  z-index:1600;
  border-radius:12px;
  box-shadow:0 0 0 1px #4f78bf inset, 0 0 28px #29519b8a;
}

.guidedTourGate{
  position:fixed;
  left:50%;
  bottom:16px;
  transform:translateX(-50%);
  width:min(860px,calc(100vw - 24px));
  z-index:1660;
}

.guidedTourCard{
  border:1px solid #35528d;
  border-radius:14px;
  padding:12px;
  background:linear-gradient(180deg,#0f1a34,#0a1224);
  box-shadow:0 0 34px #24467b8c;
}

.guidedTourHead{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
}

.guidedTourLabel{
  font-size:11px;
  letter-spacing:1.4px;
  color:#d7e5ff;
}

.guidedTourStep{
  font-size:11px;
  letter-spacing:1px;
  color:#b7caef;
}

.guidedTourTitle{
  margin-top:7px;
  font-size:14px;
  letter-spacing:1px;
  color:#e6f0ff;
}

.guidedTourText{
  margin-top:6px;
  font-size:12px;
  color:#cad7f1;
  line-height:1.45;
}

.guidedTourActions{
  margin-top:10px;
  display:grid;
  grid-template-columns:auto 1fr auto auto;
  gap:8px;
  align-items:center;
}

.guidedTourHint{
  margin:0;
  font-size:11px;
  color:#b5c7eb;
  opacity:.88;
}

.guidedTourPrevBtn,
.guidedTourNextBtn,
.guidedTourSkipBtn{
  min-width:104px;
}

.guidedTourSkipBtn{
  border:1px solid #6d7fa8;
  background:linear-gradient(180deg,#1d2a4b,#111a31);
}

.apiBaseRow{
  margin-top:10px;
  display:grid;
  grid-template-columns:minmax(0,1fr) auto auto;
  gap:8px;
  align-items:end;
}

.apiBaseInputWrap label{
  display:block;
  margin-bottom:4px;
  font-size:11px;
}

textarea{
  width:100%;
  min-height:96px;
  background:#101428;
  border:1px solid #1e2744;
  color:var(--text);
  border-radius:10px;
  padding:10px;
  font-family:ui-monospace,Consolas,monospace;
  font-size:12px;
  resize:vertical;
}

.statusPill{
  display:inline-block;
  padding:3px 8px;
  border-radius:999px;
  font-size:11px;
  font-weight:700;
  letter-spacing:.3px;
}

.statusPill.ok{
  background:#0b2f18;
  border:1px solid #1f8249;
  color:#89ffbb;
}

.statusPill.bad{
  background:#321016;
  border:1px solid #8f2433;
  color:#ff9da9;
}

.statusPill.warn{
  background:#332407;
  border:1px solid #a06d1b;
  color:#ffd68a;
}

.cluster:first-child{
  margin-top:0;
}

.subcluster{
  margin-top:12px;
  padding:10px;
  border-radius:12px;
  border:1px solid #1c2746;
  background:linear-gradient(180deg,#0d1323,#090d17);
}
.legacyNoticePanel{
  border:1px solid #6a5a2a;
  border-radius:10px;
  background:linear-gradient(180deg,#231b08,#171105);
  padding:10px;
}
.legacyNoticeTitle{
  font-size:11px;
  letter-spacing:1.1px;
  color:#ffd98a;
  margin:0 0 6px;
}
.legacyNoticeText{
  margin:0;
  font-size:12px;
  color:#e8dcc0;
  line-height:1.35;
}
.legacyNoticeActions{
  margin-top:8px;
  display:flex;
  gap:8px;
  flex-wrap:wrap;
}
.legacyAutomationWrap{
  margin-top:10px;
}
.legacyAutomationWrap.legacyLocked{
  opacity:.42;
  filter:saturate(.55) grayscale(.2);
}
.legacyAutomationWrap.legacyLocked *{
  pointer-events:none;
}

.liveMainCluster .subcluster{
  margin-top:14px;
}

.slider{margin:12px 0}
.slider label{
  display:flex;
  justify-content:space-between;
  font-size:12px;
  align-items:center;
  gap:10px;
}

.sliderInlineControls{
  display:inline-flex;
  align-items:center;
  gap:8px;
}

.sliderInlineResetBtn{
  min-height:26px;
  padding:4px 9px;
  border-radius:8px;
  font-size:10px;
  letter-spacing:.8px;
}

.sliderValue{
  min-width:40px;
  text-align:right;
  font-variant-numeric:tabular-nums;
}

.sliderResetRow{
  margin-top:8px;
  display:grid;
  grid-template-columns:repeat(3,minmax(0,1fr));
  gap:8px;
}

.reactorRiskNotice{
  margin-top:8px;
  border:1px solid #2a3f6b;
  border-radius:10px;
  background:#091126;
  padding:8px;
  font-size:11px;
  line-height:1.35;
  color:#c3cee7;
}

.reactorRiskNotice.warn{
  border-color:#7c5b20;
  background:#241b09;
  color:#ffd98a;
}

.reactorRiskNotice.bad{
  border-color:#8f2433;
  background:#341018;
  color:#ffb3be;
}

input[type="text"],
input[type="password"],
input[type="number"],
select{
  width:100%;
  background:#101428;
  border:1px solid #1e2744;
  color:var(--text);
  border-radius:10px;
  padding:10px;
}

input[type="range"]{
  width:100%;
  display:block;
}

.controlRow{
  margin-top:10px;
  display:grid;
  grid-template-columns:repeat(4,1fr);
  gap:8px;
}

.controlRow label{
  font-size:11px;
  opacity:.9;
  display:block;
  margin-bottom:4px;
}

.secretFieldRow{
  display:grid;
  grid-template-columns:minmax(0,1fr) auto;
  gap:8px;
  align-items:center;
}

.secretToggleBtn{
  min-width:70px;
  padding:8px 10px;
}

#scope{
  margin-top:18px;
  background:radial-gradient(circle at 50% 50%, #111 0%, #000 65%, #000 100%);
  border-radius:14px;
  padding:10px;
  position:relative;
  border:1px solid #2b1c22;
  overflow:hidden;
}

canvas{width:100%;height:160px}

#canvas{height:160px}

.scopeHud{
  position:absolute;
  left:12px;
  right:12px;
  top:12px;
  display:grid;
  grid-template-columns:repeat(4,minmax(0,1fr));
  gap:6px;
  z-index:2;
  pointer-events:none;
}

.scopeChip{
  background:rgba(7,13,28,0.58);
  border:1px solid rgba(43,66,114,0.55);
  border-radius:8px;
  padding:4px 6px;
  text-align:center;
  line-height:1.1;
}

.scopeChip strong{
  display:block;
  font-size:9px;
  letter-spacing:1px;
  color:#8fa6dd;
  opacity:0.9;
}

.scopeChip span{
  display:block;
  margin-top:2px;
  font-size:11px;
  font-family:ui-monospace,Consolas,monospace;
  color:#e8f0ff;
}

#telemetryScope{
  margin-top:10px;
  background:linear-gradient(180deg,#060b19,#05070f);
  border:1px solid #1e2a4a;
  border-radius:14px;
  padding:10px;
  position:relative;
}

#telemetryCanvas{
  width:100%;
  height:140px;
}

.scopeLegend{
  margin-top:8px;
  display:grid;
  grid-template-columns:repeat(6,1fr);
  gap:6px;
  font-size:10px;
  letter-spacing:.7px;
}

.legendChip{
  background:#070d1f;
  border:1px solid #1c2948;
  border-radius:8px;
  padding:6px 8px;
  text-align:center;
}

.liveStats{
  margin-top:12px;
  display:grid;
  grid-template-columns:repeat(3,minmax(0,1fr));
  gap:10px;
  align-items:start;
}

.statGroup{
  background:#060c1b;
  border:1px solid #1a2441;
  border-radius:12px;
  padding:8px;
}

.statGroupTitle{
  margin:0 0 8px;
  font-size:10px;
  letter-spacing:1.2px;
  color:#8fa6dd;
  opacity:.92;
}

.statGrid{
  display:grid;
  grid-template-columns:repeat(2,minmax(0,1fr));
  gap:6px;
}

.liveStat{
  background:#081022;
  border:1px solid #1a2441;
  border-radius:10px;
  padding:7px 6px;
  text-align:center;
  font-family:ui-monospace,Consolas,monospace;
  min-height:48px;
  display:flex;
  flex-direction:column;
  justify-content:center;
}

.liveStat strong{
  display:block;
  font-size:10px;
  color:#9fb0db;
  letter-spacing:1px;
}

.liveStat span{
  display:block;
  margin-top:3px;
  font-size:12px;
  color:#f3f7ff;
}

.genreGrid button{
  font-size:12px;
}

#dropOverlay{
  position:absolute;
  inset:0;
  display:none;
  align-items:center;
  justify-content:center;
  font-size:32px;
  font-weight:900;
  letter-spacing:6px;
  color:white;
  pointer-events:none;
  z-index:3;
}

.badge{
  padding:6px 10px;
  border-radius:10px;
  font-size:11px;
  font-weight:700;
  text-align:center;
}

.ok{background:#072;color:var(--ok)}
.warn{background:#221;color:var(--warn)}
.bad{background:#200;color:var(--bad)}

.telemetry{
  margin-top:10px;
  display:grid;
  grid-template-columns:repeat(4,1fr);
  gap:6px;
  font-family:monospace;
  font-size:11px;
}

.telemetry div{
  background:#060812;
  padding:6px;
  border-radius:8px;
  text-align:center;
}

.fixtureToolbar{
  display:grid;
  grid-template-columns:repeat(5,minmax(0,1fr));
  gap:8px;
}

.routeModesWrap{
  grid-column:span 2;
}

.routeChipGroup{
  display:grid;
  grid-template-columns:repeat(3,minmax(0,1fr));
  gap:8px;
}

.routeChipToggle{
  border:1px solid #233055;
  background:linear-gradient(180deg,#141c34,#0f1528);
  border-radius:10px;
  padding:10px 12px;
  font-size:12px;
  letter-spacing:1px;
}

.routeChipToggle.active{
  background:linear-gradient(180deg,#1f3b6f,#13274a);
  border-color:#4f78bf;
  box-shadow:0 0 12px #315ca366;
}

.routeGuide{
  margin-top:10px;
  border:1px solid #22345a;
  border-radius:12px;
  background:linear-gradient(180deg,#0d1730,#0a1225);
  padding:10px;
}

.routeGuideGrid{
  display:grid;
  grid-template-columns:repeat(3,minmax(0,1fr));
  gap:8px;
}

.routeGuideCard{
  background:#091125;
  border:1px solid #20355f;
  border-radius:10px;
  padding:8px;
}

.routeGuideCard strong{
  display:block;
  font-size:11px;
  letter-spacing:.8px;
  color:#c8d8ff;
}

.routeGuideCard span{
  display:block;
  margin-top:5px;
  font-size:11px;
  line-height:1.35;
  color:#c3cee7;
}

.twitchPrefixPanel{
  margin-top:10px;
  border:1px solid #22345a;
  border-radius:12px;
  background:linear-gradient(180deg,#0d1730,#0a1225);
  padding:10px;
}

.twitchPrefixGrid{
  margin-top:8px;
  display:grid;
  grid-template-columns:repeat(4,minmax(0,1fr));
  gap:8px;
  align-items:end;
}

.prefixReadonly{
  opacity:.86;
}

.prefixDisabled{
  opacity:.45;
  filter:grayscale(.35);
}

.fixtureModBrandStatus{
  margin-top:6px;
  font-size:11px;
}

.audioGuide{
  margin-top:8px;
  border:1px solid #22345a;
  border-radius:12px;
  background:linear-gradient(180deg,#0d1730,#0a1225);
  padding:10px;
}

.audioGuideGrid{
  display:grid;
  grid-template-columns:repeat(3,minmax(0,1fr));
  gap:8px;
}

.audioQuickPresetGrid{
  margin-top:8px;
}

.audioQuickPresetGrid button{
  min-height:34px;
  font-size:11px;
}

.audioQuickPresetHint{
  margin-top:6px;
}

.audioQuickSecondaryRow{
  margin-top:10px;
  display:grid;
  grid-template-columns:repeat(2,minmax(0,1fr));
  gap:8px;
}

.audioQuickActionRow{
  margin-top:10px;
}

.audioQuickActionRow button{
  min-height:42px;
}

.audioReactMap{
  margin-top:10px;
  padding:10px;
  border:1px solid #27457a;
  border-radius:12px;
  background:linear-gradient(180deg,#0f1a34,#0a1429);
}

.audioReactMapHeader{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:8px;
}

.audioReactMapDropToggle{
  display:flex;
  align-items:center;
  gap:6px;
  font-size:11px;
  letter-spacing:.8px;
}

.audioReactPolicyBar{
  margin-top:8px;
  display:grid;
  grid-template-columns:repeat(3,minmax(0,1fr));
  gap:8px;
}

.audioReactPolicyBar label{
  display:flex;
  align-items:center;
  gap:6px;
  font-size:11px;
  letter-spacing:.7px;
}

.audioReactCompatSummary{
  grid-column:1 / span 3;
  border:1px solid #2c456f;
  border-radius:8px;
  background:#0b1730;
  padding:6px 8px;
  font-size:10px;
  letter-spacing:.55px;
  color:#c4d4ef;
}

.audioReactMapRows{
  margin-top:8px;
  display:grid;
  gap:8px;
}

.audioReactMapRow{
  border:1px solid #25406e;
  border-radius:10px;
  padding:8px;
  background:rgba(7,15,33,0.75);
}

.audioReactMapTop{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:8px;
}

.audioReactMapTop label{
  margin:0;
}

.audioReactAmountWrap{
  display:flex;
  align-items:center;
  gap:8px;
  min-width:170px;
}

.audioReactAmountWrap input[type="range"]{
  width:110px;
  margin:0;
}

.audioReactSources{
  margin-top:7px;
  display:flex;
  flex-wrap:wrap;
  gap:6px;
}

.audioReactSourceBtn{
  min-height:30px;
  padding:4px 8px;
  border:1px solid #2b4f84;
  border-radius:999px;
  background:#0d1a36;
  color:#c4d6ff;
  font-size:11px;
  letter-spacing:.7px;
}

.audioReactSourceBtn.active{
  border-color:#4dd7ff;
  background:#153d5d;
  color:#f5fbff;
}

.audioReactSourceBtn.incompatible{
  border-color:#5c3650;
  color:#c5a8ba;
}

.audioReactSourceBtn:disabled{
  opacity:.46;
  cursor:not-allowed;
}

.audioReactMapActions{
  margin-top:10px;
  display:grid;
  grid-template-columns:repeat(2,minmax(0,1fr));
  gap:8px;
}

.audioReactMapActions input{
  grid-column:1 / span 2;
  font-size:11px;
}

.audioGuideCard{
  background:#091125;
  border:1px solid #20355f;
  border-radius:10px;
  padding:8px;
}

.audioGuideCard strong{
  display:block;
  font-size:11px;
  letter-spacing:.8px;
  color:#c8d8ff;
}

.audioGuideCard span{
  display:block;
  margin-top:5px;
  font-size:11px;
  line-height:1.35;
  color:#c3cee7;
}

.pairActionRow{
  border:1px solid #2a3d66;
  border-radius:12px;
  background:linear-gradient(180deg,#101b34,#0b1326);
  padding:8px;
}

.pairActionRow .grid2{
  margin:0;
}

.pairDiscoverBtn{
  border:1px solid #4b5f8f;
  background:linear-gradient(180deg,#1a2b4f,#121f3b);
}

.pairLinkBtn{
  border:1px solid #8f2f4d;
  background:linear-gradient(180deg,#8b001f,#5d0016);
}

.pairBridgeSaveRow{
  margin-top:8px;
}

.pairBridgeSaveBtn{
  width:100%;
  border:1px solid #365987;
  background:linear-gradient(180deg,#173258,#112543);
}

.fixtureGrid{
  margin-top:10px;
  display:grid;
  grid-template-columns:repeat(4,1fr);
  gap:8px;
}

.hidden{
  display:none !important;
}

.modUiToolbar{
  display:grid;
  grid-template-columns:2fr 1fr 1fr;
  gap:8px;
  align-items:end;
}

.modUiFrameWrap{
  margin-top:10px;
  border:1px solid #1f2c4f;
  border-radius:10px;
  overflow:hidden;
  background:#060a14;
}

#modUiFrame{
  width:100%;
  min-height:68vh;
  border:0;
  background:#ffffff;
}

.modUiEmpty{
  margin-top:10px;
  border:1px dashed #2a395f;
  border-radius:10px;
  padding:14px;
  color:#b9c7e6;
  font-size:12px;
}

.modDropZone{
  margin-top:10px;
  border:1px dashed #2f4b84;
  border-radius:10px;
  padding:12px;
  background:rgba(9,15,30,0.55);
  transition:border-color .14s ease, background .14s ease;
}

.modDropZone.dragOver{
  border-color:#6da3ff;
  background:rgba(18,31,59,0.78);
}

.tableWrap{
  margin-top:10px;
  border:1px solid #1f2c4f;
  border-radius:10px;
  overflow:auto;
}

table{
  width:100%;
  border-collapse:collapse;
  font-size:12px;
}

th, td{
  text-align:left;
  padding:8px;
  border-bottom:1px solid #1a2441;
  white-space:nowrap;
}

th{
  color:#b5c1e6;
  font-weight:700;
}

tr:last-child td{
  border-bottom:none;
}

.mono{
  font-family:ui-monospace,Consolas,monospace;
}

.hint{
  font-size:11px;
  opacity:.8;
}

.infoTip{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  width:15px;
  height:15px;
  margin-left:6px;
  border-radius:999px;
  border:1px solid #315089;
  background:#0f1830;
  color:#9fc2ff;
  font-size:10px;
  line-height:1;
  cursor:help;
}

@media (max-width:1100px){
  .liveStats{grid-template-columns:1fr 1fr}
}

@media (max-width:980px), (max-height:760px){
  .panel{margin:8px;padding:12px}
  .tabs{
    position:sticky;
    top:0;
    z-index:1100;
    background:linear-gradient(180deg,rgba(7,10,18,.95),rgba(7,10,18,.75));
    backdrop-filter:blur(3px);
    padding-top:6px;
    padding-bottom:4px;
  }
  .tabBtn{
    min-height:40px;
    padding:8px 10px;
    font-size:12px;
  }
  .liveMainCluster .grid3,
  .liveMainCluster .grid4,
  .liveMainCluster .grid5,
  .liveMainCluster .grid6{
    grid-template-columns:repeat(2,minmax(0,1fr));
  }
  .liveMainCluster .grid6 button[data-genre="auto"]{
    grid-column:span 2;
  }
}

@media (max-width:700px){
  #health.badge{width:180px}
  #netBadge.badge{width:80px}
  .grid4{grid-template-columns:1fr 1fr}
  .grid5{grid-template-columns:1fr 1fr}
  .grid6{grid-template-columns:1fr 1fr}
  .telemetry{grid-template-columns:1fr 1fr}
  .controlRow{grid-template-columns:1fr 1fr}
  .fixtureGrid{grid-template-columns:1fr 1fr}
  .fixtureToolbar{grid-template-columns:1fr}
  .twitchPrefixGrid{grid-template-columns:1fr}
  .routeModesWrap{grid-column:span 1}
  .routeChipGroup{grid-template-columns:1fr}
  .scopeLegend{grid-template-columns:1fr 1fr 1fr}
  .liveStats{grid-template-columns:1fr}
  .scopeHud{grid-template-columns:1fr 1fr}
  .apiBaseRow{grid-template-columns:1fr}
  .routeGuideGrid{grid-template-columns:1fr}
  .audioGuideGrid{grid-template-columns:1fr}
  .audioQuickSecondaryRow{grid-template-columns:1fr}
  .audioReactMapHeader{flex-direction:column;align-items:flex-start}
  .audioReactAmountWrap{min-width:0}
  .audioReactMapActions{grid-template-columns:1fr}
  .audioReactMapActions input{grid-column:1}
  .modUiToolbar{grid-template-columns:1fr}
  .onboardGateActions{grid-template-columns:1fr}
  .guidedTourActions{grid-template-columns:1fr}
  .guidedTourHint{order:4}
  .sliderResetRow{grid-template-columns:1fr}
}

@media (max-width:620px), (max-height:620px){
  .controlRow{grid-template-columns:1fr}
  .telemetry{grid-template-columns:1fr}
  .liveMainCluster .grid3,
  .liveMainCluster .grid4,
  .liveMainCluster .grid5,
  .liveMainCluster .grid6{
    grid-template-columns:1fr;
  }
  .liveMainCluster .grid6 button[data-genre="auto"]{
    grid-column:auto;
  }
  .scopeLegend{grid-template-columns:1fr 1fr}
}
</style>
</head>

<body>
<header>
  <div>
    <h1>RAVELINK</h1>
    <div class="sub">reactive lighting bridge // ready for creators, streamers, and live setups</div>
    <div class="quickLinks">
      <a href="#deviceRouting" id="jumpRoutingLink">Device Routing</a>
      <a href="#modCenter" id="jumpModsLink">Mod Center</a>
    </div>
  </div>
  <div class="headerRight">
    <div class="themeWrap">
      <button id="themeCogBtn" type="button" class="iconBtn" title="Theme settings" aria-label="Theme settings">&#9881;</button>
      <div id="themePanel" class="themePanel hidden">
        <h4>THEME PRESETS</h4>
        <div class="themePresetGrid">
          <button type="button" class="themePresetBtn" data-theme-preset="midnight">MIDNIGHT</button>
          <button type="button" class="themePresetBtn" data-theme-preset="ember">EMBER</button>
          <button type="button" class="themePresetBtn" data-theme-preset="ocean">OCEAN</button>
          <button type="button" class="themePresetBtn" data-theme-preset="matrix">MATRIX</button>
        </div>
        <h4 style="margin-top:10px;">CUSTOM COLORS</h4>
        <div class="themeCustomRow">
          <div>
            <label for="themeLogoColor">LOGO / ACTIVE</label>
            <input id="themeLogoColor" class="themeColorPicker" type="color" value="#8b001f" />
          </div>
          <div>
            <label for="themeButtonColor">BUTTON BASE</label>
            <input id="themeButtonColor" class="themeColorPicker" type="color" value="#14182c" />
          </div>
        </div>
        <div class="themeCustomRow">
          <button id="themeResetBtn" type="button" class="themePresetBtn">RESET THEME</button>
          <button id="themeCloseBtn" type="button" class="themePresetBtn">CLOSE</button>
        </div>
        <h4 style="margin-top:10px;">ONBOARDING</h4>
        <div class="themeCustomRow">
          <button id="onboardStartBtn" type="button" class="themePresetBtn">START ONBOARDING</button>
          <button id="onboardResetBtn" type="button" class="themePresetBtn">RESET ONBOARDING</button>
        </div>
        <h4 style="margin-top:10px;">DEV / DEBUG</h4>
        <div class="themeCustomRow">
          <button id="devDebugToggleBtn" type="button" class="themePresetBtn bad">DEV DEBUG OFF</button>
        </div>
        <p id="devDebugStatus" class="hint" style="margin:8px 2px 0;">
          Unlocks destructive 20-60Hz overclock controls. Use only for controlled testing.
        </p>
        <div id="devToolsPanel" class="hidden">
          <h4 style="margin-top:10px;">DEV TOOLS</h4>
          <div class="themeCustomRow">
            <button id="devToolRuntimeBtn" type="button" class="themePresetBtn">RUNTIME</button>
            <button id="devToolConnectivityBtn" type="button" class="themePresetBtn">CONNECTIVITY</button>
          </div>
          <div class="themeCustomRow">
            <button id="devToolHooksBtn" type="button" class="themePresetBtn">MOD HOOKS</button>
            <button id="devToolTiersBtn" type="button" class="themePresetBtn">OC TIERS</button>
          </div>
          <input id="devToolsStatus" class="themeStatusField" type="text" value="DEV tools idle." readonly>
          <textarea id="devToolsDump" class="themeDebugDump" readonly>Run a DEV tool to inspect live JSON snapshots.</textarea>
        </div>
        <h4 style="margin-top:10px;">MIDI TAB</h4>
        <div class="themeCustomRow">
          <button id="midiTabToggleBtn" type="button" class="themePresetBtn">MIDI TAB OFF (NO DEVICE)</button>
        </div>
        <input id="midiCogStatus" class="themeStatusField" type="text" value="MIDI not detected yet." readonly>
        <p class="hint" style="margin:8px 2px 0;">
          If you skip onboarding, you can relaunch it here anytime.
        </p>
      </div>
    </div>
    <button id="obsDockCompactBtn" type="button" class="iconBtn hidden" title="Toggle compact OBS dock layout">DK</button>
    <div id="health" class="badge ok">ENGINE OK</div>
    <div id="netBadge" class="badge ok">NET OK</div>
  </div>
</header>

<div id="devOcAckGate" class="devAckGate hidden" aria-hidden="true">
  <div class="devAckCard">
    <h3 class="devAckTitle">UNSAFE DEV OVERCLOCK CHECK</h3>
    <p class="hint" style="margin:0 0 4px;">
      Last gate before arming destructive 20-60Hz overclock. This is intentionally absurd.
    </p>
    <label for="devOcAckInput">TYPE THE EXACT PHRASE TO ARM</label>
    <input
      id="devOcAckInput"
      class="devAckInput"
      type="text"
      autocomplete="off"
      spellcheck="false"
      placeholder="pressing enter closes menu lol"
    />
    <input id="devOcAckPhrase" class="devAckPhrase" type="text" readonly value="" />
    <div class="themeCustomRow">
      <button id="devOcAckCancelBtn" type="button" class="themePresetBtn">CANCEL</button>
      <button id="devOcAckConfirmBtn" type="button" class="themePresetBtn bad">ARM DEV HZ</button>
    </div>
  </div>
</div>

<div
  class="subcluster collapsible supportPanel"
  id="supportPanel"
  data-collapsible-key="supportPanel"
  data-collapsed-default-mobile="1"
>
  <div class="clusterHeaderRow">
    <h3>OPTIONAL SUPPORT</h3>
    <button
      type="button"
      class="collapseBtn"
      data-collapse-btn
      aria-expanded="true"
      title="Show or hide optional support link."
    >
      COLLAPSE
    </button>
  </div>
  <div class="clusterBody">
    <span class="supportMeta">If this engine helps, optional support:</span>
    <a class="supportLink" href="https://ko-fi.com/namesroby" target="_blank" rel="noopener noreferrer">
      ko-fi.com/namesroby
    </a>
  </div>
</div>

<div id="onboardGate" class="onboardGate hidden" aria-live="polite">
  <div class="onboardGateCard">
    <div class="onboardGateTitle">FIRST-TIME SETUP REQUIRED</div>
    <div class="onboardGateText">
      Follow <b>ONBOARDING</b> first. The rest of the UI is dimmed until you confirm.
      This prevents routing and pairing mistakes on first launch.
    </div>
    <div class="onboardGateActions">
      <p class="hint">After confirming, this prompt stays hidden unless browser storage is cleared.</p>
      <button id="onboardAckBtn" type="button" class="onboardAckBtn">I UNDERSTAND</button>
    </div>
  </div>
</div>

<div id="hueEntGuideGate" class="hueEntGuideGate hidden" aria-live="polite">
  <div class="hueEntGuideCard">
    <div class="hueEntGuideTitle">HUE ENTERTAINMENT IS REQUIRED FOR RELIABLE ENGINE SYNC</div>
    <div class="hueEntGuideText">
      Before discovery/pairing, make sure a Hue Entertainment area exists. Without it, Hue falls back to slower REST behavior and can fail to stream at engine rate.
    </div>
    <ol class="hueEntGuideSteps">
      <li>Open Hue app -> <b>Settings</b> -> <b>Entertainment areas</b>.</li>
      <li>Create an area and add the exact lights you want in RaveLink.</li>
      <li>Save it, then use that area name or id in <b>ENT AREA (NAME/ID)</b>.</li>
    </ol>
    <div class="hueEntGuideActions">
      <button id="hueEntGuideAckBtn" type="button" class="hueEntGuideAckBtn">I UNDERSTAND</button>
    </div>
  </div>
</div>

<div id="guidedTourGate" class="guidedTourGate hidden" aria-live="polite">
  <div class="guidedTourCard">
    <div class="guidedTourHead">
      <div class="guidedTourLabel">RAVELINK ONBOARDING</div>
      <div id="guidedTourStep" class="guidedTourStep">1 / 1</div>
    </div>
    <div id="guidedTourTitle" class="guidedTourTitle">Welcome</div>
    <div id="guidedTourText" class="guidedTourText">This guide explains the most important controls.</div>
    <div class="guidedTourActions">
      <button id="guidedTourSkipBtn" type="button" class="guidedTourSkipBtn">SKIP</button>
      <p class="guidedTourHint">You can reopen this guide anytime from the settings cog.</p>
      <button id="guidedTourPrevBtn" type="button" class="guidedTourPrevBtn">BACK</button>
      <button id="guidedTourNextBtn" type="button" class="guidedTourNextBtn">NEXT</button>
    </div>
  </div>
</div>

<div id="tabsBar" class="tabs">
  <button class="tabBtn active" type="button" data-tab-btn="live">LIVE</button>
  <button class="tabBtn" type="button" data-tab-btn="fixtures">FIXTURES</button>
  <button class="tabBtn" type="button" data-tab-btn="audio">AUDIO</button>
  <button id="midiTabBtn" class="tabBtn hidden" type="button" data-tab-btn="midi">MIDI</button>
  <button class="tabBtn" type="button" data-tab-btn="custom">CUSTOM</button>
  <button class="tabBtn" type="button" data-tab-btn="mods">MODS</button>
  <button class="tabBtn" type="button" data-tab-btn="system">SYSTEM</button>
</div>

<div class="panel tabPage active" data-tab="live">
  <div class="cluster liveMainCluster">
    <h3>POWER <span class="infoTip" title="RAVE ON starts live reactive output. RAVE OFF stops reactive output. PANIC forces immediate blackout intent.">?</span></h3>
    <div class="grid3">
      <button id="onBtn" type="button">RAVE ON</button>
      <button id="offBtn" type="button">RAVE OFF</button>
      <button id="panicBtn" type="button" class="bad">PANIC</button>
    </div>

    <h3>MODE <span class="infoTip" title="AUTO self-selects mode. GAME (CLAMP) is steadier with fewer fast jumps. BPM (INTERPRET) is more reactive and switches faster.">?</span></h3>
    <div class="grid3">
      <button id="modeAutoBtn" type="button">AUTO</button>
      <button id="gameBtn" type="button">GAME (CLAMP)</button>
      <button id="bpmBtn" type="button">BPM (INTERPRET)</button>
    </div>

    <h3>AUTO SWITCH PROFILE <span class="infoTip" title="REACTIVE changes behavior/scenes quickly, BALANCED is moderate, CINEMATIC holds longer and transitions slowly.">?</span></h3>
    <div class="grid3">
      <button type="button" data-auto-profile="reactive">REACTIVE</button>
      <button type="button" data-auto-profile="balanced">BALANCED</button>
      <button type="button" data-auto-profile="cinematic">CINEMATIC</button>
    </div>

    <h3>AUDIO REACTIVITY <span class="infoTip" title="BALANCED is neutral. AGGRESSIVE boosts sensitivity and pulse triggers. PRECISION is stricter and calmer.">?</span></h3>
    <div class="grid3">
      <button type="button" data-audio-reactivity="balanced">BALANCED</button>
      <button type="button" data-audio-reactivity="aggressive">AGGRESSIVE</button>
      <button type="button" data-audio-reactivity="precision">PRECISION</button>
    </div>

    <div class="subcluster collapsible" data-collapsible-key="liveAdvancedControls" data-collapsed-default-mobile="1">
      <div class="clusterHeaderRow">
        <h3>ADVANCED LIVE CONTROLS</h3>
        <button type="button" class="collapseBtn" data-collapse-btn aria-expanded="true" title="Show or hide advanced live controls.">COLLAPSE</button>
      </div>
      <div class="clusterBody">
        <h3>ADAPTIVE META <span class="infoTip" title="Meta Auto infers genre from live audio metrics and controls profile/reactivity/Hz. Choosing manual PROFILE, AUDIO REACTIVITY, GENRE, DECADE, or OVERCLOCK automatically turns Meta Auto off.">?</span></h3>
        <div class="grid2">
          <button id="metaAutoOnBtn" type="button">META AUTO ON</button>
          <button id="metaAutoOffBtn" type="button">META AUTO OFF</button>
        </div>

        <h3>SCENE LOCK <span class="infoTip" title="AUTO rotates scenes. IDLE/FLOW/PULSE lock a fixed scene until changed (FLOW locks to a concrete flow scene).">?</span></h3>
        <div class="sceneLockRows">
          <div class="grid4">
            <button id="sceneAutoBtn" type="button" data-scene="auto">AUTO</button>
            <button type="button" data-scene="idle_soft">IDLE</button>
            <button type="button" data-scene="flow">FLOW</button>
            <button type="button" data-scene="pulse_strobe">PULSE</button>
          </div>
          <div class="grid2 sceneSyncGrid">
            <button id="sceneSyncOnBtn" type="button">SYNC FIXTURES</button>
            <button id="sceneSyncOffBtn" type="button">FIXTURE DESYNC</button>
          </div>
        </div>
        <p id="sceneSyncStat" class="hint">SCENE LINK: SYNCED</p>
        <div class="slider">
          <label>
            <span>FLOW INTENSITY</span>
            <span class="sliderInlineControls">
              <span id="flowIntensityVal" class="sliderValue">1.00x</span>
              <button id="flowResetBtn" type="button" class="sliderInlineResetBtn">RESET</button>
            </span>
          </label>
          <input id="flowIntensity" type="range" min="35" max="250" step="1" value="100">
        </div>
        <p class="hint">Lower = smoother/calm flow, higher = faster/more animated flow.</p>

        <h3>OVERCLOCK <span class="infoTip" title="Higher Hz increases visual motion and network load. Use Entertainment mode for highest stable rates.">?</span></h3>
        <div class="grid4">
          <button id="ocOffBtn" type="button">SLOW 2HZ</button>
          <button id="ocOnBtn" type="button">SLOW 4HZ</button>
          <button id="ocTurboBtn" type="button" class="warn">DEFAULT 6HZ</button>
          <button id="ocUltraBtn" type="button" class="warn">ULTRA 8HZ</button>
          <button id="ocExtremeBtn" type="button" class="warn">EXTREME 10HZ</button>
          <button id="ocInsaneBtn" type="button" class="bad">INSANE 12HZ</button>
          <button id="ocHyperBtn" type="button" class="bad">HYPER 14HZ</button>
          <button id="ocLudicrousBtn" type="button" class="bad">LUDICROUS 16HZ</button>
        </div>
        <div id="ocDevCluster" class="hidden">
          <h3>UNSAFE DEV OVERCLOCK <span class="infoTip" title="Manual-only destructive rates. Never auto-mapped by profile/genre/scene and may break output stability.">?</span></h3>
          <div class="grid5">
            <button id="ocDev20Btn" type="button" class="bad">DEV 20HZ</button>
            <button id="ocDev30Btn" type="button" class="bad">DEV 30HZ</button>
            <button id="ocDev40Btn" type="button" class="bad">DEV 40HZ</button>
            <button id="ocDev50Btn" type="button" class="bad">DEV 50HZ</button>
            <button id="ocDev60Btn" type="button" class="bad">DEV 60HZ</button>
          </div>
          <p class="hint">Severe warning: these rates are intentionally destructive and unpredictable. Use only on isolated test rigs.</p>
        </div>
        <p class="hint">
          Practical rate guidance: Hue REST is usually best at 2-6Hz. Use Hue Entertainment for 8-16Hz.
          WiZ can often run faster, but weak Wi-Fi can still cause skips.
        </p>

        <h3>GENRE <span class="infoTip" title="Genre changes behavior thresholds and palette identity. AUTO MIX lets engine infer genre live.">?</span></h3>
        <div id="genreGrid" class="grid6 genreGrid">
          <button type="button" data-genre="edm">EDM</button>
          <button type="button" data-genre="hiphop">HIP-HOP</button>
          <button type="button" data-genre="metal">METAL</button>
          <button type="button" data-genre="ambient">AMBIENT</button>
          <button type="button" data-genre="house">HOUSE</button>
          <button type="button" data-genre="trance">TRANCE</button>
          <button type="button" data-genre="dnb">DNB</button>
          <button type="button" data-genre="pop">POP</button>
          <button type="button" data-genre="rock">ROCK</button>
          <button type="button" data-genre="rnb">R&B</button>
          <button type="button" data-genre="techno">TECHNO</button>
          <button type="button" data-genre="media">MEDIA</button>
          <button type="button" data-genre="auto">AUTO MIX</button>
        </div>

        <h3>DECADE TUNE <span class="infoTip" title="Decade changes tempo/energy bias: 90S is smoother, 00S mild retro, 10S neutral, 20S more aggressive.">?</span></h3>
        <div class="grid5">
          <button type="button" data-decade-mode="auto">AUTO</button>
          <button type="button" data-decade-mode="90s">90S</button>
          <button type="button" data-decade-mode="00s">00S</button>
          <button type="button" data-decade-mode="10s">10S</button>
          <button type="button" data-decade-mode="20s">20S</button>
        </div>
      </div>
    </div>
  </div>

  <div class="cluster collapsible" data-collapsible-key="liveAnalyzer" data-collapsed-default-mobile="1">
    <div class="clusterHeaderRow">
      <h3>REACTOR // LIVE ANALYZER</h3>
      <button type="button" class="collapseBtn" data-collapse-btn aria-expanded="true" title="Show or hide analyzer visuals and deep telemetry.">COLLAPSE</button>
    </div>
    <div class="clusterBody">
    <div class="slider">
      <label>
        <span>MASTER</span>
        <span class="sliderInlineControls">
          <span id="masterVal" class="sliderValue">1.00</span>
          <button id="masterInlineResetBtn" type="button" class="sliderInlineResetBtn">RESET</button>
        </span>
      </label>
      <input id="master" type="range" min="0" max="100" value="50">
    </div>

    <div class="slider">
      <label>
        <span>DROP IMPACT</span>
        <span class="sliderInlineControls">
          <span id="dropVal" class="sliderValue">1.0</span>
          <button id="dropInlineResetBtn" type="button" class="sliderInlineResetBtn">RESET</button>
        </span>
      </label>
      <input id="dropIntensity" type="range" min="50" max="200" value="100">
    </div>
    <div class="sliderResetRow">
      <button id="reactorResetBtn" type="button">RESET BOTH</button>
    </div>
    <div id="reactorRiskNotice" class="reactorRiskNotice warn">
      Caution: raising MASTER and DROP IMPACT often hurts output quality more than it helps.
      This is especially risky with high OVERCLOCK levels.
    </div>

    <div id="scope">
      <div class="scopeHud">
        <div class="scopeChip"><strong>DRIVE</strong><span id="scopeDrive">0.00</span></div>
        <div class="scopeChip"><strong>MOTION</strong><span id="scopeMotion">0.00</span></div>
        <div class="scopeChip"><strong>SCENE</strong><span id="scopeScene">-</span></div>
        <div class="scopeChip"><strong>BEHAV</strong><span id="scopeBehav">-</span></div>
      </div>
      <canvas id="canvas"></canvas>
      <div id="dropOverlay">DROP</div>
    </div>

    <div id="telemetryScope">
      <canvas id="telemetryCanvas"></canvas>
      <div class="scopeLegend">
        <div class="legendChip">RED = ENERGY</div>
        <div class="legendChip">CYAN = RMS</div>
        <div class="legendChip">YELLOW = FLUX</div>
        <div class="legendChip">ORANGE = HUE LAT</div>
        <div class="legendChip">GREEN = WIZ LAT</div>
        <div class="legendChip">WHITE BARS = DROP</div>
      </div>
    </div>

    <div class="liveStats">
      <div class="statGroup">
        <div class="statGroupTitle">CORE SIGNAL</div>
        <div class="statGrid">
          <div class="liveStat"><strong>RMS</strong><span id="rms">0.00</span></div>
          <div class="liveStat"><strong>ENG</strong><span id="eng">0.00</span></div>
          <div class="liveStat"><strong>MODE</strong><span id="mode">-</span></div>
          <div class="liveStat"><strong>GENRE</strong><span id="genreStat">-</span></div>
          <div class="liveStat"><strong>DECADE</strong><span id="decadeStat">AUTO</span></div>
          <div class="liveStat"><strong>SCENE</strong><span id="scene">-</span></div>
        </div>
      </div>

      <div class="statGroup">
        <div class="statGroupTitle">ADAPTIVE STATE</div>
        <div class="statGrid">
          <div class="liveStat"><strong>BEHAV</strong><span id="behavior">-</span></div>
          <div class="liveStat"><strong>PHRASE</strong><span id="phrase">-</span></div>
          <div class="liveStat"><strong>DROP</strong><span id="dropStat">NO</span></div>
          <div class="liveStat"><strong>AUTO</strong><span id="autoProfile">-</span></div>
          <div class="liveStat"><strong>A-REACT</strong><span id="audioReact">-</span></div>
          <div class="liveStat"><strong>META</strong><span id="metaAutoStat">OFF</span></div>
          <div class="liveStat"><strong>FLOW X</strong><span id="flowStat">1.00x</span></div>
        </div>
      </div>

      <div class="statGroup">
        <div class="statGroupTitle">TRANSPORT</div>
        <div class="statGrid">
          <div class="liveStat"><strong>HUE STATE</strong><span id="hState">OK</span></div>
          <div class="liveStat"><strong>WIZ STATE</strong><span id="wState">OK</span></div>
          <div class="liveStat"><strong>HUE LAT</strong><span id="hLat">0</span></div>
          <div class="liveStat"><strong>WIZ LAT</strong><span id="wLat">0</span></div>
          <div class="liveStat"><strong>HUE SENT</strong><span id="hSent">0</span></div>
          <div class="liveStat"><strong>WIZ SENT</strong><span id="wSent">0</span></div>
          <div class="liveStat"><strong>HUE SKIP</strong><span id="hSkip">0</span></div>
          <div class="liveStat"><strong>WIZ SKIP</strong><span id="wSkip">0</span></div>
        </div>
      </div>
    </div>
    </div>
  </div>
</div>

<div class="panel tabPage" data-tab="fixtures">
  <div class="cluster">
    <h3>FIXTURE PAIRING / DEVICE SETUP</h3>
    <div class="fixtureGrid">
      <div>
        <label for="fxBrand">BRAND</label>
        <select id="fxBrand">
          <option value="hue">Hue</option>
          <option value="wiz">WiZ</option>
          <optgroup id="fxModBrandGroup" label="Mod Brands (locked)" disabled>
            <option value="" disabled>No mod brands detected</option>
          </optgroup>
        </select>
        <div id="fxModBrandStatus" class="hint fixtureModBrandStatus prefixDisabled">
          Mod fixture brands unlock when mods are discovered.
        </div>
      </div>
      <div id="fxModBrandWrap" class="hidden">
        <label for="fxModBrandId">MOD BRAND ID <span class="infoTip" title="Lowercase adapter brand id provided by your mod (example: http-rgb).">?</span></label>
        <input id="fxModBrandId" class="mono" type="text" placeholder="example: http-rgb" autocomplete="off" spellcheck="false" maxlength="32">
      </div>
      <div>
        <label for="fxId">ID</label>
        <input id="fxId" type="text" placeholder="auto if blank">
      </div>
      <div>
        <label for="fxZone">ZONE</label>
        <input id="fxZone" type="text" placeholder="custom path (e.g. desk-left)">
      </div>
      <div>
        <label for="fxEnabled">ENABLED</label>
        <select id="fxEnabled">
          <option value="true">true</option>
          <option value="false">false</option>
        </select>
      </div>
      <div id="fxHueLightWrap">
        <label for="fxLightId">HUE LIGHT ID <span class="infoTip" title="The numeric Hue light id for REST commands. Use the same id shown by the Hue API/bridge app.">?</span></label>
        <input id="fxLightId" type="number" min="1" value="1">
      </div>
      <div id="fxWizIpWrap" class="hidden">
        <label id="fxWizIpLabel" for="fxWizIp">WIZ IP <span class="infoTip" title="LAN IP of the WiZ fixture. One fixture per entry in this form.">?</span></label>
        <div class="secretFieldRow">
          <input id="fxWizIp" type="password" placeholder="192.168.x.x" autocomplete="off">
          <button id="fxWizIpShowBtn" type="button" class="warn secretToggleBtn" title="Reveal or hide this sensitive field.">SHOW</button>
        </div>
      </div>
      <div class="grid2">
        <button id="fxSaveBtn" type="button" title="Save this fixture entry to fixtures.config.json.">SAVE FIXTURE</button>
        <button id="fxResetBtn" type="button" title="Clear all fixture form fields.">CLEAR FORM</button>
      </div>
      <input id="fxEngineEnabled" type="hidden" value="true">
      <input id="fxCustomEnabled" type="hidden" value="false">
      <input id="fxTwitchEnabled" type="hidden" value="true">
      <input id="fxControlMode" type="hidden" value="engine">
      <input id="fxEngineBinding" type="hidden" value="hue">
      <input id="fxOriginalId" type="hidden" value="">
      <div id="fxCompatHint" class="hidden"></div>
    </div>

    <div id="fxHueBridgeBlock" class="subcluster">
      <h3>HUE BRIDGE / PAIRING</h3>
      <div class="fixtureGrid">
      <div id="fxHueBridgeWrap">
        <label for="fxBridgeIp">HUE BRIDGE IP <span class="infoTip" title="Bridge LAN IP. Discover fills this automatically on the current network.">?</span></label>
        <div class="secretFieldRow">
          <input id="fxBridgeIp" type="password" placeholder="192.168.x.x" autocomplete="off">
          <button id="fxBridgeIpShowBtn" type="button" class="warn secretToggleBtn" title="Reveal or hide this sensitive field.">SHOW</button>
        </div>
      </div>
      <div id="fxHueUserWrap">
        <label for="fxUsername">HUE USERNAME <span class="infoTip" title="Hue application key used for REST and entertainment setup. Pairing generates this for you.">?</span></label>
        <div class="secretFieldRow">
          <input id="fxUsername" type="password" class="mono" placeholder="app key" autocomplete="off">
          <button id="fxUsernameShowBtn" type="button" class="warn secretToggleBtn" title="Reveal or hide this sensitive field.">SHOW</button>
        </div>
      </div>
      <div id="fxHueBridgeIdWrap">
        <label for="fxBridgeId">HUE BRIDGE ID <span class="infoTip" title="Unique bridge identifier required by Hue Entertainment transport.">?</span></label>
        <input id="fxBridgeId" type="text" class="mono" placeholder="ECB5...">
      </div>
      <div id="fxHueClientKeyWrap">
        <label for="fxClientKey">HUE CLIENT KEY <span class="infoTip" title="DTLS client key used by Hue Entertainment for low-latency streaming. Generated during pairing.">?</span></label>
        <div class="secretFieldRow">
          <input id="fxClientKey" type="password" class="mono" placeholder="for entertainment" autocomplete="off">
          <button id="fxClientKeyShowBtn" type="button" class="warn secretToggleBtn" title="Reveal or hide this sensitive field.">SHOW</button>
        </div>
      </div>
      <div id="fxHueEntWrap">
        <label for="fxEntertainmentAreaId">ENT AREA (NAME/ID) <span class="infoTip" title="Entertainment Area to stream to. Use name or id from the paired bridge areas list.">?</span></label>
        <input id="fxEntertainmentAreaId" type="text" placeholder="Living Room">
      </div>
      <div id="fxHuePairWrap" class="pairActionRow">
        <div class="grid2">
          <button id="fxHueDiscoverBtn" type="button" class="pairDiscoverBtn" title="Step 1: Discover bridge IP/ID from local network.">1) DISCOVER BRIDGE</button>
          <button id="fxHuePairBtn" type="button" class="pairLinkBtn" title="Step 2: Press physical Hue bridge link button, then run pairing.">2) PAIR (PRESS LINK)</button>
        </div>
        <div class="pairBridgeSaveRow">
          <button id="fxHueSaveBridgeBtn" type="button" class="pairBridgeSaveBtn" title="Save Hue bridge fields to the selected fixture without re-pairing.">SAVE BRIDGE EDITS (NO RE-PAIR)</button>
        </div>
      </div>
      <div class="hint"><b>Pairing order:</b> Discover Bridge -> press link button on bridge -> Pair.</div>
      <div class="hint"><b>Bridge edits:</b> after loading a fixture with EDIT, change Hue bridge fields and click <b>SAVE BRIDGE EDITS</b> to confirm without pairing again.</div>
      <div class="hint">
        <b>Entertainment area required:</b> create one in the Hue app, then use that name/id here.
        <span class="infoTip" title="Hue app -> Settings -> Entertainment areas -> Create area -> add lights -> Save. Then paste that area name or id into ENT AREA.">?</span>
      </div>
      <div class="hint">
        Discovery and pairing only apply to Hue fixtures. Press the bridge link button during pairing.
        Pairing fills username/client key/bridge id so Entertainment can run.
      </div>
      <div class="hint">
        Recommendation: configure Hue Entertainment for smooth high-rate scenes.
        Without it, Hue falls back to REST, which is safer but less responsive at very high Hz.
      </div>
    </div>
    </div>
  </div>

  <div class="cluster collapsible" data-collapsible-key="fixtureList" data-collapsed-default-mobile="1">
    <div class="clusterHeaderRow">
      <h3>FIXTURE LIST</h3>
      <button type="button" class="collapseBtn" data-collapse-btn aria-expanded="true" title="Show or hide fixture table.">COLLAPSE</button>
    </div>
    <div class="clusterBody">
    <p class="hint">
      <b>First-time setup:</b> entries like <code>hue-main-1</code> and <code>wiz-custom-1</code> are placeholder fixtures.
      Delete them and save your real devices before starting Rave mode.
    </p>
    <div class="tableWrap">
      <table>
        <thead>
          <tr>
            <th>ID</th>
            <th>BRAND</th>
            <th>ZONE</th>
            <th title="Current per-fixture enable state for ENGINE, TWITCH, and CUSTOM paths.">APPLIED MODES</th>
            <th title="Resolved route bindings this fixture listens to.">ROUTE PATH</th>
            <th>TARGET</th>
            <th>ENABLED</th>
            <th>ACTIONS</th>
          </tr>
        </thead>
        <tbody id="fixtureRows"></tbody>
      </table>
    </div>
    <p class="hint">APPLIED MODES shows per-fixture state: ENG (rave engine), TWITCH (/color), CUSTOM (manual/self-animate).</p>
    </div>
  </div>

  <div class="cluster collapsible" id="deviceRouting" data-collapsible-key="deviceRouting" data-collapsed-default-mobile="1">
    <div class="clusterHeaderRow">
      <h3>DEVICE ROUTING</h3>
      <button type="button" class="collapseBtn" data-collapse-btn aria-expanded="true" title="Collapse this section to reduce clutter.">COLLAPSE</button>
    </div>
    <div class="clusterBody">
      <div class="controlRow">
        <div>
          <label for="standFixtureSelect">SELECT FIXTURE <span class="infoTip" title="Pick one fixture to edit its routing mode toggles below.">?</span></label>
          <select id="standFixtureSelect">
            <option value="">select fixture</option>
          </select>
        </div>
        <div class="routeModesWrap">
          <label>ROUTE MODES <span class="infoTip" title="ENGINE = audio rave engine. TWITCH = /color reward events. CUSTOM = standalone manual/animated device control. ENGINE and CUSTOM cannot run together; whichever you press last takes priority.">?</span></label>
          <div class="routeChipGroup">
            <button id="standRouteEngine" type="button" class="routeChipToggle" data-on="false" aria-pressed="false" title="Enable this fixture for live audio rave engine output.">ENGINE</button>
            <button id="standRouteTwitch" type="button" class="routeChipToggle" data-on="false" aria-pressed="false" title="Enable this fixture for Twitch/color route events.">TWITCH</button>
            <button id="standRouteCustom" type="button" class="routeChipToggle" data-on="false" aria-pressed="false" title="Enable standalone custom control for this fixture.">CUSTOM</button>
          </div>
        </div>
        <div class="grid2">
          <button id="standRouteApplyBtn" type="button" title="Save the ENGINE/TWITCH/CUSTOM mode toggles for the selected fixture.">APPLY ROUTING</button>
          <button id="standRefreshBtn" type="button" title="Reload fixture list from server before editing routes.">REFRESH FIXTURES</button>
          <button id="standConnectivityBtn" type="button" title="Run a live connectivity test for the selected fixture host/IP.">TEST CONNECTIVITY</button>
        </div>
        <div>
          <label for="standRouteStatus">STATUS <span class="infoTip" title="Shows selected fixture and its currently active route modes.">?</span></label>
          <input id="standRouteStatus" type="text" value="Select fixture and routing options." readonly>
          <label for="standConnectivityStatus">CONNECTIVITY</label>
          <input id="standConnectivityStatus" type="text" value="No connectivity test yet." readonly>
        </div>
      </div>
      <p class="hint"><code>ENGINE</code> and <code>TWITCH</code> can run together. New fixtures default to <code>ENGINE + TWITCH</code>. <code>CUSTOM</code> can run with <code>TWITCH</code>, but not with <code>ENGINE</code> (last toggle wins between ENGINE/CUSTOM).</p>

      <div class="fixtureToolbar">
        <div>
          <label for="routeHueInput">DERIVED HUE_STATE <span class="infoTip" title="Derived automatically from Hue fixtures that have ENGINE enabled.">?</span></label>
          <input id="routeHueInput" type="text" readonly>
        </div>
        <div>
          <label for="routeWizInput">DERIVED WIZ_PULSE <span class="infoTip" title="Derived automatically from WiZ fixtures that have ENGINE enabled.">?</span></label>
          <input id="routeWizInput" type="text" readonly>
        </div>
        <div>
          <label for="routeTwitchHueInput">DERIVED TWITCH_HUE <span class="infoTip" title="Derived automatically from Hue fixtures that have TWITCH enabled.">?</span></label>
          <input id="routeTwitchHueInput" type="text" readonly>
        </div>
        <div>
          <label for="routeTwitchWizInput">DERIVED TWITCH_WIZ <span class="infoTip" title="Derived automatically from WiZ fixtures that have TWITCH enabled.">?</span></label>
          <input id="routeTwitchWizInput" type="text" readonly>
        </div>
        <div>
          <label for="fixturesReloadBtn">ROUTING CONFIG</label>
          <button id="fixturesReloadBtn" type="button" title="Reload fixtures.config.json and route table from disk.">RELOAD CFG</button>
        </div>
      </div>
      <p class="hint">These route values are read-only and updated automatically from fixture toggles.</p>

      <div class="twitchPrefixPanel">
        <h3>TWITCH COLOR COMMAND PREFIXES</h3>
        <div class="twitchPrefixGrid">
          <div>
            <label for="colorPrefixHue">HUE PREFIX (OPTIONAL)</label>
            <input id="colorPrefixHue" type="text" value="hue" placeholder="hue">
          </div>
          <div>
            <label for="colorPrefixWiz">WIZ PREFIX (OPTIONAL)</label>
            <input id="colorPrefixWiz" type="text" value="wiz" placeholder="wiz">
          </div>
          <div>
            <label for="colorPrefixDefaultTarget">UNPREFIXED /color TARGET</label>
            <select id="colorPrefixDefaultTarget">
              <option value="both">both brands (sync)</option>
              <option value="hue">hue only</option>
              <option value="wiz">wiz only</option>
            </select>
          </div>
          <div id="colorPrefixOtherWrap" class="prefixDisabled">
            <label for="colorPrefixOther">MOD-BRAND PREFIX (OPTIONAL)</label>
            <input id="colorPrefixOther" type="text" placeholder="e.g. lifx">
          </div>
          <div class="grid2">
            <button id="colorPrefixSaveBtn" type="button">SAVE PREFIX CONFIG</button>
            <button id="colorPrefixResetBtn" type="button">RESET PREFIX DEFAULTS</button>
          </div>
        </div>
        <p id="colorPrefixStatus" class="hint">
          Prefixes are optional. Clear both Hue + WiZ prefixes and set unprefixed target to <code>both</code> for full sync behavior.
        </p>
      </div>
    </div>
  </div>
</div>

<div class="panel tabPage" data-tab="audio">
  <div class="cluster">
    <h3>AUDIO CONTROL <span class="infoTip" title="Configure input source and sensitivity. Hover labels/buttons for what each control changes.">?</span></h3>
    <div class="audioGuide">
      <div class="audioGuideGrid">
        <div class="audioGuideCard">
          <strong>1) Quick setup first</strong>
          <span>Pick <b>INPUT DEVICES</b>, then start with a quality profile. Most setups only need this section.</span>
        </div>
        <div class="audioGuideCard">
          <strong>2) Apply + verify</strong>
          <span>Click <b>APPLY AUDIO CFG</b>, then check <b>AUDIO PIPELINE</b> values rise when music plays.</span>
        </div>
        <div class="audioGuideCard">
          <strong>3) Use advanced only if needed</strong>
          <span>Expand <b>ADVANCED AUDIO TUNING</b> for detailed thresholds, limiter behavior, and watchdog tuning.</span>
        </div>
      </div>
    </div>
    <div class="subcluster">
      <h3>QUICK SETUP</h3>
      <p class="hint">For most users: pick a device, choose sample rate + frames, then apply.</p>
      <div class="controlRow">
        <div>
          <label for="aDevices">INPUT DEVICES <span class="infoTip" title="Enumerated audio input devices discovered by the host audio backend.">?</span></label>
          <select id="aDevices"></select>
        </div>
        <div>
          <label for="aDeviceMatch">DEVICE MATCH <span class="infoTip" title="Optional partial device name match. Example: stereo mix, loopback, cable output.">?</span></label>
          <input id="aDeviceMatch" type="text" value="" placeholder="optional name match (e.g. stereo mix)" />
        </div>
        <div>
          <label for="aSampleRate">SAMPLE RATE <span class="infoTip" title="Higher rate can be cleaner but uses more CPU. 44100/48000 are common stable defaults.">?</span></label>
          <select id="aSampleRate">
            <option value="44100">44100</option>
            <option value="48000">48000</option>
            <option value="96000">96000</option>
          </select>
        </div>
        <div>
          <label for="aFrames">FRAMES/BUFFER <span class="infoTip" title="Lower = lower latency but can crackle/drop on weak systems. Higher = steadier but slower reaction.">?</span></label>
          <select id="aFrames">
            <option value="128">128</option>
            <option value="256">256</option>
            <option value="512">512</option>
            <option value="1024">1024</option>
          </select>
        </div>
      </div>
      <div class="audioQuickSecondaryRow">
        <div>
          <label for="aChannels">CHANNELS <span class="infoTip" title="Use 2 for stereo devices. Use 1 only for mono input capture.">?</span></label>
          <select id="aChannels">
            <option value="1">1</option>
            <option value="2" selected>2</option>
          </select>
        </div>
        <div>
          <label for="aGain">GAIN <span class="infoTip" title="Input amplification before feature extraction. Increase if levels stay low; reduce if clipping/overreaction.">?</span></label>
          <input id="aGain" type="number" step="0.01" min="0.2" max="3.0" value="1.00" />
        </div>
      </div>
      <div>
        <label>AUDIO QUALITY PROFILES <span class="infoTip" title="One-click presets for common sample-rate/buffer combos. Apply after selecting.">?</span></label>
        <div class="grid4 audioQuickPresetGrid">
          <button type="button" data-audio-quick="safe" title="Safer stability profile: 48000 / 512">SAFE</button>
          <button type="button" data-audio-quick="balanced" title="Balanced profile: 48000 / 256">BALANCED</button>
          <button type="button" data-audio-quick="fast" title="Lower latency profile: 48000 / 128">FAST</button>
          <button type="button" data-audio-quick="hires" title="High-rate profile: 96000 / 256">HI-RES</button>
        </div>
        <p class="hint audioQuickPresetHint">Profiles only change sample rate + frames/buffer.</p>
      </div>
      <div class="audioReactMap">
        <div class="audioReactMapHeader">
          <label>PER-BRAND AUDIO REACTIVITY <span class="infoTip" title="Pick which audio features each brand responds to. Multiple source toggles blend together.">?</span></label>
          <div class="audioReactMapDropToggle">
            <label for="reactDropEnabled">DROP REACTIVE</label>
            <input id="reactDropEnabled" type="checkbox">
          </div>
        </div>
        <p class="hint">Small + simple: toggle one or more sources per brand. This also includes a CUSTOM/FUTURE row for upcoming mod-brand fixtures.</p>
        <div class="audioReactPolicyBar">
          <label><input id="reactHardwareRateLimitsEnabled" type="checkbox" checked> HARDWARE SAFE RATE CAPS</label>
          <label><input id="reactSmartMatchEnabled" type="checkbox" checked> SMART MATCH LIVE (RECOMMENDED)</label>
          <label><input id="reactForceLockEnabled" type="checkbox"> FORCE SINGLE SOURCE</label>
          <label><input id="reactForceMatchOverride" type="checkbox"> FORCE MATCH OVERRIDE</label>
          <div id="reactCompatSummary" class="audioReactCompatSummary">Compatibility policy not loaded yet.</div>
        </div>
        <div class="audioReactMapRows">
          <div class="audioReactMapRow">
            <div class="audioReactMapTop">
              <label><input id="reactHueEnabled" type="checkbox" checked> HUE</label>
              <div class="audioReactAmountWrap">
                <span>AMOUNT</span>
                <input id="reactHueAmount" type="range" min="0" max="180" step="1" value="100">
                <span id="reactHueAmountVal" class="sliderValue">1.00x</span>
              </div>
            </div>
            <div id="reactHueSources" class="audioReactSources"></div>
          </div>
          <div class="audioReactMapRow">
            <div class="audioReactMapTop">
              <label><input id="reactWizEnabled" type="checkbox" checked> WIZ</label>
              <div class="audioReactAmountWrap">
                <span>AMOUNT</span>
                <input id="reactWizAmount" type="range" min="0" max="180" step="1" value="100">
                <span id="reactWizAmountVal" class="sliderValue">1.00x</span>
              </div>
            </div>
            <div id="reactWizSources" class="audioReactSources"></div>
          </div>
          <div class="audioReactMapRow">
            <div class="audioReactMapTop">
              <label><input id="reactOtherEnabled" type="checkbox" checked> CUSTOM/FUTURE</label>
              <div class="audioReactAmountWrap">
                <span>AMOUNT</span>
                <input id="reactOtherAmount" type="range" min="0" max="180" step="1" value="100">
                <span id="reactOtherAmountVal" class="sliderValue">1.00x</span>
              </div>
            </div>
            <div id="reactOtherSources" class="audioReactSources"></div>
          </div>
        </div>
        <div class="audioReactMapActions">
          <button id="reactMapApplyBtn" type="button">APPLY REACT MAP</button>
          <button id="reactMapResetBtn" type="button">RESET REACT MAP</button>
          <input id="reactMapStatus" type="text" value="React map not loaded yet." readonly>
        </div>
      </div>
      <div class="grid2 audioQuickActionRow">
        <button id="aRefreshBtn" type="button" title="Reload current audio config from server.">REFRESH CFG</button>
        <button id="aScanBtn" type="button" title="Rescan input devices from the audio backend.">SCAN DEVICES</button>
      </div>
      <div class="grid3 audioQuickActionRow">
        <button id="aApplyBtn" type="button" class="warn" title="Save these audio settings to server and apply immediately.">APPLY AUDIO CFG</button>
        <button id="aRestartBtn" type="button" title="Restart audio capture pipeline with current settings.">RESTART AUDIO</button>
        <button id="aResetDefaultsBtn" type="button" class="warn" title="Restore audio settings to defaults and apply immediately.">RESET AUDIO DEFAULTS</button>
      </div>
    </div>

    <div class="subcluster collapsible" data-collapsible-key="audioAdvancedTuning" data-collapsed-default="1" data-collapsed-default-mobile="1">
      <div class="clusterHeaderRow">
        <h3>ADVANCED AUDIO TUNING</h3>
        <button type="button" class="collapseBtn" data-collapse-btn aria-expanded="true" title="Show or hide advanced audio tuning controls.">COLLAPSE</button>
      </div>
      <div class="clusterBody">
        <p class="hint">Use these when troubleshooting edge cases, room noise behavior, limiter response, or backend restart behavior.</p>
        <div class="controlRow">
          <div>
            <label for="aDeviceId">DEVICE ID (blank = auto) <span class="infoTip" title="Numeric input device id. Leave blank to auto-select based on match/fallback.">?</span></label>
            <input id="aDeviceId" type="text" placeholder="auto" />
          </div>
          <div>
            <label for="aNoise">NOISE FLOOR MIN <span class="infoTip" title="Minimum signal floor to ignore background hum. Raise if room noise triggers effects.">?</span></label>
            <input id="aNoise" type="number" step="0.00001" min="0" max="0.02" value="0.00045" />
          </div>
          <div>
            <label for="aPeakDecay">PEAK DECAY <span class="infoTip" title="How quickly peaks fall back down. Higher holds peak longer; lower decays faster.">?</span></label>
            <input id="aPeakDecay" type="number" step="0.001" min="0.5" max="0.9995" value="0.93" />
          </div>
          <div>
            <label for="aRestartMs">RESTART MS <span class="infoTip" title="Watchdog restart delay when audio stream stalls.">?</span></label>
            <input id="aRestartMs" type="number" step="50" min="250" max="20000" value="1500" />
          </div>
        </div>
        <div class="controlRow">
          <div>
            <label for="aBandLowHz">BAND LOW HZ <span class="infoTip" title="Upper edge of low-frequency band used by reactive analysis.">?</span></label>
            <input id="aBandLowHz" type="number" step="1" min="60" max="500" value="180" />
          </div>
          <div>
            <label for="aBandMidHz">BAND MID HZ <span class="infoTip" title="Upper edge of mid-frequency band. Higher values shift more content from highs into mids.">?</span></label>
            <input id="aBandMidHz" type="number" step="1" min="700" max="8000" value="2200" />
          </div>
          <div>
            <label for="aLimiterThreshold">LIMITER THRESHOLD <span class="infoTip" title="Peak limiter threshold. Lower means stronger limiting.">?</span></label>
            <input id="aLimiterThreshold" type="number" step="0.01" min="0.4" max="0.99" value="0.82" />
          </div>
          <div>
            <label for="aLimiterKnee">LIMITER KNEE <span class="infoTip" title="Limiter knee softness. Higher is smoother; lower is harder clamp.">?</span></label>
            <input id="aLimiterKnee" type="number" step="0.01" min="0.02" max="0.8" value="0.16" />
          </div>
        </div>
        <div class="grid2">
          <div>
            <label for="aLogTicks">LOG EVERY TICKS <span class="infoTip" title="Internal debug logging interval. Higher values = less log noise.">?</span></label>
            <input id="aLogTicks" type="number" step="1" min="10" max="2000" value="60" />
          </div>
        </div>
        <h3>LIMITER PRESETS</h3>
        <div class="grid3">
          <button type="button" data-limiter-preset="transparent">TRANSPARENT</button>
          <button type="button" data-limiter-preset="balanced">BALANCED</button>
          <button type="button" data-limiter-preset="hard">HARD</button>
        </div>
        <p class="hint">Preset buttons only change limiter threshold and knee.</p>
      </div>
    </div>
  </div>

  <div class="cluster collapsible" data-collapsible-key="audioPipeline" data-collapsed-default-mobile="1">
    <div class="clusterHeaderRow">
      <h3>AUDIO PIPELINE</h3>
      <button type="button" class="collapseBtn" data-collapse-btn aria-expanded="true" title="Show or hide audio telemetry panels.">COLLAPSE</button>
    </div>
    <div class="clusterBody">
    <div class="telemetry">
      <div>LEVEL<br><span id="aLevel">0.00</span></div>
      <div>RAW<br><span id="aRaw">0.00</span></div>
      <div>PEAK<br><span id="aPeak">0.00</span></div>
  <div>TR<br><span id="aTransient">0.00</span></div>
  <div>ZCR<br><span id="aZcr">0.00</span></div>
  <div>B LOW<br><span id="aBandLow">0.00</span></div>
  <div>B MID<br><span id="aBandMid">0.00</span></div>
  <div>B HIGH<br><span id="aBandHigh">0.00</span></div>
  <div>FLUX<br><span id="aFlux">0.00</span></div>
  <div>DEVICE<br><span id="aDevice">-</span></div>
  <div>RUNNING<br><span id="aRunning">NO</span></div>
  <div>RESTART<br><span id="aRestart">-</span></div>
  <div>ERROR<br><span id="aError">-</span></div>
    </div>
  </div>
</div>
</div>

<div id="midiTabPage" class="panel tabPage hidden" data-tab="midi">
  <div class="cluster">
    <h3>MIDI CONTROL <span class="infoTip" title="Map MIDI notes/CC controls to engine actions without editing code.">?</span></h3>
    <div class="audioGuide">
      <div class="audioGuideGrid">
        <div class="audioGuideCard">
          <strong>1) Detect device</strong>
          <span>Pick a <b>MIDI INPUT PORT</b>, then click <b>SAVE MIDI CFG</b>.</span>
        </div>
        <div class="audioGuideCard">
          <strong>2) Map controls</strong>
          <span>Use <b>ARM LEARN</b> and hit a key/knob, or fill manual binding fields.</span>
        </div>
        <div class="audioGuideCard">
          <strong>3) Test actions</strong>
          <span>Use <b>TRIGGER ACTION</b> to verify mapped engine behavior.</span>
        </div>
      </div>
    </div>

    <div class="subcluster">
      <h3>MIDI STATUS</h3>
      <div class="controlRow">
        <div>
          <label for="midiModuleStatus">MODULE</label>
          <input id="midiModuleStatus" type="text" value="checking..." readonly>
        </div>
        <div>
          <label for="midiRuntimeStatus">RUNTIME</label>
          <input id="midiRuntimeStatus" type="text" value="checking..." readonly>
        </div>
        <div>
          <label for="midiActivePort">ACTIVE PORT</label>
          <input id="midiActivePort" type="text" value="none" readonly>
        </div>
        <div>
          <label for="midiLearnStatus">LEARN MODE</label>
          <input id="midiLearnStatus" type="text" value="idle" readonly>
        </div>
      </div>
      <div class="controlRow">
        <div>
          <label for="midiLastEvent">LAST MIDI EVENT</label>
          <input id="midiLastEvent" type="text" value="none" readonly>
        </div>
        <div>
          <label for="midiLastAction">LAST ACTION</label>
          <input id="midiLastAction" type="text" value="none" readonly>
        </div>
        <div>
          <label for="midiEnabled">MIDI ENABLED</label>
          <select id="midiEnabled">
            <option value="true">enabled</option>
            <option value="false">disabled</option>
          </select>
        </div>
        <div>
          <label for="midiVelocityThreshold">DEFAULT MIN VALUE</label>
          <input id="midiVelocityThreshold" type="number" min="0" max="127" step="1" value="1">
        </div>
      </div>
      <div class="controlRow">
        <div>
          <label for="midiPortSelect">MIDI INPUT PORT</label>
          <select id="midiPortSelect"></select>
        </div>
        <div>
          <label for="midiDeviceMatch">DEVICE MATCH (OPTIONAL)</label>
          <input id="midiDeviceMatch" type="text" placeholder="partial port name">
        </div>
        <div class="grid2">
          <button id="midiRefreshBtn" type="button">REFRESH PORTS</button>
          <button id="midiSaveCfgBtn" type="button">SAVE MIDI CFG</button>
        </div>
      </div>
    </div>

    <div class="subcluster">
      <h3>LEARN + BINDINGS</h3>
      <div class="controlRow">
        <div>
          <label for="midiLearnAction">LEARN ACTION</label>
          <select id="midiLearnAction"></select>
        </div>
        <div class="grid3">
          <button id="midiLearnArmBtn" type="button">ARM LEARN</button>
          <button id="midiLearnCancelBtn" type="button">CANCEL LEARN</button>
          <button id="midiTriggerBtn" type="button">TRIGGER ACTION</button>
        </div>
      </div>

      <div class="controlRow">
        <div>
          <label for="midiBindingAction">BINDING ACTION</label>
          <select id="midiBindingAction"></select>
        </div>
        <div>
          <label for="midiBindingType">MESSAGE TYPE</label>
          <select id="midiBindingType">
            <option value="note">note</option>
            <option value="cc">cc</option>
          </select>
        </div>
        <div>
          <label for="midiBindingNumber">NUMBER</label>
          <input id="midiBindingNumber" type="number" min="0" max="127" step="1" value="36">
        </div>
        <div>
          <label for="midiBindingChannel">CHANNEL (blank = any)</label>
          <input id="midiBindingChannel" type="number" min="1" max="16" step="1" placeholder="any">
        </div>
      </div>
      <div class="controlRow">
        <div>
          <label for="midiBindingMinValue">MIN VALUE</label>
          <input id="midiBindingMinValue" type="number" min="0" max="127" step="1" value="1">
        </div>
        <div class="grid3">
          <button id="midiBindingSaveBtn" type="button">SAVE BINDING</button>
          <button id="midiBindingClearBtn" type="button" class="warn">CLEAR ACTION BINDING</button>
          <button id="midiBindingResetBtn" type="button" class="warn">RESET DEFAULT BINDINGS</button>
        </div>
      </div>

      <div>
        <label for="midiBindingsDump">BINDINGS SNAPSHOT</label>
        <textarea id="midiBindingsDump" readonly>no bindings loaded yet</textarea>
      </div>
      <p class="hint">
        Tip: if a control keeps re-triggering, raise <b>MIN VALUE</b> or use a button that sends 0 on release and 127 on press.
      </p>
    </div>
  </div>
</div>

<div class="panel tabPage" data-tab="custom">
  <div class="cluster">
    <h3>CUSTOM FIXTURE CONTROL</h3>
    <p class="hint">
      This tab is for per-device custom behavior driven by live audio metrics. <code>STATIC</code> mode keeps output fixed and only reacts to manual/apply + rave start/stop updates.
    </p>
      <div class="controlRow">
        <div>
          <label for="customFixtureSelect">SELECT CUSTOM FIXTURE (HUE + WiZ)</label>
          <select id="customFixtureSelect">
            <option value="">no custom fixture routed</option>
          </select>
        </div>
        <div class="grid2">
          <button id="customFixtureSyncBtn" type="button" title="Use selected custom fixture as the active routing target.">USE SELECTED FIXTURE</button>
        </div>
      </div>
  </div>
  <div id="customStandaloneMount"></div>
</div>

<div class="panel tabPage" data-tab="system">
  <div class="cluster collapsible" data-collapsible-key="systemSettings">
    <div class="clusterHeaderRow">
      <h3>SYSTEM SETTINGS</h3>
      <button type="button" class="collapseBtn" data-collapse-btn aria-expanded="true" title="Show or hide system-level runtime settings.">COLLAPSE</button>
    </div>
    <div class="clusterBody">
      <div class="controlRow">
        <div>
          <label for="systemStartTab">START TAB</label>
          <select id="systemStartTab">
            <option value="live">live</option>
            <option value="fixtures">fixtures</option>
            <option value="audio">audio</option>
            <option value="midi">midi</option>
            <option value="custom">custom</option>
            <option value="mods">mods</option>
            <option value="system">system</option>
          </select>
        </div>
        <div>
          <label for="systemConfirmActions">CONFIRM DANGEROUS ACTIONS</label>
          <select id="systemConfirmActions">
            <option value="true">enabled</option>
            <option value="false">disabled</option>
          </select>
        </div>
        <div>
          <label for="systemPollingMode">AUTO POLLING</label>
          <select id="systemPollingMode">
            <option value="live">live</option>
            <option value="paused">paused</option>
          </select>
        </div>
        <div>
          <label for="systemAutoLaunchBrowser">SERVER BROWSER AUTO-LAUNCH</label>
          <select id="systemAutoLaunchBrowser">
            <option value="true">enabled</option>
            <option value="false">disabled</option>
          </select>
        </div>
        <div>
          <label for="systemHueTransportPreference">HUE TRANSPORT DEFAULT</label>
          <select id="systemHueTransportPreference">
            <option value="auto">auto (entertainment preferred)</option>
            <option value="rest">rest only</option>
          </select>
        </div>
        <div>
          <label for="systemUnsafeSensitiveLogs">SERVER LOG REDACTION</label>
          <select id="systemUnsafeSensitiveLogs">
            <option value="false">redacted (safe default)</option>
            <option value="true">expose sensitive logs (DEV RISK)</option>
          </select>
        </div>
        <div class="grid2">
          <button id="systemSettingsSaveBtn" type="button">SAVE SYSTEM SETTINGS</button>
          <button id="systemSettingsResetBtn" type="button">RESET SYSTEM DEFAULTS</button>
        </div>
      </div>
      <div class="controlRow">
        <div>
          <label for="systemSettingsStatus">SETTINGS STATUS</label>
          <input id="systemSettingsStatus" type="text" value="SYSTEM SETTINGS READY" readonly>
        </div>
        <div class="grid2">
          <button id="systemPollNowBtn" type="button">POLL NOW</button>
          <button id="systemClearCacheBtn" type="button" class="warn">CLEAR UI CACHE</button>
        </div>
      </div>
      <div class="apiBaseRow">
        <div class="apiBaseInputWrap">
          <label for="apiBaseInput">API BASE (optional)</label>
          <input id="apiBaseInput" type="text" placeholder="http://127.0.0.1:5050" />
        </div>
        <button id="apiBaseSaveBtn" type="button" title="Save a custom API endpoint when this UI and bridge are on different hosts.">SAVE API BASE</button>
        <button id="apiBaseResetBtn" type="button" title="Reset API BASE to this page origin.">USE DEFAULT</button>
      </div>
      <p class="hint">System settings include browser-local controls plus server browser auto-launch behavior.</p>
      <p class="hint">Set <code>HUE TRANSPORT DEFAULT</code> to <code>rest only</code> if you want to avoid Entertainment mode auto-switching.</p>
      <p class="hint">Danger: disabling log redaction can expose usernames, client keys, bridge IDs, area IDs, bearer tokens, and network addresses in plain text logs.</p>
      <p class="hint">Use API BASE if this UI runs on a different host than the bridge server.</p>
    </div>
  </div>

  <div id="standCustomCluster" class="cluster hidden">
    <h3>CUSTOM DEVICE CONTROL</h3>
    <p class="hint">Visible when <code>ROUTE CUSTOM</code> is enabled for the selected fixture. Use scene + ranges for animation, or toggle <code>STATIC</code> to hold one frame.</p>
    <div class="controlRow">
      <div>
        <label for="standPower">POWER</label>
        <select id="standPower">
          <option value="true">on</option>
          <option value="false">off</option>
        </select>
      </div>
      <div>
        <label for="standMode">MODE</label>
        <select id="standMode">
          <option value="rgb">RGB STATIC</option>
          <option value="scene">SCENE CYCLE</option>
          <option value="auto">AUTO HZ</option>
        </select>
      </div>
      <div>
        <label for="standSpeedHz">SPEED HZ</label>
        <input id="standSpeedHz" type="number" min="0.2" max="12" step="0.1" value="1.2">
      </div>
      <div>
        <label for="standTransitionMs">TRANSITION MS</label>
        <input id="standTransitionMs" type="number" min="0" max="10000" step="10" value="350">
      </div>
    </div>
    <div class="controlRow">
      <div>
        <label for="standScene">SCENE</label>
        <select id="standScene">
          <option value="sweep">SWEEP</option>
          <option value="bounce">BOUNCE</option>
          <option value="pulse">PULSE</option>
          <option value="spark">SPARK</option>
        </select>
      </div>
      <div>
        <label for="standSpeedMode">SPEED SOURCE</label>
        <select id="standSpeedMode">
          <option value="fixed">FIXED HZ</option>
          <option value="audio">AUDIO REACTIVE HZ</option>
        </select>
      </div>
      <div>
        <label for="standSpeedMinHz">AUDIO MIN HZ <span id="standSpeedMinHzVal">0.6</span></label>
        <input id="standSpeedMinHz" type="range" min="0.2" max="12" step="0.1" value="0.6">
      </div>
      <div>
        <label for="standSpeedMaxHz">AUDIO MAX HZ <span id="standSpeedMaxHzVal">3.2</span></label>
        <input id="standSpeedMaxHz" type="range" min="0.2" max="12" step="0.1" value="3.2">
      </div>
    </div>
    <div class="controlRow">
      <div>
        <label for="standColorMode">COLOR MODE</label>
        <select id="standColorMode">
          <option value="hsv">HSV RANGE</option>
          <option value="cct">CCT (WiZ + HUE CT)</option>
        </select>
      </div>
      <div class="grid3">
        <button id="standStaticBtn" type="button" data-on="false" aria-pressed="false">STATIC OFF</button>
        <button id="standRaveStartBtn" type="button" data-on="false" aria-pressed="false">RAVE-START UPDATE OFF</button>
        <button id="standRaveStopBtn" type="button" data-on="false" aria-pressed="false">RAVE-END UPDATE OFF</button>
      </div>
      <div class="grid2">
        <button id="standApplyBtn" type="button">APPLY TO DEVICE</button>
      </div>
      <div>
        <label for="standStatus">CUSTOM STATUS</label>
        <input id="standStatus" type="text" value="No custom fixture selected." readonly>
      </div>
    </div>
    <div class="controlRow">
      <div>
        <label for="standBrightness">BRIGHTNESS % <span id="standBrightnessVal">70</span></label>
        <input id="standBrightness" type="range" min="1" max="100" value="70">
      </div>
      <div id="standHsvSingleWrap">
        <label for="standHue">HUE <span id="standHueVal">210</span></label>
        <input id="standHue" type="range" min="0" max="359" value="210">
      </div>
      <div>
        <label for="standSat">SAT % <span id="standSatVal">80</span></label>
        <input id="standSat" type="range" min="0" max="100" value="80">
      </div>
      <div>
        <label for="standCctKelvin">CCT K <span id="standCctKelvinVal">4000</span></label>
        <input id="standCctKelvin" type="range" min="2200" max="6500" step="50" value="4000">
      </div>
    </div>
    <div id="standHsvRangeRow" class="controlRow">
      <div>
        <label for="standHueMin">HUE MIN <span id="standHueMinVal">0</span></label>
        <input id="standHueMin" type="range" min="0" max="359" value="0">
      </div>
      <div>
        <label for="standHueMax">HUE MAX <span id="standHueMaxVal">359</span></label>
        <input id="standHueMax" type="range" min="0" max="359" value="359">
      </div>
      <div>
        <label for="standSatMin">SAT MIN % <span id="standSatMinVal">45</span></label>
        <input id="standSatMin" type="range" min="0" max="100" value="45">
      </div>
      <div>
        <label for="standSatMax">SAT MAX % <span id="standSatMaxVal">100</span></label>
        <input id="standSatMax" type="range" min="0" max="100" value="100">
      </div>
    </div>
    <div id="standCctRangeRow" class="controlRow hidden">
      <div>
        <label for="standCctMinKelvin">CCT MIN K <span id="standCctMinKelvinVal">2700</span></label>
        <input id="standCctMinKelvin" type="range" min="2200" max="6500" step="50" value="2700">
      </div>
      <div>
        <label for="standCctMaxKelvin">CCT MAX K <span id="standCctMaxKelvinVal">6500</span></label>
        <input id="standCctMaxKelvin" type="range" min="2200" max="6500" step="50" value="6500">
      </div>
    </div>
    <input id="standAnimate" type="hidden" value="false">
  </div>

  <div class="cluster">
    <h3>FIXTURE TOPOLOGY</h3>
    <div class="telemetry">
      <div>HUE<br><span id="fixHue">0</span></div>
      <div>WIZ<br><span id="fixWiz">0</span></div>
      <div>HUE READY<br><span id="fixHueReady">0</span></div>
      <div>WIZ READY<br><span id="fixWizReady">0</span></div>
      <div>R:HUE<br><span id="routeHue">-</span></div>
      <div>R:WIZ<br><span id="routeWiz">-</span></div>
      <div>R:T-HUE<br><span id="routeTwitchHue">-</span></div>
      <div>R:T-WIZ<br><span id="routeTwitchWiz">-</span></div>
      <div>CFG VER<br><span id="cfgVer">0</span></div>
      <div>CFG AT<br><span id="cfgAt">-</span></div>
      <div>LOCK<br><span id="sceneLockStat">AUTO</span></div>
      <div>POLL(ms)<br><span id="pollMs">220</span></div>
    </div>
  </div>

  <div class="cluster collapsible" data-collapsible-key="engineUtilities" data-collapsed-default="1">
    <div class="clusterHeaderRow">
      <h3>ENGINE UTILITIES</h3>
      <button type="button" class="collapseBtn" data-collapse-btn aria-expanded="true" title="Show or hide advanced utility controls.">COLLAPSE</button>
    </div>
    <div class="clusterBody">
      <div class="grid3">
        <button id="reloadBtn" type="button" class="warn" title="Reload server runtime modules without closing the app window.">HOT RELOAD</button>
        <button id="dropBtn" type="button" class="warn" title="Trigger one manual drop hit event for testing visuals.">DROP HIT</button>
        <button id="hueEntBtn" type="button" title="Force Hue transport to Entertainment mode.">HUE ENTERTAINMENT</button>
        <button id="hueRestBtn" type="button" title="Force Hue transport to REST mode.">HUE REST</button>
        <button id="serverStopBtn" type="button" class="bad" title="Gracefully stop the local bridge process from the browser UI.">STOP SERVER (UI)</button>
      </div>
      <p class="hint">Rave mode auto-switches Hue transport. These controls are for diagnostics. MIDI mapping is managed in the MIDI tab.</p>
      <p class="hint">Browser security cannot run local .bat files directly. Use this UI stop button or <code>RaveLink-Bridge-Stop.bat</code>.</p>
    </div>
  </div>

  <div class="cluster collapsible" data-collapsible-key="automationRules" data-collapsed-default="1">
    <div class="clusterHeaderRow">
      <h3>NO-CODE AUTOMATION RULES</h3>
      <button type="button" class="collapseBtn" data-collapse-btn aria-expanded="true" title="Show or hide automation rule editor.">COLLAPSE</button>
    </div>
    <div class="clusterBody">
    <div class="legacyNoticePanel">
      <p class="legacyNoticeTitle">LEGACY / DEPRECATED</p>
      <p class="legacyNoticeText">This section is legacy and replaced by <b>CUSTOM FIXTURE CONTROL</b>. Keep disabled unless you explicitly need old automation behavior.</p>
      <div class="legacyNoticeActions">
        <button id="legacyAutomationUnlockBtn" type="button" class="warn">OPEN LEGACY CONTROLS</button>
        <button id="legacyAutomationLockBtn" type="button" class="hidden">HIDE LEGACY CONTROLS</button>
        <button id="legacyAutomationJumpCustomBtn" type="button">GO TO CUSTOM FIXTURE CONTROL</button>
      </div>
    </div>
    <div id="legacyAutomationWrap" class="legacyAutomationWrap legacyLocked">
    <div class="controlRow">
      <div>
        <label for="autoRulesEnabled">AUTOMATION</label>
        <select id="autoRulesEnabled">
          <option value="true">enabled</option>
          <option value="false">disabled</option>
        </select>
      </div>
      <div>
        <label for="autoRulesTargetZone">TARGET ZONE</label>
        <select id="autoRulesTargetZone">
          <option value="all">all hue fixtures</option>
        </select>
      </div>
      <div>
        <label for="autoRulesTransitionMs">TRANSITION MS</label>
        <input id="autoRulesTransitionMs" type="number" min="0" max="10000" step="50" value="400" />
      </div>
    </div>

    <div class="controlRow">
      <div>
        <label for="autoStartEnabled">ON ENGINE START</label>
        <select id="autoStartEnabled">
          <option value="true">run</option>
          <option value="false">skip</option>
        </select>
      </div>
      <div>
        <label for="autoStartPercent">START BRIGHTNESS % <span id="autoStartPercentVal">80%</span></label>
        <input id="autoStartPercent" type="range" min="1" max="100" value="80" />
      </div>
      <div>
        <label for="autoStartDelayMs">START DELAY MS</label>
        <input id="autoStartDelayMs" type="number" min="0" max="60000" step="100" value="0" />
      </div>
    </div>

    <div class="controlRow">
      <div>
        <label for="autoStopEnabled">ON ENGINE STOP</label>
        <select id="autoStopEnabled">
          <option value="true">run</option>
          <option value="false">skip</option>
        </select>
      </div>
      <div>
        <label for="autoStopPercent">STOP BRIGHTNESS % <span id="autoStopPercentVal">100%</span></label>
        <input id="autoStopPercent" type="range" min="1" max="100" value="100" />
      </div>
      <div>
        <label for="autoStopDelayMs">STOP DELAY MS</label>
        <input id="autoStopDelayMs" type="number" min="0" max="60000" step="100" value="0" />
      </div>
    </div>

    <div class="grid4">
      <button id="autoRulesSaveBtn" type="button" class="warn">SAVE RULES</button>
      <button id="autoRulesReloadBtn" type="button">RELOAD RULES</button>
      <button id="autoRulesTestStartBtn" type="button">TEST START ACTION</button>
      <button id="autoRulesTestStopBtn" type="button">TEST STOP ACTION</button>
    </div>

    <p class="hint">
      Rules run automatically on <code>/rave/on</code> and <code>/rave/off</code>. Every save writes a backup in
      <code>core/backups/automation</code>.
    </p>

    <div class="telemetry">
      <div>AUTO<br><span id="autoRulesState">-</span></div>
      <div>ZONE<br><span id="autoRulesZone">-</span></div>
      <div>TRANS<br><span id="autoRulesTransition">-</span></div>
      <div>START<br><span id="autoRulesStart">-</span></div>
      <div>STOP<br><span id="autoRulesStop">-</span></div>
      <div>CFG VER<br><span id="autoRulesVersion">0</span></div>
      <div>LOADED<br><span id="autoRulesLoadedAt">-</span></div>
      <div>LAST BACKUP<br><span id="autoRulesBackup">-</span></div>
    </div>
    </div>
    </div>
  </div>
</div>

<div id="modUiPanel" class="panel tabPage" data-tab="mods">
  <div class="cluster collapsible" id="modCenter" data-collapsible-key="modCenter" data-collapsed-default="1">
    <div class="clusterHeaderRow">
      <h3>MOD CENTER</h3>
      <div class="clusterHeaderActions">
        <button id="moddingReadmeBtn" type="button" class="modReadmeBtn" title="Open developer modding docs in a separate page.">MODDING README</button>
        <button type="button" class="collapseBtn" data-collapse-btn aria-expanded="true" title="Show or hide mod controls.">COLLAPSE</button>
      </div>
    </div>
    <div class="clusterBody">
      <p class="hint">
        Add mod folders under <code>mods/</code> (each with <code>mod.json</code>), then use <b>RELOAD MODS</b>.
      </p>
      <p class="hint">
        <code>0/2 loaded</code> is normal in a fresh distro when mods exist but are disabled in <code>mods/mods.config.json</code>.
      </p>
      <div id="modDropZone" class="modDropZone">
        <div class="controlRow">
          <div>
            <label>DRAG + DROP MOD IMPORT</label>
            <input id="modImportStatus" type="text" value="Drop a mod folder here, or browse and pick a folder." readonly>
          </div>
          <div class="grid2">
            <button id="modImportBrowseBtn" type="button">BROWSE FOLDER</button>
          </div>
        </div>
        <div class="controlRow">
          <div>
            <label style="font-size:11px;">
              <input id="modImportOverwrite" type="checkbox">
              overwrite existing mod with same id
            </label>
          </div>
          <div>
            <label style="font-size:11px;">
              <input id="modImportEnable" type="checkbox" checked>
              auto-enable + hotswap after import
            </label>
          </div>
        </div>
        <p class="hint">Folder must include <code>mod.json</code>. Supports drag/drop directly from Explorer.</p>
        <input id="modImportPicker" type="file" webkitdirectory directory multiple class="hidden">
      </div>
      <div class="controlRow">
        <div>
          <label>MOD STATUS</label>
          <input id="modsStatus" type="text" value="No mod data loaded yet." readonly>
        </div>
        <div class="grid2">
          <button id="modsRefreshBtn" type="button" title="Fetch mod status from server without reloading modules.">REFRESH MODS</button>
          <button id="modsReloadBtn" type="button" class="warn" title="Reload mods.config.json and re-instantiate enabled mods.">RELOAD MODS</button>
        </div>
      </div>
      <div class="controlRow">
        <div>
          <label for="modEnableId">MOD ID</label>
          <input id="modEnableId" type="text" placeholder="quiet-hours-mod">
          <label for="modHotswapStatus">HOTSWAP STATUS</label>
          <input id="modHotswapStatus" type="text" value="No pending mod changes." readonly>
        </div>
        <div class="grid4">
          <button id="modEnableBtn" type="button" title="Queue this mod to enable. Changes are not live until APPLY HOTSWAP.">QUEUE ENABLE</button>
          <button id="modDisableBtn" type="button" title="Queue this mod to disable. Changes are not live until APPLY HOTSWAP.">QUEUE DISABLE</button>
          <button id="modApplyBtn" type="button" class="warn" title="Apply all queued mod enable/disable changes live.">APPLY HOTSWAP</button>
          <button id="modDiscardBtn" type="button" title="Discard queued changes and keep current loaded mods.">DISCARD CHANGES</button>
        </div>
      </div>
      <p class="hint">Queue one or more mod enable/disable changes, then press <b>APPLY HOTSWAP</b> to load/unload without restarting the bridge.</p>
      <p class="hint">Hover a mod ID to see its summary from <code>mod-info.txt</code>/<code>README.md</code> or <code>mod.json description</code>.</p>

      <div class="tableWrap">
        <table>
          <thead>
            <tr>
              <th>ID</th>
              <th>VERSION</th>
              <th>ENABLED</th>
              <th>PENDING</th>
              <th>LOADED</th>
              <th>HOOKS</th>
              <th>ERROR</th>
            </tr>
          </thead>
          <tbody id="modsRows"></tbody>
        </table>
      </div>

      <div class="subcluster">
        <h3>RUN MOD ACTION</h3>
        <div class="controlRow">
          <div>
            <label for="modActionModId">MOD ID</label>
            <input id="modActionModId" type="text" placeholder="hello-mod">
          </div>
          <div>
            <label for="modActionName">ACTION</label>
            <input id="modActionName" type="text" placeholder="status">
          </div>
          <div>
            <label for="modActionMethod">METHOD</label>
            <select id="modActionMethod">
              <option value="GET">GET</option>
              <option value="POST">POST</option>
            </select>
          </div>
          <div class="grid2">
            <button id="modActionRunBtn" type="button" title="Call /mods/:modId/:action using selected method.">RUN ACTION</button>
          </div>
        </div>
        <textarea id="modActionOutput" readonly>Waiting for mod action...</textarea>
        <p class="hint">Action calls use /mods/:modId/:action routes. Leave action blank to call /mods/:modId.</p>
      </div>
    </div>
  </div>

  <div class="cluster">
    <h3>MOD UI WORKBENCH</h3>
    <p class="hint">Enabled mods with packaged UI create their own top tabs automatically. This workbench lets you inspect and manually reload/open those UIs.</p>
    <p class="hint">Mod UI asset route pattern: <code>/mods-ui/&lt;mod-id&gt;/</code> (catalog at <code>/mods/ui/catalog</code>).</p>

    <div class="modUiToolbar">
      <div>
        <label for="modUiSelect">MOD UI</label>
        <select id="modUiSelect">
          <option value="">no loaded mod UI</option>
        </select>
      </div>
      <button id="modUiRefreshBtn" type="button" title="Refresh mod UI catalog from /mods/ui/catalog.">REFRESH UIs</button>
      <button id="modUiReloadBtn" type="button" title="Reload selected mod UI frame without reloading mod runtime.">RELOAD FRAME</button>
    </div>

    <div class="controlRow">
      <div>
        <label for="modUiStatus">MOD UI STATUS</label>
        <input id="modUiStatus" type="text" value="Waiting for mod UI catalog..." readonly>
      </div>
      <div class="grid2">
        <button id="modUiOpenBtn" type="button" title="Open selected mod UI in a separate browser tab.">OPEN IN NEW TAB</button>
      </div>
    </div>

    <div id="modUiEmpty" class="modUiEmpty">
      No loaded mods expose UI assets yet. Add <code>ui/index.html</code> (or a <code>ui</code> entry in <code>mod.json</code>), then enable the mod and apply hotswap.
    </div>
    <div id="modUiFrameWrap" class="modUiFrameWrap hidden">
      <iframe
        id="modUiFrame"
        title="Mod UI host frame"
        sandbox="allow-same-origin allow-scripts allow-forms allow-popups"
      ></iframe>
    </div>
  </div>
</div>

<script>
// [TITLE] UI Functionality Index:
// [TITLE] - Theme + Layout State
// [TITLE] - Engine Controls + Telemetry Polling
// [TITLE] - Fixture Catalog + Routing Editor
// [TITLE] - Custom/Standalone Fixture Control
// [TITLE] - Audio Config + Per-Brand Reactivity Map
// [TITLE] - Hue Bridge Pairing + Entertainment Area Setup
// [TITLE] - Twitch/Color Routing + Prefixes
// [TITLE] - Mods Dashboard + Embedded Mod UI
const THEME_STORAGE_KEY = "ravelink_ui_theme_v1";
const OBS_DOCK_COMPACT_KEY = "ravelink_obs_dock_compact_v1";
const LEGACY_AUTOMATION_UNLOCK_KEY = "ravelink_legacy_automation_unlocked_v1";
const DEFAULT_THEME_NAME = "midnight";

const THEME_PRESETS = {
  midnight: {
    bg: "#050507",
    panel: "#0b0e18",
    panel2: "#121a2f",
    accent: "#8b001f",
    edge: "#233055",
    btnBg: "#14182c",
    text: "#eaeaea"
  },
  ember: {
    bg: "#120807",
    panel: "#1a0f10",
    panel2: "#2a1617",
    accent: "#d84a1c",
    edge: "#5d2b2c",
    btnBg: "#2b1a18",
    text: "#f2e6dd"
  },
  ocean: {
    bg: "#050c13",
    panel: "#081823",
    panel2: "#0e2434",
    accent: "#00a7c4",
    edge: "#1d4d66",
    btnBg: "#132436",
    text: "#e1effa"
  },
  matrix: {
    bg: "#020807",
    panel: "#061211",
    panel2: "#0b1f1d",
    accent: "#00cf72",
    edge: "#1b4d3c",
    btnBg: "#102120",
    text: "#d9f7e7"
  }
};

function parseDockFlag(rawValue) {
  const raw = String(rawValue || "").trim().toLowerCase();
  return raw === "1" || raw === "true" || raw === "yes" || raw === "on";
}

const dockSearchParams = new URLSearchParams(location.search || "");
const detectedObsDockMode =
  parseDockFlag(dockSearchParams.get("obsdock")) ||
  parseDockFlag(dockSearchParams.get("obsDock")) ||
  parseDockFlag(dockSearchParams.get("dock")) ||
  /obsbrowser|obs studio|obs\//i.test(String(navigator.userAgent || ""));
const detectedObsDockCompact = detectedObsDockMode
  ? (dockSearchParams.has("compact")
    ? parseDockFlag(dockSearchParams.get("compact"))
    : localStorage.getItem(OBS_DOCK_COMPACT_KEY) !== "0")
  : false;

const ui = {
  raveOn: false,
  mode: "interpret",
  modeLock: "auto",
  autoProfile: "balanced",
  audioReactivityPreset: "balanced",
  audioQuickProfile: "balanced",
  flowIntensity: 1,
  wizSceneSync: true,
  sceneSyncActiveBrands: [],
  flowIntensityInputUntil: 0,
  metaAutoEnabled: false,
  metaAutoReason: "off",
  metaAutoGenre: "auto",
  metaAutoHz: 2,
  limiterPreset: "balanced",
  activeTab: "live",
  genre: "edm",
  genreDecadeMode: "auto",
  genreDecadeResolved: "10s",
  overclock: true,
  overclockLevel: 2,
  devDebugMode: localStorage.getItem("ravelink_dev_debug_v1") === "1",
  sceneLock: "auto",
  visualMaster: 1,
  dropIntensity: 1,
  audioReactivityMapLoaded: false,
  audioReactivityMapDirty: false,
  audioReactivityMap: null,
  lastRaveTelemetry: null,
  lastAudioTelemetry: null,
  smartMatchFingerprint: "",
  smartMatchNextRetuneAt: 0,
  reactSmartMatchEnabled: localStorage.getItem("ravelink_react_smart_match_v1") !== "0",
  reactForceLockEnabled: localStorage.getItem("ravelink_react_force_lock_v1") === "1",
  reactForceMatchOverride: localStorage.getItem("ravelink_react_force_override_v1") === "1",
  pollErrors: 0,
  audioConfigLoaded: false,
  midiConfigLoaded: false,
  midiDetected: false,
  midiActions: [],
  midiSnapshot: null,
  midiTabForced: localStorage.getItem("ravelink_midi_tab_forced_v1") === "1",
  automationConfigLoaded: false,
  legacyAutomationUnlocked: localStorage.getItem(LEGACY_AUTOMATION_UNLOCK_KEY) === "1",
  modsLoadedAt: 0,
  modsTotal: 0,
  modsActive: 0,
  modUiCatalog: [],
  modUiSelectedId: localStorage.getItem("ravelink_mod_ui_selected_v1") || "",
  modUiLastId: "",
  modUiLastUrl: "",
  modUiLoadedAt: 0,
  modsSnapshot: null,
  modsRuntimeConfig: { enabled: [], order: [], disabled: [] },
  modsDraftConfig: { enabled: [], order: [], disabled: [] },
  modsDraftDirty: false,
  fixtureModBrands: [],
  fixturesCatalog: [],
  fixturesSnapshotLoaded: false,
  standaloneFixtures: [],
  standaloneSelectedId: "",
  standaloneModeByFixture: {},
  standaloneDraftDirty: false,
  standaloneDraftFixtureId: "",
  standaloneDraftTouchedAt: 0,
  lastBpm: 0,
  routeDraftDirty: false,
  routeDraftFixtureId: "",
  routeDraftFlags: null,
  routeLastSavedAt: 0,
  engineReadyTargets: 0,
  engineModeTargets: 0,
  fixtureConnectivityById: {},
  connectivitySummary: null,
  onboardingAcknowledged: false,
  hueEntGuideAcknowledged: false,
  colorPrefixConfigLoaded: false,
  colorPrefixOtherEnabled: false,
  colorPrefixDefaultTarget: "both",
  colorPrefixes: { hue: "hue", wiz: "wiz", other: "" },
  guidedOnboardingStatus: "",
  guidedOnboardingActive: false,
  guidedOnboardingStep: 0,
  obsDockMode: detectedObsDockMode,
  obsDockCompact: detectedObsDockCompact,
  startTabPreference: String(localStorage.getItem("ravelink_ui_start_tab_v1") || "live").trim().toLowerCase(),
  confirmDangerousActions: localStorage.getItem("ravelink_ui_confirm_danger_v1") !== "0",
  pollPaused: localStorage.getItem("ravelink_ui_poll_paused_v1") === "1",
  serverAutoLaunchBrowser: true,
  serverHueTransportPreference: "auto",
  serverUnsafeSensitiveLogs: false,
  serverUnsafeSensitiveLogsBaseline: false,
  themeName: DEFAULT_THEME_NAME,
  themeConfig: { ...THEME_PRESETS[DEFAULT_THEME_NAME] }
};

const pollIntervalMs = 220;
let pollTick = 0;

const inferredApiBase = (() => {
  if (location.protocol === "file:") return "http://127.0.0.1:5050";
  const isHttp = location.protocol === "http:" || location.protocol === "https:";
  if (isHttp && location.port === "5050") return "";
  if (isHttp) {
    return `${location.protocol}//${location.hostname}:5050`;
  }
  return "";
})();

let apiBase = normalizeApiBaseInput(localStorage.getItem("rave_api_base") || inferredApiBase);
function normalizeUiRelativePath(rawPath) {
  const raw = String(rawPath || "").trim();
  if (!raw) return "/";
  if (raw.startsWith("//")) return "/";
  if (/^[a-z][a-z0-9+.-]*:/i.test(raw)) return "/";
  return raw.startsWith("/") ? raw : `/${raw}`;
}

const withBase = path => {
  const safePath = normalizeUiRelativePath(path);
  return apiBase ? `${apiBase}${safePath}` : safePath;
};
const DEV_DEBUG_KEY = "ravelink_dev_debug_v1";
const DEV_DEBUG_WARN_ONCE_KEY = "ravelink_dev_debug_warn_once_v1";
const DEV_OVERCLOCK_COMICAL_ACK_KEY = "ravelink_dev_overclock_comical_ack_v1";
const MOD_UI_SELECTED_KEY = "ravelink_mod_ui_selected_v1";
const ONBOARD_ACK_KEY = "ravelink_onboard_ack_v1";
const HUE_ENT_GUIDE_ACK_KEY = "ravelink_hue_ent_guide_ack_v1";
const GUIDED_ONBOARDING_STATE_KEY = "ravelink_guided_onboarding_v1";
const UI_STORAGE_MIGRATION_KEY = "ravelink_ui_storage_migration_v1";
const UI_STORAGE_MIGRATION_TARGET = "2026-02-14-release-1-4-3-mods-telemetry-log-hotfix-1";
const UI_START_TAB_KEY = "ravelink_ui_start_tab_v1";
const UI_CONFIRM_DANGER_KEY = "ravelink_ui_confirm_danger_v1";
const UI_POLL_PAUSED_KEY = "ravelink_ui_poll_paused_v1";
const AUDIO_REACT_SMART_MATCH_KEY = "ravelink_react_smart_match_v1";
const AUDIO_REACT_FORCE_LOCK_KEY = "ravelink_react_force_lock_v1";
const AUDIO_REACT_FORCE_OVERRIDE_KEY = "ravelink_react_force_override_v1";
const MIDI_TAB_FORCE_KEY = "ravelink_midi_tab_forced_v1";
const DEV_OVERCLOCK_COMICAL_TEXT = "I AM REALLY REALLY REALLY REALLY REALLY REALLY REALLY SURE";
const UNSAFE_LOG_ACK_PHRASE = "I_UNDERSTAND_SENSITIVE_LOG_RISK";
const UI_STORAGE_RESET_KEYS = Object.freeze([
  "rave_api_base",
  THEME_STORAGE_KEY,
  DEV_DEBUG_KEY,
  DEV_DEBUG_WARN_ONCE_KEY,
  DEV_OVERCLOCK_COMICAL_ACK_KEY,
  MOD_UI_SELECTED_KEY,
  ONBOARD_ACK_KEY,
  HUE_ENT_GUIDE_ACK_KEY,
  GUIDED_ONBOARDING_STATE_KEY,
  UI_STORAGE_MIGRATION_KEY,
  OBS_DOCK_COMPACT_KEY,
  UI_START_TAB_KEY,
  UI_CONFIRM_DANGER_KEY,
  UI_POLL_PAUSED_KEY,
  AUDIO_REACT_SMART_MATCH_KEY,
  AUDIO_REACT_FORCE_LOCK_KEY,
  AUDIO_REACT_FORCE_OVERRIDE_KEY,
  MIDI_TAB_FORCE_KEY,
  LEGACY_AUTOMATION_UNLOCK_KEY
]);
const UI_STORAGE_RESET_PREFIXES = Object.freeze([
  "ravelink_ui_collapsed_",
  "ravelink_ui_theme_",
  "ravelink_guided_"
]);
let hueEntGuideAckResolver = null;
let hueEntGuideAckPromise = null;
let guidedTourFocusEl = null;
let guidedTourAutoStartTimer = null;
let devOcAckResolver = null;
let devOcAckKeydownHandler = null;

ui.devDebugWarned = localStorage.getItem(DEV_DEBUG_WARN_ONCE_KEY) === "1";
ui.devOverclockComicalAcked = localStorage.getItem(DEV_OVERCLOCK_COMICAL_ACK_KEY) === "1";

function removeStorageKeys(storage, keys = []) {
  if (!storage || typeof storage.removeItem !== "function") return;
  for (const key of keys) {
    try {
      storage.removeItem(String(key || ""));
    } catch {}
  }
}

function removeStoragePrefixKeys(storage, prefixes = []) {
  if (!storage || typeof storage.key !== "function" || typeof storage.removeItem !== "function") return;
  for (let i = Number(storage.length || 0) - 1; i >= 0; i -= 1) {
    const key = String(storage.key(i) || "");
    if (!key) continue;
    if (prefixes.some(prefix => key.startsWith(prefix))) {
      try {
        storage.removeItem(key);
      } catch {}
    }
  }
}

async function clearBrowserCacheStorage() {
  if (typeof window === "undefined" || !window.caches || typeof window.caches.keys !== "function") return;
  try {
    const cacheNames = await window.caches.keys();
    await Promise.all(
      cacheNames.map(name => window.caches.delete(name).catch(() => false))
    );
  } catch {}
}

async function wipeUiBrowserMemory(options = {}) {
  const opts = options && typeof options === "object" ? options : {};
  const includeCacheStorage = opts.includeCacheStorage === true;
  removeStorageKeys(localStorage, UI_STORAGE_RESET_KEYS);
  removeStoragePrefixKeys(localStorage, UI_STORAGE_RESET_PREFIXES);
  removeStorageKeys(sessionStorage, UI_STORAGE_RESET_KEYS);
  removeStoragePrefixKeys(sessionStorage, UI_STORAGE_RESET_PREFIXES);
  if (includeCacheStorage) {
    await clearBrowserCacheStorage();
  }
}

async function applyUiStorageMigration() {
  const applied = String(localStorage.getItem(UI_STORAGE_MIGRATION_KEY) || "").trim();
  if (applied === UI_STORAGE_MIGRATION_TARGET) return;

  // Ensure this release starts with a clean UI cache/state baseline.
  await wipeUiBrowserMemory({ includeCacheStorage: false });
  localStorage.setItem(UI_STORAGE_MIGRATION_KEY, UI_STORAGE_MIGRATION_TARGET);
}

applyUiStorageMigration().catch(() => {});

const el = {
  onBtn: document.getElementById("onBtn"),
  offBtn: document.getElementById("offBtn"),
  panicBtn: document.getElementById("panicBtn"),
  reloadBtn: document.getElementById("reloadBtn"),
  dropBtn: document.getElementById("dropBtn"),
  hueEntBtn: document.getElementById("hueEntBtn"),
  hueRestBtn: document.getElementById("hueRestBtn"),
  serverStopBtn: document.getElementById("serverStopBtn"),
  fixturesReloadBtn: document.getElementById("fixturesReloadBtn"),
  autoRulesEnabled: document.getElementById("autoRulesEnabled"),
  autoRulesTargetZone: document.getElementById("autoRulesTargetZone"),
  autoRulesTransitionMs: document.getElementById("autoRulesTransitionMs"),
  autoStartEnabled: document.getElementById("autoStartEnabled"),
  autoStartPercent: document.getElementById("autoStartPercent"),
  autoStartPercentVal: document.getElementById("autoStartPercentVal"),
  autoStartDelayMs: document.getElementById("autoStartDelayMs"),
  autoStopEnabled: document.getElementById("autoStopEnabled"),
  autoStopPercent: document.getElementById("autoStopPercent"),
  autoStopPercentVal: document.getElementById("autoStopPercentVal"),
  autoStopDelayMs: document.getElementById("autoStopDelayMs"),
  autoRulesSaveBtn: document.getElementById("autoRulesSaveBtn"),
  autoRulesReloadBtn: document.getElementById("autoRulesReloadBtn"),
  autoRulesTestStartBtn: document.getElementById("autoRulesTestStartBtn"),
  autoRulesTestStopBtn: document.getElementById("autoRulesTestStopBtn"),
  autoRulesState: document.getElementById("autoRulesState"),
  autoRulesZone: document.getElementById("autoRulesZone"),
  autoRulesTransition: document.getElementById("autoRulesTransition"),
  autoRulesStart: document.getElementById("autoRulesStart"),
  autoRulesStop: document.getElementById("autoRulesStop"),
  autoRulesVersion: document.getElementById("autoRulesVersion"),
  autoRulesLoadedAt: document.getElementById("autoRulesLoadedAt"),
  autoRulesBackup: document.getElementById("autoRulesBackup"),
  legacyAutomationWrap: document.getElementById("legacyAutomationWrap"),
  legacyAutomationUnlockBtn: document.getElementById("legacyAutomationUnlockBtn"),
  legacyAutomationLockBtn: document.getElementById("legacyAutomationLockBtn"),
  legacyAutomationJumpCustomBtn: document.getElementById("legacyAutomationJumpCustomBtn"),
  systemStartTab: document.getElementById("systemStartTab"),
  systemConfirmActions: document.getElementById("systemConfirmActions"),
  systemPollingMode: document.getElementById("systemPollingMode"),
  systemAutoLaunchBrowser: document.getElementById("systemAutoLaunchBrowser"),
  systemHueTransportPreference: document.getElementById("systemHueTransportPreference"),
  systemUnsafeSensitiveLogs: document.getElementById("systemUnsafeSensitiveLogs"),
  systemSettingsSaveBtn: document.getElementById("systemSettingsSaveBtn"),
  systemSettingsResetBtn: document.getElementById("systemSettingsResetBtn"),
  systemPollNowBtn: document.getElementById("systemPollNowBtn"),
  systemClearCacheBtn: document.getElementById("systemClearCacheBtn"),
  systemSettingsStatus: document.getElementById("systemSettingsStatus"),
  modeAutoBtn: document.getElementById("modeAutoBtn"),
  aRefreshBtn: document.getElementById("aRefreshBtn"),
  aScanBtn: document.getElementById("aScanBtn"),
  aApplyBtn: document.getElementById("aApplyBtn"),
  aRestartBtn: document.getElementById("aRestartBtn"),
  aResetDefaultsBtn: document.getElementById("aResetDefaultsBtn"),
  gameBtn: document.getElementById("gameBtn"),
  bpmBtn: document.getElementById("bpmBtn"),
  metaAutoOnBtn: document.getElementById("metaAutoOnBtn"),
  metaAutoOffBtn: document.getElementById("metaAutoOffBtn"),
  ocInsaneBtn: document.getElementById("ocInsaneBtn"),
  ocHyperBtn: document.getElementById("ocHyperBtn"),
  ocLudicrousBtn: document.getElementById("ocLudicrousBtn"),
  ocExtremeBtn: document.getElementById("ocExtremeBtn"),
  ocUltraBtn: document.getElementById("ocUltraBtn"),
  ocTurboBtn: document.getElementById("ocTurboBtn"),
  ocOnBtn: document.getElementById("ocOnBtn"),
  ocOffBtn: document.getElementById("ocOffBtn"),
  ocDevCluster: document.getElementById("ocDevCluster"),
  ocDev20Btn: document.getElementById("ocDev20Btn"),
  ocDev30Btn: document.getElementById("ocDev30Btn"),
  ocDev40Btn: document.getElementById("ocDev40Btn"),
  ocDev50Btn: document.getElementById("ocDev50Btn"),
  ocDev60Btn: document.getElementById("ocDev60Btn"),
  sceneAutoBtn: document.getElementById("sceneAutoBtn"),
  sceneSyncOnBtn: document.getElementById("sceneSyncOnBtn"),
  sceneSyncOffBtn: document.getElementById("sceneSyncOffBtn"),
  sceneSyncStat: document.getElementById("sceneSyncStat"),
  themeCogBtn: document.getElementById("themeCogBtn"),
  themePanel: document.getElementById("themePanel"),
  tabsBar: document.getElementById("tabsBar"),
  midiTabBtn: document.getElementById("midiTabBtn"),
  midiTabPage: document.getElementById("midiTabPage"),
  themeLogoColor: document.getElementById("themeLogoColor"),
  themeButtonColor: document.getElementById("themeButtonColor"),
  themeResetBtn: document.getElementById("themeResetBtn"),
  themeCloseBtn: document.getElementById("themeCloseBtn"),
  devDebugToggleBtn: document.getElementById("devDebugToggleBtn"),
  devDebugStatus: document.getElementById("devDebugStatus"),
  devToolsPanel: document.getElementById("devToolsPanel"),
  midiTabToggleBtn: document.getElementById("midiTabToggleBtn"),
  midiCogStatus: document.getElementById("midiCogStatus"),
  devToolRuntimeBtn: document.getElementById("devToolRuntimeBtn"),
  devToolConnectivityBtn: document.getElementById("devToolConnectivityBtn"),
  devToolHooksBtn: document.getElementById("devToolHooksBtn"),
  devToolTiersBtn: document.getElementById("devToolTiersBtn"),
  devToolsStatus: document.getElementById("devToolsStatus"),
  devToolsDump: document.getElementById("devToolsDump"),
  devOcAckGate: document.getElementById("devOcAckGate"),
  devOcAckInput: document.getElementById("devOcAckInput"),
  devOcAckPhrase: document.getElementById("devOcAckPhrase"),
  devOcAckCancelBtn: document.getElementById("devOcAckCancelBtn"),
  devOcAckConfirmBtn: document.getElementById("devOcAckConfirmBtn"),
  onboardStartBtn: document.getElementById("onboardStartBtn"),
  onboardResetBtn: document.getElementById("onboardResetBtn"),
  obsDockCompactBtn: document.getElementById("obsDockCompactBtn"),
  health: document.getElementById("health"),
  netBadge: document.getElementById("netBadge"),
  onboardGate: document.getElementById("onboardGate"),
  onboardAckBtn: document.getElementById("onboardAckBtn"),
  hueEntGuideGate: document.getElementById("hueEntGuideGate"),
  hueEntGuideAckBtn: document.getElementById("hueEntGuideAckBtn"),
  guidedTourGate: document.getElementById("guidedTourGate"),
  guidedTourStep: document.getElementById("guidedTourStep"),
  guidedTourTitle: document.getElementById("guidedTourTitle"),
  guidedTourText: document.getElementById("guidedTourText"),
  guidedTourPrevBtn: document.getElementById("guidedTourPrevBtn"),
  guidedTourNextBtn: document.getElementById("guidedTourNextBtn"),
  guidedTourSkipBtn: document.getElementById("guidedTourSkipBtn"),
  jumpRoutingLink: document.getElementById("jumpRoutingLink"),
  jumpModsLink: document.getElementById("jumpModsLink"),
  apiBaseInput: document.getElementById("apiBaseInput"),
  apiBaseSaveBtn: document.getElementById("apiBaseSaveBtn"),
  apiBaseResetBtn: document.getElementById("apiBaseResetBtn"),
  aDeviceMatch: document.getElementById("aDeviceMatch"),
  aDeviceId: document.getElementById("aDeviceId"),
  aSampleRate: document.getElementById("aSampleRate"),
  aFrames: document.getElementById("aFrames"),
  aChannels: document.getElementById("aChannels"),
  aGain: document.getElementById("aGain"),
  aNoise: document.getElementById("aNoise"),
  aPeakDecay: document.getElementById("aPeakDecay"),
  aBandLowHz: document.getElementById("aBandLowHz"),
  aBandMidHz: document.getElementById("aBandMidHz"),
  aLimiterThreshold: document.getElementById("aLimiterThreshold"),
  aLimiterKnee: document.getElementById("aLimiterKnee"),
  aRestartMs: document.getElementById("aRestartMs"),
  aLogTicks: document.getElementById("aLogTicks"),
  aDevices: document.getElementById("aDevices"),
  midiModuleStatus: document.getElementById("midiModuleStatus"),
  midiRuntimeStatus: document.getElementById("midiRuntimeStatus"),
  midiActivePort: document.getElementById("midiActivePort"),
  midiLearnStatus: document.getElementById("midiLearnStatus"),
  midiLastEvent: document.getElementById("midiLastEvent"),
  midiLastAction: document.getElementById("midiLastAction"),
  midiEnabled: document.getElementById("midiEnabled"),
  midiVelocityThreshold: document.getElementById("midiVelocityThreshold"),
  midiPortSelect: document.getElementById("midiPortSelect"),
  midiDeviceMatch: document.getElementById("midiDeviceMatch"),
  midiRefreshBtn: document.getElementById("midiRefreshBtn"),
  midiSaveCfgBtn: document.getElementById("midiSaveCfgBtn"),
  midiLearnAction: document.getElementById("midiLearnAction"),
  midiLearnArmBtn: document.getElementById("midiLearnArmBtn"),
  midiLearnCancelBtn: document.getElementById("midiLearnCancelBtn"),
  midiTriggerBtn: document.getElementById("midiTriggerBtn"),
  midiBindingAction: document.getElementById("midiBindingAction"),
  midiBindingType: document.getElementById("midiBindingType"),
  midiBindingNumber: document.getElementById("midiBindingNumber"),
  midiBindingChannel: document.getElementById("midiBindingChannel"),
  midiBindingMinValue: document.getElementById("midiBindingMinValue"),
  midiBindingSaveBtn: document.getElementById("midiBindingSaveBtn"),
  midiBindingClearBtn: document.getElementById("midiBindingClearBtn"),
  midiBindingResetBtn: document.getElementById("midiBindingResetBtn"),
  midiBindingsDump: document.getElementById("midiBindingsDump"),
  master: document.getElementById("master"),
  masterVal: document.getElementById("masterVal"),
  masterInlineResetBtn: document.getElementById("masterInlineResetBtn"),
  flowIntensity: document.getElementById("flowIntensity"),
  flowIntensityVal: document.getElementById("flowIntensityVal"),
  flowResetBtn: document.getElementById("flowResetBtn"),
  dropIntensity: document.getElementById("dropIntensity"),
  dropVal: document.getElementById("dropVal"),
  dropInlineResetBtn: document.getElementById("dropInlineResetBtn"),
  reactorResetBtn: document.getElementById("reactorResetBtn"),
  reactorRiskNotice: document.getElementById("reactorRiskNotice"),
  reactDropEnabled: document.getElementById("reactDropEnabled"),
  reactHardwareRateLimitsEnabled: document.getElementById("reactHardwareRateLimitsEnabled"),
  reactSmartMatchEnabled: document.getElementById("reactSmartMatchEnabled"),
  reactForceLockEnabled: document.getElementById("reactForceLockEnabled"),
  reactForceMatchOverride: document.getElementById("reactForceMatchOverride"),
  reactCompatSummary: document.getElementById("reactCompatSummary"),
  reactHueEnabled: document.getElementById("reactHueEnabled"),
  reactWizEnabled: document.getElementById("reactWizEnabled"),
  reactOtherEnabled: document.getElementById("reactOtherEnabled"),
  reactHueSources: document.getElementById("reactHueSources"),
  reactWizSources: document.getElementById("reactWizSources"),
  reactOtherSources: document.getElementById("reactOtherSources"),
  reactHueAmount: document.getElementById("reactHueAmount"),
  reactWizAmount: document.getElementById("reactWizAmount"),
  reactOtherAmount: document.getElementById("reactOtherAmount"),
  reactHueAmountVal: document.getElementById("reactHueAmountVal"),
  reactWizAmountVal: document.getElementById("reactWizAmountVal"),
  reactOtherAmountVal: document.getElementById("reactOtherAmountVal"),
  reactMapApplyBtn: document.getElementById("reactMapApplyBtn"),
  reactMapResetBtn: document.getElementById("reactMapResetBtn"),
  reactMapStatus: document.getElementById("reactMapStatus"),
  rms: document.getElementById("rms"),
  eng: document.getElementById("eng"),
  mode: document.getElementById("mode"),
  autoProfile: document.getElementById("autoProfile"),
  audioReact: document.getElementById("audioReact"),
  flowStat: document.getElementById("flowStat"),
  scene: document.getElementById("scene"),
  behavior: document.getElementById("behavior"),
  phrase: document.getElementById("phrase"),
  dropStat: document.getElementById("dropStat"),
  metaAutoStat: document.getElementById("metaAutoStat"),
  genreStat: document.getElementById("genreStat"),
  decadeStat: document.getElementById("decadeStat"),
  hSent: document.getElementById("hSent"),
  hSkip: document.getElementById("hSkip"),
  hLat: document.getElementById("hLat"),
  hState: document.getElementById("hState"),
  wSent: document.getElementById("wSent"),
  wSkip: document.getElementById("wSkip"),
  wLat: document.getElementById("wLat"),
  wState: document.getElementById("wState"),
  aLevel: document.getElementById("aLevel"),
  aRaw: document.getElementById("aRaw"),
  aPeak: document.getElementById("aPeak"),
  aTransient: document.getElementById("aTransient"),
  aZcr: document.getElementById("aZcr"),
  aBandLow: document.getElementById("aBandLow"),
  aBandMid: document.getElementById("aBandMid"),
  aBandHigh: document.getElementById("aBandHigh"),
  aFlux: document.getElementById("aFlux"),
  aDevice: document.getElementById("aDevice"),
  aRunning: document.getElementById("aRunning"),
  aRestart: document.getElementById("aRestart"),
  aError: document.getElementById("aError"),
  fixHue: document.getElementById("fixHue"),
  fixWiz: document.getElementById("fixWiz"),
  fixHueReady: document.getElementById("fixHueReady"),
  fixWizReady: document.getElementById("fixWizReady"),
  routeHue: document.getElementById("routeHue"),
  routeWiz: document.getElementById("routeWiz"),
  routeTwitchHue: document.getElementById("routeTwitchHue"),
  routeTwitchWiz: document.getElementById("routeTwitchWiz"),
  cfgVer: document.getElementById("cfgVer"),
  cfgAt: document.getElementById("cfgAt"),
  routeHueInput: document.getElementById("routeHueInput"),
  routeWizInput: document.getElementById("routeWizInput"),
  routeTwitchHueInput: document.getElementById("routeTwitchHueInput"),
  routeTwitchWizInput: document.getElementById("routeTwitchWizInput"),
  colorPrefixHue: document.getElementById("colorPrefixHue"),
  colorPrefixWiz: document.getElementById("colorPrefixWiz"),
  colorPrefixDefaultTarget: document.getElementById("colorPrefixDefaultTarget"),
  colorPrefixOtherWrap: document.getElementById("colorPrefixOtherWrap"),
  colorPrefixOther: document.getElementById("colorPrefixOther"),
  colorPrefixSaveBtn: document.getElementById("colorPrefixSaveBtn"),
  colorPrefixResetBtn: document.getElementById("colorPrefixResetBtn"),
  colorPrefixStatus: document.getElementById("colorPrefixStatus"),
  fxBrand: document.getElementById("fxBrand"),
  fxModBrandGroup: document.getElementById("fxModBrandGroup"),
  fxModBrandStatus: document.getElementById("fxModBrandStatus"),
  fxModBrandWrap: document.getElementById("fxModBrandWrap"),
  fxModBrandId: document.getElementById("fxModBrandId"),
  fxId: document.getElementById("fxId"),
  fxZone: document.getElementById("fxZone"),
  fxEnabled: document.getElementById("fxEnabled"),
  fxEngineEnabled: document.getElementById("fxEngineEnabled"),
  fxCustomEnabled: document.getElementById("fxCustomEnabled"),
  fxControlMode: document.getElementById("fxControlMode"),
  fxEngineBinding: document.getElementById("fxEngineBinding"),
  fxTwitchEnabled: document.getElementById("fxTwitchEnabled"),
  fxOriginalId: document.getElementById("fxOriginalId"),
  fxCompatHint: document.getElementById("fxCompatHint"),
  fxBridgeIp: document.getElementById("fxBridgeIp"),
  fxUsername: document.getElementById("fxUsername"),
  fxLightId: document.getElementById("fxLightId"),
  fxBridgeId: document.getElementById("fxBridgeId"),
  fxClientKey: document.getElementById("fxClientKey"),
  fxEntertainmentAreaId: document.getElementById("fxEntertainmentAreaId"),
  fxHueDiscoverBtn: document.getElementById("fxHueDiscoverBtn"),
  fxHuePairBtn: document.getElementById("fxHuePairBtn"),
  fxHueSaveBridgeBtn: document.getElementById("fxHueSaveBridgeBtn"),
  fxWizIp: document.getElementById("fxWizIp"),
  fxBridgeIpShowBtn: document.getElementById("fxBridgeIpShowBtn"),
  fxUsernameShowBtn: document.getElementById("fxUsernameShowBtn"),
  fxClientKeyShowBtn: document.getElementById("fxClientKeyShowBtn"),
  fxWizIpShowBtn: document.getElementById("fxWizIpShowBtn"),
  fxSaveBtn: document.getElementById("fxSaveBtn"),
  fxResetBtn: document.getElementById("fxResetBtn"),
  fxHueBridgeBlock: document.getElementById("fxHueBridgeBlock"),
  fxHueBridgeWrap: document.getElementById("fxHueBridgeWrap"),
  fxHueUserWrap: document.getElementById("fxHueUserWrap"),
  fxHueLightWrap: document.getElementById("fxHueLightWrap"),
  fxHueBridgeIdWrap: document.getElementById("fxHueBridgeIdWrap"),
  fxHueClientKeyWrap: document.getElementById("fxHueClientKeyWrap"),
  fxHueEntWrap: document.getElementById("fxHueEntWrap"),
  fxHuePairWrap: document.getElementById("fxHuePairWrap"),
  fxWizIpWrap: document.getElementById("fxWizIpWrap"),
  fxWizIpLabel: document.getElementById("fxWizIpLabel"),
  fixtureRows: document.getElementById("fixtureRows"),
  standFixtureSelect: document.getElementById("standFixtureSelect"),
  customFixtureSelect: document.getElementById("customFixtureSelect"),
  customFixtureSyncBtn: document.getElementById("customFixtureSyncBtn"),
  customStandaloneMount: document.getElementById("customStandaloneMount"),
  standRouteEngine: document.getElementById("standRouteEngine"),
  standRouteTwitch: document.getElementById("standRouteTwitch"),
  standRouteCustom: document.getElementById("standRouteCustom"),
  standRouteApplyBtn: document.getElementById("standRouteApplyBtn"),
  standConnectivityBtn: document.getElementById("standConnectivityBtn"),
  standRouteStatus: document.getElementById("standRouteStatus"),
  standConnectivityStatus: document.getElementById("standConnectivityStatus"),
  standCustomCluster: document.getElementById("standCustomCluster"),
  standPower: document.getElementById("standPower"),
  standMode: document.getElementById("standMode"),
  standScene: document.getElementById("standScene"),
  standAnimate: document.getElementById("standAnimate"),
  standSpeedMode: document.getElementById("standSpeedMode"),
  standSpeedHz: document.getElementById("standSpeedHz"),
  standSpeedMinHz: document.getElementById("standSpeedMinHz"),
  standSpeedMinHzVal: document.getElementById("standSpeedMinHzVal"),
  standSpeedMaxHz: document.getElementById("standSpeedMaxHz"),
  standSpeedMaxHzVal: document.getElementById("standSpeedMaxHzVal"),
  standBrightness: document.getElementById("standBrightness"),
  standBrightnessVal: document.getElementById("standBrightnessVal"),
  standColorMode: document.getElementById("standColorMode"),
  standStaticBtn: document.getElementById("standStaticBtn"),
  standRaveStartBtn: document.getElementById("standRaveStartBtn"),
  standRaveStopBtn: document.getElementById("standRaveStopBtn"),
  standHsvSingleWrap: document.getElementById("standHsvSingleWrap"),
  standHsvRangeRow: document.getElementById("standHsvRangeRow"),
  standCctRangeRow: document.getElementById("standCctRangeRow"),
  standHue: document.getElementById("standHue"),
  standHueVal: document.getElementById("standHueVal"),
  standHueMin: document.getElementById("standHueMin"),
  standHueMinVal: document.getElementById("standHueMinVal"),
  standHueMax: document.getElementById("standHueMax"),
  standHueMaxVal: document.getElementById("standHueMaxVal"),
  standSat: document.getElementById("standSat"),
  standSatVal: document.getElementById("standSatVal"),
  standSatMin: document.getElementById("standSatMin"),
  standSatMinVal: document.getElementById("standSatMinVal"),
  standSatMax: document.getElementById("standSatMax"),
  standSatMaxVal: document.getElementById("standSatMaxVal"),
  standCctKelvin: document.getElementById("standCctKelvin"),
  standCctKelvinVal: document.getElementById("standCctKelvinVal"),
  standCctMinKelvin: document.getElementById("standCctMinKelvin"),
  standCctMinKelvinVal: document.getElementById("standCctMinKelvinVal"),
  standCctMaxKelvin: document.getElementById("standCctMaxKelvin"),
  standCctMaxKelvinVal: document.getElementById("standCctMaxKelvinVal"),
  standTransitionMs: document.getElementById("standTransitionMs"),
  standApplyBtn: document.getElementById("standApplyBtn"),
  standRefreshBtn: document.getElementById("standRefreshBtn"),
  standStatus: document.getElementById("standStatus"),
  sceneLockStat: document.getElementById("sceneLockStat"),
  pollMs: document.getElementById("pollMs"),
  dropOverlay: document.getElementById("dropOverlay"),
  modsStatus: document.getElementById("modsStatus"),
  modDropZone: document.getElementById("modDropZone"),
  modImportStatus: document.getElementById("modImportStatus"),
  modImportBrowseBtn: document.getElementById("modImportBrowseBtn"),
  modImportOverwrite: document.getElementById("modImportOverwrite"),
  modImportEnable: document.getElementById("modImportEnable"),
  modImportPicker: document.getElementById("modImportPicker"),
  modsRows: document.getElementById("modsRows"),
  moddingReadmeBtn: document.getElementById("moddingReadmeBtn"),
  modsRefreshBtn: document.getElementById("modsRefreshBtn"),
  modsReloadBtn: document.getElementById("modsReloadBtn"),
  modEnableId: document.getElementById("modEnableId"),
  modEnableBtn: document.getElementById("modEnableBtn"),
  modDisableBtn: document.getElementById("modDisableBtn"),
  modApplyBtn: document.getElementById("modApplyBtn"),
  modDiscardBtn: document.getElementById("modDiscardBtn"),
  modHotswapStatus: document.getElementById("modHotswapStatus"),
  modActionModId: document.getElementById("modActionModId"),
  modActionName: document.getElementById("modActionName"),
  modActionMethod: document.getElementById("modActionMethod"),
  modActionRunBtn: document.getElementById("modActionRunBtn"),
  modActionOutput: document.getElementById("modActionOutput"),
  modUiPanel: document.getElementById("modUiPanel"),
  modUiSelect: document.getElementById("modUiSelect"),
  modUiRefreshBtn: document.getElementById("modUiRefreshBtn"),
  modUiReloadBtn: document.getElementById("modUiReloadBtn"),
  modUiOpenBtn: document.getElementById("modUiOpenBtn"),
  modUiStatus: document.getElementById("modUiStatus"),
  modUiFrameWrap: document.getElementById("modUiFrameWrap"),
  modUiFrame: document.getElementById("modUiFrame"),
  modUiEmpty: document.getElementById("modUiEmpty"),
  scopeDrive: document.getElementById("scopeDrive"),
  scopeMotion: document.getElementById("scopeMotion"),
  scopeScene: document.getElementById("scopeScene"),
  scopeBehav: document.getElementById("scopeBehav"),
  canvas: document.getElementById("canvas"),
  telemetryCanvas: document.getElementById("telemetryCanvas"),
  genreGrid: document.getElementById("genreGrid")
};

const tabButtons = Array.from(document.querySelectorAll("[data-tab-btn]"));
const tabPages = Array.from(document.querySelectorAll("[data-tab]"));
const sceneButtons = Array.from(document.querySelectorAll("[data-scene]"));
const autoProfileButtons = Array.from(document.querySelectorAll("[data-auto-profile]"));
const audioReactivityButtons = Array.from(document.querySelectorAll("[data-audio-reactivity]"));
const audioQuickPresetButtons = Array.from(document.querySelectorAll("[data-audio-quick]"));
const decadeButtons = Array.from(document.querySelectorAll("[data-decade-mode]"));
const limiterPresetButtons = Array.from(document.querySelectorAll("[data-limiter-preset]"));
const getGenreButtons = () => Array.from(el.genreGrid.querySelectorAll("[data-genre]"));
const themePresetButtons = Array.from(document.querySelectorAll("[data-theme-preset]"));
const MOD_BRAND_RE = /^[a-z][a-z0-9_-]{1,31}$/;
const FIXTURE_MOD_CUSTOM_BRAND_VALUE = "__mod_custom__";

const LIMITER_PRESETS = {
  transparent: { limiterThreshold: 0.9, limiterKnee: 0.24 },
  balanced: { limiterThreshold: 0.82, limiterKnee: 0.16 },
  hard: { limiterThreshold: 0.72, limiterKnee: 0.08 }
};
const AUDIO_QUICK_PROFILES = Object.freeze({
  safe: { sampleRate: 48000, framesPerBuffer: 512 },
  balanced: { sampleRate: 48000, framesPerBuffer: 256 },
  fast: { sampleRate: 48000, framesPerBuffer: 128 },
  hires: { sampleRate: 96000, framesPerBuffer: 256 }
});
const AUDIO_CONFIG_DEFAULTS = Object.freeze({
  deviceMatch: "",
  deviceId: null,
  sampleRate: 96000,
  framesPerBuffer: 256,
  channels: 2,
  outputGain: 1,
  noiseFloorMin: 0.00045,
  peakDecay: 0.93,
  bandLowHz: 180,
  bandMidHz: 2200,
  limiterThreshold: 0.82,
  limiterKnee: 0.16,
  restartMs: 1500,
  logEveryTicks: 60
});
const AUDIO_REACTIVITY_SOURCE_CATALOG_DEFAULT = Object.freeze({
  smart: Object.freeze({ label: "SMART", description: "Adaptive blend" }),
  baseline: Object.freeze({ label: "BASE", description: "Steady RMS/body" }),
  bass: Object.freeze({ label: "BASS", description: "Low band" }),
  mids: Object.freeze({ label: "MIDS", description: "Mid band" }),
  highs: Object.freeze({ label: "HIGHS", description: "High band" }),
  peaks: Object.freeze({ label: "PEAKS", description: "Peak envelope" }),
  transients: Object.freeze({ label: "TRANS", description: "Attack spikes" }),
  flux: Object.freeze({ label: "FLUX", description: "Spectral motion" }),
  drums: Object.freeze({ label: "DRUMS", description: "Percussive blend" }),
  vocals: Object.freeze({ label: "VOCALS", description: "Vocal focus" }),
  beat: Object.freeze({ label: "BEAT", description: "Beat confidence" }),
  groove: Object.freeze({ label: "GROOVE", description: "Body blend" })
});
const AUDIO_REACTIVITY_TARGET_KEYS = Object.freeze(["hue", "wiz", "other"]);
const AUDIO_REACTIVITY_MAP_DEFAULT = Object.freeze({
  version: 1,
  dropEnabled: false,
  hardwareRateLimitsEnabled: true,
  targets: Object.freeze({
    hue: Object.freeze({ enabled: true, amount: 1, sources: Object.freeze(["smart"]) }),
    wiz: Object.freeze({ enabled: true, amount: 1, sources: Object.freeze(["smart"]) }),
    other: Object.freeze({ enabled: true, amount: 1, sources: Object.freeze(["smart"]) })
  })
});
const AUDIO_REACTIVITY_SOURCE_ORDER = Object.freeze([
  "smart",
  "baseline",
  "bass",
  "mids",
  "highs",
  "peaks",
  "transients",
  "flux",
  "drums",
  "vocals",
  "beat",
  "groove"
]);
const LIVE_REACTIVITY_STATE_WEIGHT = Object.freeze({
  modeLock: 1.2,
  autoProfile: 0.95,
  audioReactivityPreset: 1.25,
  sceneLock: 1.45,
  genre: 0.85,
  genreDecadeMode: 0.35,
  overclockBand: 0.85
});
const LIVE_REACTIVITY_SOURCE_BY_STATE = Object.freeze({
  modeLock: Object.freeze({
    auto: Object.freeze(["smart", "drums", "transients", "beat"]),
    clamp: Object.freeze(["drums", "transients", "bass", "peaks"]),
    interpret: Object.freeze(["beat", "drums", "transients", "groove"])
  }),
  autoProfile: Object.freeze({
    reactive: Object.freeze(["transients", "drums", "peaks", "flux"]),
    balanced: Object.freeze(["smart", "drums", "beat", "transients"]),
    cinematic: Object.freeze(["baseline", "vocals", "mids", "smart"])
  }),
  audioReactivityPreset: Object.freeze({
    balanced: Object.freeze(["smart", "drums", "beat", "transients"]),
    aggressive: Object.freeze(["peaks", "transients", "drums", "bass"]),
    precision: Object.freeze(["beat", "vocals", "highs", "baseline"])
  }),
  sceneLock: Object.freeze({
    auto: Object.freeze(["smart", "drums", "transients", "beat"]),
    idle_soft: Object.freeze(["baseline", "vocals", "mids"]),
    flow: Object.freeze(["groove", "mids", "flux", "bass"]),
    pulse_strobe: Object.freeze(["drums", "peaks", "transients", "beat"])
  }),
  genre: Object.freeze({
    edm: Object.freeze(["drums", "peaks", "transients", "flux"]),
    hiphop: Object.freeze(["bass", "groove", "drums", "baseline"]),
    metal: Object.freeze(["peaks", "transients", "drums", "highs"]),
    ambient: Object.freeze(["baseline", "vocals", "highs", "smart"]),
    house: Object.freeze(["bass", "groove", "beat", "transients"]),
    trance: Object.freeze(["highs", "flux", "beat", "mids"]),
    dnb: Object.freeze(["drums", "bass", "peaks", "transients"]),
    pop: Object.freeze(["vocals", "mids", "beat", "groove"]),
    rock: Object.freeze(["mids", "drums", "peaks", "bass"]),
    rnb: Object.freeze(["vocals", "baseline", "groove", "mids"]),
    techno: Object.freeze(["transients", "flux", "peaks", "drums"]),
    media: Object.freeze(["baseline", "vocals", "mids", "smart"]),
    auto: Object.freeze(["smart", "drums", "beat", "transients"])
  }),
  genreDecadeMode: Object.freeze({
    auto: Object.freeze(["smart", "drums", "beat"]),
    "90s": Object.freeze(["baseline", "groove", "vocals"]),
    "00s": Object.freeze(["bass", "mids", "groove"]),
    "10s": Object.freeze(["drums", "beat", "mids"]),
    "20s": Object.freeze(["transients", "flux", "peaks", "drums"])
  }),
  overclockBand: Object.freeze({
    low: Object.freeze(["smart", "beat", "groove", "mids"]),
    medium: Object.freeze(["drums", "transients", "beat", "smart"]),
    high: Object.freeze(["transients", "peaks", "drums", "flux"])
  })
});
const LIVE_REACTIVITY_TARGET_BIAS = Object.freeze({
  hue: Object.freeze({
    smart: 0.28,
    baseline: 0.12,
    groove: 0.08,
    beat: 0.16,
    vocals: 0.08,
    mids: 0.11,
    highs: 0.06,
    bass: 0.12,
    transients: 0.16,
    peaks: 0.14,
    flux: 0.1,
    drums: 0.18
  }),
  wiz: Object.freeze({
    smart: 0.14,
    drums: 0.3,
    transients: 0.24,
    peaks: 0.22,
    flux: 0.2,
    bass: 0.14,
    beat: 0.14,
    groove: 0.1,
    mids: 0.08,
    highs: 0.11,
    baseline: -0.04,
    vocals: -0.02
  }),
  other: Object.freeze({
    smart: 0.22,
    groove: 0.14,
    beat: 0.16,
    mids: 0.12,
    bass: 0.14,
    vocals: 0.06,
    highs: 0.07,
    flux: 0.12,
    transients: 0.14,
    peaks: 0.12,
    drums: 0.16,
    baseline: 0.04
  })
});
let liveSmartMatchSaveTimer = null;
let liveSmartMatchSaveInFlight = false;
let liveSmartMatchSaveQueued = false;
let audioReactivitySourceCatalogRuntime = { ...AUDIO_REACTIVITY_SOURCE_CATALOG_DEFAULT };
const DEV_OVERCLOCK_LEVEL_BY_HZ = Object.freeze({
  20: 8,
  30: 9,
  40: 10,
  50: 11,
  60: 12
});
const MIDI_ACTION_LABELS = Object.freeze({
  drop: "DROP HIT",
  overclock_toggle: "OVERCLOCK TOGGLE",
  overclock_on: "OVERCLOCK ON",
  overclock_off: "OVERCLOCK OFF",
  overclock_up: "OVERCLOCK UP",
  overclock_down: "OVERCLOCK DOWN",
  behavior_auto: "MODE AUTO",
  behavior_clamp: "MODE GAME/CLAMP",
  behavior_interpret: "MODE BPM/INTERPRET",
  scene_auto: "SCENE AUTO",
  scene_idle: "SCENE IDLE",
  scene_flow: "SCENE FLOW",
  scene_pulse: "SCENE PULSE",
  auto_profile_reactive: "AUTO PROFILE REACTIVE",
  auto_profile_balanced: "AUTO PROFILE BALANCED",
  auto_profile_cinematic: "AUTO PROFILE CINEMATIC",
  audio_reactivity_balanced: "AUDIO REACT BALANCED",
  audio_reactivity_aggressive: "AUDIO REACT AGGRESSIVE",
  audio_reactivity_precision: "AUDIO REACT PRECISION",
  meta_auto_toggle: "META AUTO TOGGLE",
  meta_auto_on: "META AUTO ON",
  meta_auto_off: "META AUTO OFF"
});
const MIDI_FALLBACK_ACTIONS = Object.freeze(Object.keys(MIDI_ACTION_LABELS));

function setNodeTitle(node, text) {
  if (!node) return;
  node.title = text;
}

function applyUiTooltips() {
  setNodeTitle(el.onBtn, "Start reactive rave output.");
  setNodeTitle(el.offBtn, "Stop reactive rave output.");
  setNodeTitle(el.panicBtn, "Emergency blackout command.");
  setNodeTitle(el.themeCogBtn, "Open theme settings.");
  setNodeTitle(el.obsDockCompactBtn, "Toggle compact OBS dock layout.");
  setNodeTitle(
    el.devDebugToggleBtn,
    "Toggle DEV/DEBUG mode. One-time warning on first enable, then unsafe 20-60Hz controls remain unlocked."
  );
  setNodeTitle(
    el.devDebugStatus,
    "DEV mode exposes unsafe overclock routes and is intended only for controlled test environments."
  );
  setNodeTitle(el.devToolRuntimeBtn, "Fetch /mods/runtime and show a quick runtime snapshot.");
  setNodeTitle(el.devToolConnectivityBtn, "Fetch /fixtures/connectivity for quick fixture health checks.");
  setNodeTitle(el.devToolHooksBtn, "Fetch /mods/hooks to inspect loaded hook maps.");
  setNodeTitle(el.devToolTiersBtn, "Fetch /rave/overclock/tiers to inspect safe/dev tier availability.");
  setNodeTitle(el.devToolsStatus, "Last dev tool execution status.");
  setNodeTitle(el.devToolsDump, "Latest JSON response from dev tools.");
  setNodeTitle(el.midiTabToggleBtn, "Show or hide MIDI tab when no MIDI device is detected.");
  setNodeTitle(el.midiCogStatus, "Current MIDI detection + tab visibility policy.");
  setNodeTitle(el.devOcAckInput, "Comical destructive overclock confirmation phrase input.");
  setNodeTitle(el.devOcAckConfirmBtn, "Arm unsafe overclock if phrase matches exactly.");
  setNodeTitle(el.devOcAckCancelBtn, "Cancel unsafe overclock arming.");
  setNodeTitle(el.modeAutoBtn, "Dynamic AUTO mode selection from live signal motion.");
  setNodeTitle(el.gameBtn, "GAME/CLAMP: steadier state machine with higher switch thresholds.");
  setNodeTitle(el.bpmBtn, "BPM/INTERPRET: faster switching and more motion-driven response.");
  setNodeTitle(
    el.metaAutoOnBtn,
    "Enable Meta Auto. It infers genre from live audio metrics and controls profile/reactivity/Hz."
  );
  setNodeTitle(
    el.metaAutoOffBtn,
    "Disable Meta Auto and return to manual controls. Manual profile/reactivity/genre/decade/overclock selections also disable Meta Auto."
  );
  setNodeTitle(el.aResetDefaultsBtn, "Restore audio controls to defaults and apply immediately.");
  setNodeTitle(el.reactDropEnabled, "Enable/disable drop-trigger behavior (off by default).");
  setNodeTitle(
    el.reactHardwareRateLimitsEnabled,
    "Recommended ON: clamp Hue/WiZ send rates to hardware-safe ranges. Turn off only for controlled testing."
  );
  setNodeTitle(
    el.reactSmartMatchEnabled,
    "Recommended: LIVE tab selections auto-pick per-brand compatible sources and keep Smart Mix available."
  );
  setNodeTitle(
    el.reactForceLockEnabled,
    "Force each brand to one source. Incompatible sources are locked unless FORCE MATCH OVERRIDE is enabled."
  );
  setNodeTitle(
    el.reactForceMatchOverride,
    "Allow forced sources even when they do not match current LIVE compatibility profile."
  );
  setNodeTitle(el.reactCompatSummary, "Current LIVE compatibility + lock policy summary.");
  setNodeTitle(el.reactMapApplyBtn, "Save per-brand audio source routing map.");
  setNodeTitle(el.reactMapResetBtn, "Reset per-brand audio source routing map to defaults.");
  setNodeTitle(el.reactMapStatus, "Current audio reactivity routing summary.");
  setNodeTitle(el.ocDev20Btn, "Unsafe manual overclock 20Hz.");
  setNodeTitle(el.ocDev30Btn, "Unsafe manual overclock 30Hz.");
  setNodeTitle(el.ocDev40Btn, "Unsafe manual overclock 40Hz.");
  setNodeTitle(el.ocDev50Btn, "Unsafe manual overclock 50Hz.");
  setNodeTitle(el.ocDev60Btn, "Unsafe manual overclock 60Hz.");
  setNodeTitle(el.master, "Overall output scaling multiplier.");
  setNodeTitle(el.masterInlineResetBtn, "Reset MASTER to default.");
  setNodeTitle(el.flowIntensity, "Flow animation intensity multiplier for flow behavior.");
  setNodeTitle(el.flowResetBtn, "Reset FLOW INTENSITY back to default (1.00x).");
  setNodeTitle(el.sceneSyncOnBtn, "Link scene behavior across active engine fixtures.");
  setNodeTitle(el.sceneSyncOffBtn, "Allow fixtures to run independent/desynced scene variants.");
  setNodeTitle(el.sceneSyncStat, "Current fixture scene-link mode for live engine output.");
  setNodeTitle(el.dropIntensity, "How hard drop events hit visuals.");
  setNodeTitle(el.dropInlineResetBtn, "Reset DROP IMPACT to default.");
  setNodeTitle(el.reactorResetBtn, "Reset both MASTER and DROP IMPACT to defaults.");
  setNodeTitle(
    el.reactorRiskNotice,
    "High MASTER and DROP values can reduce quality and increase instability, especially with high OVERCLOCK."
  );
  setNodeTitle(el.colorPrefixHue, "Optional Hue color prefix. Leave blank to disable prefix matching.");
  setNodeTitle(el.colorPrefixWiz, "Optional WiZ color prefix. Leave blank to disable prefix matching.");
  setNodeTitle(el.colorPrefixDefaultTarget, "Where unprefixed /color commands are sent by default.");
  setNodeTitle(
    el.colorPrefixOther,
    "Prefix for future mod-brand Twitch color commands. Enabled when mod-brand Twitch fixtures are available."
  );
  setNodeTitle(el.colorPrefixSaveBtn, "Save Twitch color prefix/default-target config.");
  setNodeTitle(el.colorPrefixResetBtn, "Reset Twitch color prefix config to defaults.");
  setNodeTitle(el.modUiSelect, "Choose a loaded mod UI package.");
  setNodeTitle(el.modUiRefreshBtn, "Refresh UI catalog from mod loader routes.");
  setNodeTitle(el.modUiReloadBtn, "Reload selected mod UI frame.");
  setNodeTitle(el.modUiOpenBtn, "Open selected mod UI in a separate browser tab.");
  setNodeTitle(el.modUiStatus, "Current status for mod UI catalog and selected host frame.");
  setNodeTitle(el.modUiFrame, "Sandboxed mod UI frame.");
  setNodeTitle(el.customFixtureSelect, "Custom-routed fixtures from both Hue and WiZ brands.");
  setNodeTitle(el.customFixtureSyncBtn, "Use selected custom fixture as active device control target.");
  setNodeTitle(el.legacyAutomationUnlockBtn, "Open deprecated automation controls.");
  setNodeTitle(el.legacyAutomationLockBtn, "Hide deprecated automation controls.");
  setNodeTitle(el.legacyAutomationJumpCustomBtn, "Jump to Custom Fixture Control (recommended replacement).");
  setNodeTitle(el.modDropZone, "Drop a mod folder here to import directly.");
  setNodeTitle(el.modImportStatus, "Current drag/drop import status.");
  setNodeTitle(el.modImportBrowseBtn, "Pick a mod folder from disk and import it.");
  setNodeTitle(el.modImportOverwrite, "Replace existing mod files when mod id already exists.");
  setNodeTitle(el.modImportEnable, "Automatically enable imported mod and apply hotswap.");
  setNodeTitle(el.modImportPicker, "Folder picker for mod import.");
  setNodeTitle(el.moddingReadmeBtn, "Open formatted modding developer docs in a separate page.");
  setNodeTitle(el.systemStartTab, "Default tab to open when this UI loads.");
  setNodeTitle(el.systemConfirmActions, "Require confirms for panic/reload/stop actions.");
  setNodeTitle(el.systemPollingMode, "Pause or resume automatic telemetry polling.");
  setNodeTitle(el.systemAutoLaunchBrowser, "Enable/disable browser auto-launch when the server starts.");
  setNodeTitle(
    el.systemUnsafeSensitiveLogs,
    "Dangerous DEV option: disable server-side redaction and allow sensitive credentials/ids/tokens to appear in logs."
  );
  setNodeTitle(el.systemSettingsSaveBtn, "Persist local settings plus server browser-launch and log-redaction settings.");
  setNodeTitle(el.systemSettingsResetBtn, "Reset system settings back to defaults.");
  setNodeTitle(el.systemPollNowBtn, "Run one immediate telemetry/config poll.");
  setNodeTitle(el.systemClearCacheBtn, "Clear UI local/session/cache memory and reload this page.");
  setNodeTitle(el.systemSettingsStatus, "Current saved system settings summary.");
  setNodeTitle(el.fxBridgeIpShowBtn, "Reveal/hide Hue bridge IP after warning confirmation.");
  setNodeTitle(el.fxUsernameShowBtn, "Reveal/hide Hue username/app key after warning confirmation.");
  setNodeTitle(el.fxClientKeyShowBtn, "Reveal/hide Hue client key after warning confirmation.");
  setNodeTitle(el.fxWizIpShowBtn, "Reveal/hide WiZ IP after warning confirmation.");
  setNodeTitle(el.midiModuleStatus, "Whether Node MIDI module is available.");
  setNodeTitle(el.midiRuntimeStatus, "MIDI runtime connection status.");
  setNodeTitle(el.midiActivePort, "Currently opened MIDI input port.");
  setNodeTitle(el.midiLearnStatus, "Current MIDI learn target and timeout status.");
  setNodeTitle(el.midiLastEvent, "Most recent MIDI packet observed by runtime.");
  setNodeTitle(el.midiLastAction, "Most recent engine action triggered from MIDI.");
  setNodeTitle(el.midiEnabled, "Enable or disable MIDI input handling.");
  setNodeTitle(el.midiVelocityThreshold, "Default minimum value threshold for new bindings.");
  setNodeTitle(el.midiPortSelect, "Preferred MIDI input port. AUTO uses first available/match.");
  setNodeTitle(el.midiDeviceMatch, "Optional case-insensitive port-name contains matcher.");
  setNodeTitle(el.midiRefreshBtn, "Rescan MIDI ports and reconnect runtime.");
  setNodeTitle(el.midiSaveCfgBtn, "Save MIDI config and reconnect if needed.");
  setNodeTitle(el.midiLearnAction, "Action that learn mode will map to next MIDI input.");
  setNodeTitle(el.midiLearnArmBtn, "Arm learn mode for selected action.");
  setNodeTitle(el.midiLearnCancelBtn, "Cancel active learn mode.");
  setNodeTitle(el.midiTriggerBtn, "Trigger selected action directly for testing.");
  setNodeTitle(el.midiBindingAction, "Action whose binding you want to inspect or edit.");
  setNodeTitle(el.midiBindingType, "Binding message type.");
  setNodeTitle(el.midiBindingNumber, "MIDI note/CC number (0-127).");
  setNodeTitle(el.midiBindingChannel, "Optional MIDI channel filter (1-16). Leave blank for any.");
  setNodeTitle(el.midiBindingMinValue, "Minimum value required to trigger action (0-127).");
  setNodeTitle(el.midiBindingSaveBtn, "Save/update binding for selected action.");
  setNodeTitle(el.midiBindingClearBtn, "Remove binding for selected action.");
  setNodeTitle(el.midiBindingResetBtn, "Restore default DROP + OVERCLOCK bindings.");
  setNodeTitle(el.midiBindingsDump, "Current MIDI config and action bindings snapshot.");

  const autoProfileTips = {
    reactive: "Fastest confirms/holds for punchy behavior and rapid scene changes.",
    balanced: "Middle-ground timing and hysteresis for general use.",
    cinematic: "Longest holds/confirms and strongest hysteresis for smoother output."
  };
  autoProfileButtons.forEach(btn => {
    const key = String(btn.dataset.autoProfile || "");
    setNodeTitle(btn, autoProfileTips[key] || "Set automatic profile behavior.");
  });

  const reactTips = {
    balanced: "Neutral detection and pulse thresholds.",
    aggressive: "Lower pulse gates and higher motion gain for stronger hits.",
    precision: "Higher gates and stricter trend checks for calmer, cleaner output."
  };
  audioReactivityButtons.forEach(btn => {
    const key = String(btn.dataset.audioReactivity || "");
    setNodeTitle(btn, reactTips[key] || "Set audio reactivity preset.");
  });

  sceneButtons.forEach(btn => {
    const key = String(btn.dataset.scene || "").toLowerCase();
    if (key === "auto") setNodeTitle(btn, "Auto-select scene based on telemetry.");
    else if (key === "flow") setNodeTitle(btn, "Lock scene to a fixed flow variant (not rotating).");
    else setNodeTitle(btn, `Lock scene to ${key}.`);
  });

  getGenreButtons().forEach(btn => {
    const key = String(btn.dataset.genre || "").toUpperCase();
    setNodeTitle(
      btn,
      key === "AUTO"
        ? "Auto-mix between genre signatures. Meta Auto ignores this while enabled."
        : `Switch to ${key} signature: unique behavior/palette tuning. Meta Auto ignores this while enabled.`
    );
  });

  decadeButtons.forEach(btn => {
    const key = String(btn.dataset.decadeMode || "").toUpperCase();
    setNodeTitle(
      btn,
      key === "AUTO"
        ? "Auto-select decade style from live motion/BPM. Meta Auto ignores this while enabled."
        : `Force decade style ${key}: distinct tempo + aggression bias. Meta Auto ignores this while enabled.`
    );
  });
}

function detectLimiterPreset(config = {}) {
  const threshold = Number(config.limiterThreshold);
  const knee = Number(config.limiterKnee);
  if (!Number.isFinite(threshold) || !Number.isFinite(knee)) return "balanced";

  let best = "balanced";
  let bestDist = Number.POSITIVE_INFINITY;
  for (const [name, p] of Object.entries(LIMITER_PRESETS)) {
    const dist = Math.abs(threshold - p.limiterThreshold) + Math.abs(knee - p.limiterKnee);
    if (dist < bestDist) {
      bestDist = dist;
      best = name;
    }
  }
  return bestDist <= 0.035 ? best : "custom";
}

function setBadge(node, state, text) {
  if (!node) return;
  const nextState = String(state || "").trim().toLowerCase();
  const nextText = String(text || "");
  const stateChanged = !node.classList.contains(nextState);
  const textChanged = node.textContent !== nextText;
  if (!stateChanged && !textChanged) return;
  node.classList.remove("ok", "warn", "bad");
  if (nextState) node.classList.add(nextState);
  node.textContent = nextText;
}

function normalizeHexColor(value, fallback = "#8b001f") {
  const raw = String(value || "").trim().toLowerCase();
  if (/^#[0-9a-f]{6}$/.test(raw)) return raw;
  return String(fallback || "#8b001f").toLowerCase();
}

function hexToRgba(hex, alpha = 0.67) {
  const safe = normalizeHexColor(hex, "#8b001f");
  const r = parseInt(safe.slice(1, 3), 16);
  const g = parseInt(safe.slice(3, 5), 16);
  const b = parseInt(safe.slice(5, 7), 16);
  const a = Math.max(0, Math.min(1, Number(alpha) || 0));
  return `rgba(${r}, ${g}, ${b}, ${a.toFixed(3)})`;
}

function getThemePreset(name) {
  const key = String(name || "").trim().toLowerCase();
  if (THEME_PRESETS[key]) return { ...THEME_PRESETS[key] };
  return { ...THEME_PRESETS[DEFAULT_THEME_NAME] };
}

function normalizeThemeCustomConfig(customConfig = {}, fallbackPreset = {}) {
  const custom = customConfig && typeof customConfig === "object" ? customConfig : {};
  const fallback = fallbackPreset && typeof fallbackPreset === "object"
    ? fallbackPreset
    : getThemePreset(DEFAULT_THEME_NAME);
  return {
    bg: normalizeHexColor(custom.bg, fallback.bg),
    panel: normalizeHexColor(custom.panel, fallback.panel),
    panel2: normalizeHexColor(custom.panel2, fallback.panel2),
    accent: normalizeHexColor(custom.accent, fallback.accent),
    edge: normalizeHexColor(custom.edge, fallback.edge),
    btnBg: normalizeHexColor(custom.btnBg, fallback.btnBg),
    text: normalizeHexColor(custom.text, fallback.text)
  };
}

function applyThemeConfig(config = {}, options = {}) {
  const preset = getThemePreset(ui.themeName);
  const next = {
    ...preset,
    ...(config && typeof config === "object" ? config : {})
  };

  next.bg = normalizeHexColor(next.bg, preset.bg);
  next.panel = normalizeHexColor(next.panel, preset.panel);
  next.panel2 = normalizeHexColor(next.panel2, preset.panel2);
  next.accent = normalizeHexColor(next.accent, preset.accent);
  next.edge = normalizeHexColor(next.edge, preset.edge);
  next.btnBg = normalizeHexColor(next.btnBg, preset.btnBg);
  next.text = normalizeHexColor(next.text, preset.text);

  const root = document.documentElement;
  root.style.setProperty("--bg", next.bg);
  root.style.setProperty("--panel", next.panel);
  root.style.setProperty("--panel2", next.panel2);
  root.style.setProperty("--accent", next.accent);
  root.style.setProperty("--accentGlow", hexToRgba(next.accent, 0.67));
  root.style.setProperty("--edge", next.edge);
  root.style.setProperty("--btn-bg", next.btnBg);
  root.style.setProperty("--text", next.text);

  ui.themeConfig = next;

  if (options.persist !== false) {
    localStorage.setItem(
      THEME_STORAGE_KEY,
      JSON.stringify({
        name: ui.themeName,
        custom: normalizeThemeCustomConfig(next, preset)
      })
    );
  }
}

function setDevDebugMode(enabled, options = {}) {
  ui.devDebugMode = Boolean(enabled);

  if (el.ocDevCluster) {
    el.ocDevCluster.classList.toggle("hidden", !ui.devDebugMode);
  }
  if (el.devToolsPanel) {
    el.devToolsPanel.classList.toggle("hidden", !ui.devDebugMode);
  }
  if (el.devDebugToggleBtn) {
    el.devDebugToggleBtn.textContent = ui.devDebugMode ? "DEV DEBUG ON" : "DEV DEBUG OFF";
    el.devDebugToggleBtn.classList.toggle("active", ui.devDebugMode);
  }
  if (el.devDebugStatus) {
    el.devDebugStatus.textContent = ui.devDebugMode
      ? "DEV mode is ON. Unsafe 20-60Hz controls are unlocked. First destructive arm uses a one-time joke gate; later arms show warning-only."
      : "Unlocks destructive 20-60Hz overclock controls. Use only for controlled testing.";
  }

  if (options.persist !== false) {
    localStorage.setItem(DEV_DEBUG_KEY, ui.devDebugMode ? "1" : "0");
  }
}

function setDevToolsStatus(text) {
  if (!el.devToolsStatus) return;
  el.devToolsStatus.value = String(text || "").trim() || "DEV tools idle.";
}

function normalizeMidiAction(action) {
  return String(action || "").trim().toLowerCase();
}

function formatMidiActionLabel(action) {
  const key = normalizeMidiAction(action);
  return MIDI_ACTION_LABELS[key] || key.replace(/_/g, " ").toUpperCase();
}

function resolveMidiActionsList(snapshot = null) {
  const raw = Array.isArray(snapshot?.actions) ? snapshot.actions : [];
  const actions = raw
    .map(item => normalizeMidiAction(item))
    .filter(Boolean);
  if (actions.length) return Array.from(new Set(actions));
  return [...MIDI_FALLBACK_ACTIONS];
}

function parseMidiPortIndex(value) {
  const raw = String(value ?? "").trim();
  if (!raw) return null;
  const parsed = Number(raw);
  if (!Number.isInteger(parsed) || parsed < 0) return null;
  return parsed;
}

function formatMidiBinding(binding = null) {
  if (!binding || typeof binding !== "object") return "unbound";
  const type = String(binding.type || "").trim().toLowerCase() || "?";
  const number = Number(binding.number);
  const channel = Number(binding.channel);
  const minValue = Number(binding.minValue);
  const channelLabel = Number.isInteger(channel) && channel >= 0
    ? `ch${channel + 1}`
    : "any";
  const minLabel = Number.isFinite(minValue) ? `min${Math.round(minValue)}` : "min?";
  return `${type.toUpperCase()} #${Number.isFinite(number) ? Math.round(number) : "?"} ${channelLabel} ${minLabel}`;
}

function setMidiTabForced(next, options = {}) {
  ui.midiTabForced = Boolean(next);
  if (options.persist !== false) {
    if (ui.midiTabForced) localStorage.setItem(MIDI_TAB_FORCE_KEY, "1");
    else localStorage.removeItem(MIDI_TAB_FORCE_KEY);
  }
}

function applyMidiTabVisibility(options = {}) {
  const preserveTab = options.preserveTab !== false;
  const showMidiTab = Boolean(ui.midiDetected || ui.midiTabForced);

  if (el.midiTabBtn) {
    el.midiTabBtn.classList.toggle("hidden", !showMidiTab);
  }
  if (el.midiTabPage) {
    el.midiTabPage.classList.toggle("hidden", !showMidiTab);
  }
  if (el.systemStartTab) {
    const midiStartOption = el.systemStartTab.querySelector('option[value="midi"]');
    if (midiStartOption) midiStartOption.disabled = !showMidiTab;
    if (!showMidiTab && normalizeStartTabPreference(ui.startTabPreference) === "midi") {
      ui.startTabPreference = "live";
      localStorage.setItem(UI_START_TAB_KEY, ui.startTabPreference);
      if (el.systemStartTab.value === "midi") el.systemStartTab.value = "live";
      renderSystemSettingsStatus();
    }
  }

  if (el.midiTabToggleBtn) {
    const detected = Boolean(ui.midiDetected);
    const forced = Boolean(ui.midiTabForced);
    if (detected) {
      el.midiTabToggleBtn.textContent = "MIDI TAB AUTO (DEVICE DETECTED)";
      el.midiTabToggleBtn.disabled = true;
    } else {
      el.midiTabToggleBtn.disabled = false;
      el.midiTabToggleBtn.textContent = forced ? "MIDI TAB ON (NO DEVICE)" : "MIDI TAB OFF (NO DEVICE)";
    }
  }

  if (el.midiCogStatus) {
    if (ui.midiDetected) {
      el.midiCogStatus.value = "MIDI input detected. MIDI tab is always visible.";
    } else if (ui.midiTabForced) {
      el.midiCogStatus.value = "No MIDI input detected. MIDI tab forced ON from settings.";
    } else {
      el.midiCogStatus.value = "No MIDI input detected. MIDI tab hidden until detected.";
    }
  }

  if (!showMidiTab && ui.activeTab === "midi" && preserveTab) {
    showTab("live");
  }
}

function renderMidiActionsOptions(actions = []) {
  const list = Array.isArray(actions) && actions.length ? actions : [...MIDI_FALLBACK_ACTIONS];
  const normalizedList = Array.from(new Set(list.map(item => normalizeMidiAction(item)).filter(Boolean)));
  const targets = [el.midiLearnAction, el.midiBindingAction];

  targets.forEach(select => {
    if (!select) return;
    const current = normalizeMidiAction(select.value);
    select.innerHTML = "";
    normalizedList.forEach(action => {
      const option = document.createElement("option");
      option.value = action;
      option.textContent = formatMidiActionLabel(action);
      select.appendChild(option);
    });
    if (current && normalizedList.includes(current)) select.value = current;
    else if (normalizedList.length) select.value = normalizedList[0];
  });

  ui.midiActions = normalizedList;
}

function buildMidiBindingsDump(snapshot = null) {
  if (!snapshot || typeof snapshot !== "object") return "MIDI snapshot unavailable.";
  const config = snapshot.config && typeof snapshot.config === "object" ? snapshot.config : {};
  const bindings = config.bindings && typeof config.bindings === "object" ? config.bindings : {};
  const actions = resolveMidiActionsList(snapshot);

  const lines = [];
  lines.push(`moduleAvailable: ${Boolean(snapshot.moduleAvailable)}`);
  lines.push(`connected: ${Boolean(snapshot.connected)}`);
  lines.push(`portCount: ${Number(snapshot.portCount || 0)}`);
  lines.push(`activePort: ${String(snapshot.activePortName || "none")}`);
  lines.push(`enabled: ${Boolean(config.enabled)}`);
  lines.push(`deviceIndex: ${config.deviceIndex === null || config.deviceIndex === undefined ? "auto" : config.deviceIndex}`);
  lines.push(`deviceMatch: ${String(config.deviceMatch || "") || "<empty>"}`);
  lines.push(`velocityThreshold: ${Number(config.velocityThreshold || 0)}`);
  lines.push("");
  lines.push("bindings:");
  actions.forEach(action => {
    lines.push(`- ${action}: ${formatMidiBinding(bindings[action])}`);
  });
  return lines.join("\n");
}

function formatMidiEvent(snapshot = null) {
  const msg = snapshot?.lastMessage;
  if (!msg || typeof msg !== "object") return "none";
  const type = String(msg.type || "?").toUpperCase();
  const channel = Number(msg.channel);
  const number = Number(msg.number);
  const value = Number(msg.value);
  const stamp = msg.at ? new Date(msg.at).toLocaleTimeString() : "";
  const channelLabel = Number.isInteger(channel) && channel >= 0 ? `ch${channel + 1}` : "any";
  return `${type} #${Number.isFinite(number) ? Math.round(number) : "?"} ${channelLabel} v${Number.isFinite(value) ? Math.round(value) : "?"}${stamp ? ` @ ${stamp}` : ""}`;
}

function populateMidiPorts(snapshot = null) {
  if (!el.midiPortSelect) return;
  const ports = Array.isArray(snapshot?.ports) ? snapshot.ports : [];
  const config = snapshot?.config && typeof snapshot.config === "object" ? snapshot.config : {};
  const selectedIndex = parseMidiPortIndex(config.deviceIndex);

  el.midiPortSelect.innerHTML = "";
  const autoOption = document.createElement("option");
  autoOption.value = "";
  autoOption.textContent = "AUTO SELECT";
  el.midiPortSelect.appendChild(autoOption);

  ports.forEach(port => {
    const idx = parseMidiPortIndex(port?.index);
    if (idx === null) return;
    const option = document.createElement("option");
    option.value = String(idx);
    option.textContent = `${idx} | ${String(port?.name || `port ${idx}`)}`;
    el.midiPortSelect.appendChild(option);
  });

  el.midiPortSelect.value = selectedIndex === null ? "" : String(selectedIndex);
}

function applyMidiBindingEditor(snapshot = null) {
  const config = snapshot?.config && typeof snapshot.config === "object" ? snapshot.config : {};
  const bindings = config.bindings && typeof config.bindings === "object" ? config.bindings : {};
  const action = normalizeMidiAction(el.midiBindingAction?.value || el.midiLearnAction?.value || "");
  const binding = bindings[action];
  const suggestedCc = action.includes("overclock") || action.includes("meta_auto");
  const fallbackType = suggestedCc ? "cc" : "note";
  const fallbackNumber = suggestedCc ? 64 : 36;
  const fallbackMin = suggestedCc ? 64 : 1;

  if (el.midiBindingType) el.midiBindingType.value = String(binding?.type || fallbackType).toLowerCase() === "cc" ? "cc" : "note";
  if (el.midiBindingNumber) el.midiBindingNumber.value = Number.isFinite(Number(binding?.number)) ? String(Number(binding.number)) : String(fallbackNumber);
  if (el.midiBindingChannel) {
    el.midiBindingChannel.value = Number.isInteger(Number(binding?.channel))
      ? String(Number(binding.channel) + 1)
      : "";
  }
  if (el.midiBindingMinValue) {
    const defaultMin = (String(el.midiBindingType?.value || fallbackType).toLowerCase() === "cc") ? 64 : fallbackMin;
    el.midiBindingMinValue.value = Number.isFinite(Number(binding?.minValue))
      ? String(Number(binding.minValue))
      : String(defaultMin);
  }
}

function applyMidiSnapshot(snapshot = null) {
  if (!snapshot || typeof snapshot !== "object") return;
  ui.midiSnapshot = snapshot;
  ui.midiConfigLoaded = true;

  const hasPorts = Number(snapshot.portCount || 0) > 0;
  ui.midiDetected = Boolean(snapshot.moduleAvailable && (snapshot.connected || hasPorts));

  if (el.midiModuleStatus) {
    el.midiModuleStatus.value = snapshot.moduleAvailable
      ? "module ready"
      : `module unavailable${snapshot.moduleError ? `: ${snapshot.moduleError}` : ""}`;
  }
  if (el.midiRuntimeStatus) {
    el.midiRuntimeStatus.value = snapshot.connected
      ? "listening"
      : (snapshot.config?.enabled === false ? "disabled" : "not connected");
  }
  if (el.midiActivePort) {
    const portLabel = snapshot.connected
      ? `${snapshot.activePortIndex ?? "-"} | ${snapshot.activePortName || "unknown"}`
      : "none";
    el.midiActivePort.value = portLabel;
  }
  if (el.midiLearnStatus) {
    const learnTarget = normalizeMidiAction(snapshot.learn?.target);
    if (learnTarget) {
      const expire = Number(snapshot.learn?.expiresAt || 0);
      const ttlSec = expire > Date.now() ? Math.max(1, Math.round((expire - Date.now()) / 1000)) : 0;
      el.midiLearnStatus.value = `learning ${formatMidiActionLabel(learnTarget)} (${ttlSec}s)`;
    } else {
      el.midiLearnStatus.value = "idle";
    }
  }
  if (el.midiLastEvent) {
    el.midiLastEvent.value = formatMidiEvent(snapshot);
  }
  if (el.midiLastAction) {
    el.midiLastAction.value = String(snapshot.lastAction || "none");
  }
  if (el.midiEnabled) {
    el.midiEnabled.value = snapshot.config?.enabled === false ? "false" : "true";
  }
  if (el.midiVelocityThreshold) {
    const threshold = Number(snapshot.config?.velocityThreshold);
    el.midiVelocityThreshold.value = Number.isFinite(threshold)
      ? String(Math.max(0, Math.min(127, Math.round(threshold))))
      : "1";
  }
  if (el.midiDeviceMatch) {
    el.midiDeviceMatch.value = String(snapshot.config?.deviceMatch || "");
  }

  populateMidiPorts(snapshot);
  renderMidiActionsOptions(resolveMidiActionsList(snapshot));
  applyMidiBindingEditor(snapshot);
  if (el.midiBindingsDump) {
    el.midiBindingsDump.value = buildMidiBindingsDump(snapshot);
  }
  applyMidiTabVisibility();
}

function collectMidiConfigPatch() {
  return {
    enabled: String(el.midiEnabled?.value || "true").toLowerCase() !== "false",
    deviceIndex: parseMidiPortIndex(el.midiPortSelect?.value),
    deviceMatch: String(el.midiDeviceMatch?.value || "").trim(),
    velocityThreshold: Math.max(0, Math.min(127, Number(el.midiVelocityThreshold?.value || 1) || 1))
  };
}

function collectMidiBindingPatch() {
  const type = String(el.midiBindingType?.value || "note").trim().toLowerCase() === "cc" ? "cc" : "note";
  const number = Math.max(0, Math.min(127, Math.round(Number(el.midiBindingNumber?.value || 0) || 0)));
  const channelRaw = String(el.midiBindingChannel?.value || "").trim();
  const channel = channelRaw
    ? Math.max(0, Math.min(15, Math.round(Number(channelRaw) || 1) - 1))
    : null;
  const minFallback = type === "cc" ? 64 : 1;
  const minValue = Math.max(0, Math.min(127, Math.round(Number(el.midiBindingMinValue?.value || minFallback) || minFallback)));

  return { type, number, channel, minValue };
}

async function loadMidiStatus(options = {}) {
  const refresh = options.refresh === true;
  if (refresh) {
    const response = await postJson("/midi/refresh", {});
    if (!response.ok || !response.data) return false;
    applyMidiSnapshot(response.data);
    return true;
  }

  const snapshot = await getJson("/midi/status");
  if (!snapshot || snapshot.ok === false) return false;
  applyMidiSnapshot(snapshot);
  return true;
}

function toSafeJsonString(payload, fallback = "") {
  try {
    const seen = new WeakSet();
    return JSON.stringify(payload, (key, value) => {
      if (value && typeof value === "object") {
        if (seen.has(value)) return "[Circular]";
        seen.add(value);
      }
      return value;
    }, 2);
  } catch {
    return String(fallback || "");
  }
}

function setDevToolsDump(payload, label = "") {
  if (!el.devToolsDump) return;
  const header = String(label || "").trim();
  const body = typeof payload === "string"
    ? payload
    : toSafeJsonString(payload, "[unserializable payload]");
  const full = header ? `${header}\n${body}` : body;
  el.devToolsDump.value = full.length > 50000 ? `${full.slice(0, 50000)}\n...[truncated]` : full;
}

async function runDevToolsProbe(label, path) {
  const name = String(label || "DEV TOOL").trim();
  setDevToolsStatus(`${name}: querying...`);
  const snapshot = await getJson(path);
  if (!snapshot) {
    setDevToolsStatus(`${name}: failed`);
    setBadge(el.health, "bad", `${name} FAIL`);
    return false;
  }
  setDevToolsStatus(`${name}: ok @ ${new Date().toLocaleTimeString()}`);
  setDevToolsDump(snapshot, `${name} ${path}`);
  setBadge(el.health, "ok", `${name} OK`);
  return true;
}

function closeDevOverclockAckGate(confirmed) {
  if (devOcAckKeydownHandler) {
    document.removeEventListener("keydown", devOcAckKeydownHandler);
    devOcAckKeydownHandler = null;
  }
  if (el.devOcAckGate) {
    el.devOcAckGate.classList.add("hidden");
    el.devOcAckGate.setAttribute("aria-hidden", "true");
  }
  if (el.devOcAckInput) el.devOcAckInput.value = "";
  if (devOcAckResolver) {
    const resolve = devOcAckResolver;
    devOcAckResolver = null;
    resolve(Boolean(confirmed));
  }
}

function openDevOverclockAckGate(hz) {
  if (!el.devOcAckGate || !el.devOcAckInput || !el.devOcAckPhrase) {
    return Promise.resolve(false);
  }
  if (devOcAckResolver) {
    devOcAckResolver(false);
    devOcAckResolver = null;
  }

  el.devOcAckPhrase.value = DEV_OVERCLOCK_COMICAL_TEXT;
  el.devOcAckInput.value = "";
  el.devOcAckGate.classList.remove("hidden");
  el.devOcAckGate.setAttribute("aria-hidden", "false");

  return new Promise(resolve => {
    devOcAckResolver = resolve;
    devOcAckKeydownHandler = ev => {
      if (!el.devOcAckGate || el.devOcAckGate.classList.contains("hidden")) {
        if (devOcAckKeydownHandler) {
          document.removeEventListener("keydown", devOcAckKeydownHandler);
          devOcAckKeydownHandler = null;
        }
        return;
      }
      if (ev.key === "Escape") {
        ev.preventDefault();
        closeDevOverclockAckGate(false);
        return;
      }
      if (ev.key === "Enter") {
        ev.preventDefault();
        const typed = String(el.devOcAckInput.value || "").trim();
        if (!typed) {
          closeDevOverclockAckGate(false);
          return;
        }
        closeDevOverclockAckGate(typed.toUpperCase() === DEV_OVERCLOCK_COMICAL_TEXT);
      }
    };
    document.addEventListener("keydown", devOcAckKeydownHandler);

    setTimeout(() => {
      if (el.devOcAckInput) el.devOcAckInput.focus();
    }, 0);
  });
}

function confirmDevDebugEnableOnce() {
  if (ui.devDebugWarned) return true;
  const proceed = window.confirm(
    "DEV/DEBUG MODE unlocks destructive 20-60Hz overclock.\n\n" +
    "This warning appears once. Continue?"
  );
  if (!proceed) return false;
  ui.devDebugWarned = true;
  localStorage.setItem(DEV_DEBUG_WARN_ONCE_KEY, "1");
  return true;
}

function confirmUnsafeSensitiveLogEnable() {
  const proceed = window.confirm(
    "DANGER: This will disable server log redaction and expose sensitive values in plain text logs.\n\n" +
    "Exposed data may include Hue usernames/client keys, bridge ids, entertainment area ids, bearer/access tokens, auth headers/cookies, and private IP/host data.\n\n" +
    "Logs can be copied, indexed, uploaded, or retained by other tools.\n\n" +
    "Continue?"
  );
  if (!proceed) return { ok: false, ack: "" };

  const typed = String(
    window.prompt(
      `Type exactly ${UNSAFE_LOG_ACK_PHRASE} to confirm you understand the risk:`,
      ""
    ) || ""
  ).trim();

  if (typed !== UNSAFE_LOG_ACK_PHRASE) {
    return { ok: false, ack: "" };
  }

  return { ok: true, ack: typed };
}

function normalizeModUiId(value) {
  return String(value || "").trim();
}

function normalizeModUiCatalogEntries(entries = []) {
  const seen = new Set();
  const out = [];
  for (const item of (Array.isArray(entries) ? entries : [])) {
    const id = normalizeModUiId(item?.id);
    if (!id || seen.has(id)) continue;
    seen.add(id);

    const title = String(item?.title || item?.name || id).trim() || id;
    const loaded = Boolean(item?.loaded);
    const enabled = Boolean(item?.enabled);
    const entry = String(item?.entry || "").trim();
    const url = loaded ? (String(item?.url || `/mods-ui/${encodeURIComponent(id)}/`).trim()) : "";

    out.push({
      id,
      name: String(item?.name || id).trim() || id,
      version: String(item?.version || "").trim(),
      title,
      entry,
      enabled,
      loaded,
      url
    });
  }
  return out;
}

function formatModUiTabLabel(item = {}) {
  const raw = String(item?.title || item?.name || item?.id || "MOD UI").trim();
  if (raw.length <= 20) return raw.toUpperCase();
  return `${raw.slice(0, 17).trimEnd()}...`.toUpperCase();
}

function syncDynamicModUiTabButtons() {
  if (!el.tabsBar) return;
  const selectedId = normalizeModUiId(ui.modUiSelectedId);
  const modsTabActive = ui.activeTab === "mods";
  const dynamicTabs = Array.from(el.tabsBar.querySelectorAll(".modUiDynamicTab"));
  dynamicTabs.forEach(btn => {
    const id = normalizeModUiId(btn.dataset.modUiTabId);
    btn.classList.toggle("active", modsTabActive && id === selectedId);
  });
}

function rebuildDynamicModUiTabs() {
  if (!el.tabsBar) return;
  Array.from(el.tabsBar.querySelectorAll(".modUiDynamicTab")).forEach(node => node.remove());

  for (const item of ui.modUiCatalog) {
    const id = normalizeModUiId(item?.id);
    if (!id || !item.loaded) continue;
    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = "tabBtn modUiDynamicTab";
    btn.dataset.modUiTabId = id;
    btn.textContent = formatModUiTabLabel(item);
    const route = `/mods-ui/${encodeURIComponent(id)}/`;
    btn.title = `Open ${item.title || id} UI (${route})`;
    el.tabsBar.appendChild(btn);
  }

  syncDynamicModUiTabButtons();
}

function buildModUiCatalogFromModsSnapshot(snapshot) {
  const mods = Array.isArray(snapshot?.mods) ? snapshot.mods : [];
  return normalizeModUiCatalogEntries(mods
    .filter(mod => mod && mod.ui)
    .map(mod => ({
      id: mod.id,
      name: mod.name,
      version: mod.version,
      enabled: Boolean(mod.enabled),
      loaded: Boolean(mod.loaded),
      title: mod.ui?.title || mod.name || mod.id,
      entry: mod.ui?.entry || "",
      url: mod.loaded ? `/mods-ui/${encodeURIComponent(String(mod.id || "").trim())}/` : ""
    })));
}

function getSelectedModUiDescriptor() {
  const selectedId = normalizeModUiId(ui.modUiSelectedId);
  if (!selectedId) return null;
  return ui.modUiCatalog.find(item => item.id === selectedId) || null;
}

function buildModUiFrameUrl(descriptor, options = {}) {
  const baseUrl = String(descriptor?.url || "").trim();
  if (!baseUrl) return "";
  const descriptorId = normalizeModUiId(descriptor?.id);
  const forceReload = options.forceReload === true;
  if (!forceReload && ui.modUiLastUrl && ui.modUiLastId === descriptorId) {
    return ui.modUiLastUrl;
  }
  const ts = Date.now();
  const joiner = baseUrl.includes("?") ? "&" : "?";
  return `${baseUrl}${joiner}host=modui&ts=${ts}`;
}

function renderModUiFrame(options = {}) {
  const frame = el.modUiFrame;
  const frameWrap = el.modUiFrameWrap;
  const empty = el.modUiEmpty;
  const status = el.modUiStatus;

  const descriptor = getSelectedModUiDescriptor();
  if (!descriptor) {
    if (frame) frame.src = "about:blank";
    if (frameWrap) frameWrap.classList.add("hidden");
    if (empty) {
      empty.classList.remove("hidden");
      empty.textContent = "No mod UI packages discovered. Add a UI HTML file in a mod folder and reload mods.";
    }
    if (status) status.value = "No mod UI packages discovered.";
    if (el.modUiOpenBtn) el.modUiOpenBtn.disabled = true;
    if (el.modUiReloadBtn) el.modUiReloadBtn.disabled = true;
    ui.modUiLastId = "";
    ui.modUiLastUrl = "";
    syncDynamicModUiTabButtons();
    return;
  }

  if (!descriptor.loaded || !descriptor.url) {
    if (frame) frame.src = "about:blank";
    if (frameWrap) frameWrap.classList.add("hidden");
    if (empty) {
      empty.classList.remove("hidden");
      empty.textContent = `Selected mod UI (${descriptor.id}) is offline. Enable the mod and click APPLY HOTSWAP to mount its UI.`;
    }
    if (status) status.value = `${descriptor.id} UI is offline (mod not loaded).`;
    if (el.modUiOpenBtn) el.modUiOpenBtn.disabled = true;
    if (el.modUiReloadBtn) el.modUiReloadBtn.disabled = true;
    ui.modUiLastId = "";
    ui.modUiLastUrl = "";
    syncDynamicModUiTabButtons();
    return;
  }

  const nextUrl = buildModUiFrameUrl(descriptor, options);
  if (frame && nextUrl && (
    options.forceReload === true ||
    ui.modUiLastId !== normalizeModUiId(descriptor.id) ||
    ui.modUiLastUrl !== nextUrl
  )) {
    frame.src = withBase(nextUrl);
    ui.modUiLastId = normalizeModUiId(descriptor.id);
    ui.modUiLastUrl = nextUrl;
    ui.modUiLoadedAt = Date.now();
  }

  if (frameWrap) frameWrap.classList.remove("hidden");
  if (empty) empty.classList.add("hidden");
  if (status) status.value = `${descriptor.title} (${descriptor.id}) loaded`;
  if (el.modUiOpenBtn) el.modUiOpenBtn.disabled = false;
  if (el.modUiReloadBtn) el.modUiReloadBtn.disabled = false;
  syncDynamicModUiTabButtons();
}

function applyModUiCatalog(catalog = [], options = {}) {
  ui.modUiCatalog = normalizeModUiCatalogEntries(catalog);

  const previousSelectedId = normalizeModUiId(
    options.selectedId !== undefined ? options.selectedId : ui.modUiSelectedId
  );
  const hasPrevious = previousSelectedId && ui.modUiCatalog.some(item => item.id === previousSelectedId);
  const firstLoaded = ui.modUiCatalog.find(item => item.loaded);
  const nextSelectedId = hasPrevious
    ? previousSelectedId
    : normalizeModUiId(firstLoaded?.id || ui.modUiCatalog[0]?.id || "");

  ui.modUiSelectedId = nextSelectedId;
  if (options.persist !== false) {
    if (nextSelectedId) localStorage.setItem(MOD_UI_SELECTED_KEY, nextSelectedId);
    else localStorage.removeItem(MOD_UI_SELECTED_KEY);
  }

  if (el.modUiSelect) {
    el.modUiSelect.replaceChildren();
    const placeholder = document.createElement("option");
    placeholder.value = "";
    placeholder.textContent = ui.modUiCatalog.length
      ? "select mod UI"
      : "no mod UI packages discovered";
    el.modUiSelect.appendChild(placeholder);

    for (const item of ui.modUiCatalog) {
      const opt = document.createElement("option");
      opt.value = item.id;
      const stateWord = item.loaded ? "LIVE" : "OFFLINE";
      opt.textContent = `${item.title} (${item.id}) [${stateWord}]`;
      opt.disabled = !item.loaded;
      el.modUiSelect.appendChild(opt);
    }
    el.modUiSelect.value = nextSelectedId || "";
  }

  rebuildDynamicModUiTabs();
  renderModUiFrame({ forceReload: options.forceReload === true });
}

function syncModUiCatalogFromModsSnapshot(snapshot, options = {}) {
  const catalog = buildModUiCatalogFromModsSnapshot(snapshot);
  applyModUiCatalog(catalog, options);
}

async function refreshModUiCatalog(options = {}) {
  const preferRemote = options.preferRemote !== false;
  if (preferRemote) {
    const remote = await getJson("/mods/ui/catalog");
    if (remote?.ok && Array.isArray(remote.mods)) {
      applyModUiCatalog(remote.mods, options);
      return true;
    }
  }
  syncModUiCatalogFromModsSnapshot(ui.modsSnapshot || {}, options);
  return Array.isArray(ui.modUiCatalog);
}

function syncThemeUi() {
  const accent = normalizeHexColor(ui.themeConfig?.accent, THEME_PRESETS[DEFAULT_THEME_NAME].accent);
  const btnBg = normalizeHexColor(ui.themeConfig?.btnBg, THEME_PRESETS[DEFAULT_THEME_NAME].btnBg);
  if (el.themeLogoColor) el.themeLogoColor.value = accent;
  if (el.themeButtonColor) el.themeButtonColor.value = btnBg;

  themePresetButtons.forEach(btn => {
    const name = String(btn.dataset.themePreset || "").trim().toLowerCase();
    btn.classList.toggle("active", name === ui.themeName);
  });
}

function applyThemePreset(name, options = {}) {
  ui.themeName = String(name || DEFAULT_THEME_NAME).trim().toLowerCase();
  if (!THEME_PRESETS[ui.themeName]) ui.themeName = DEFAULT_THEME_NAME;
  applyThemeConfig(getThemePreset(ui.themeName), options);
  syncThemeUi();
}

function toggleThemePanel(open) {
  const nextOpen = open === undefined
    ? el.themePanel.classList.contains("hidden")
    : Boolean(open);
  el.themePanel.classList.toggle("hidden", !nextOpen);
}

function initThemeSettings() {
  let loaded = null;
  try {
    loaded = JSON.parse(localStorage.getItem(THEME_STORAGE_KEY) || "null");
  } catch {}

  const loadedNameRaw = String(loaded?.name || "").trim().toLowerCase();
  const hasStoredTheme = loaded && typeof loaded === "object";
  const hasValidStoredThemeName = Boolean(THEME_PRESETS[loadedNameRaw]);
  const loadedName = hasValidStoredThemeName ? loadedNameRaw : DEFAULT_THEME_NAME;
  ui.themeName = loadedName;
  const preset = getThemePreset(ui.themeName);
  const custom = normalizeThemeCustomConfig(loaded?.custom, preset);
  const shouldPersistTheme =
    !hasStoredTheme ||
    !hasValidStoredThemeName;

  applyThemeConfig(
    {
      ...preset,
      ...custom
    },
    { persist: shouldPersistTheme }
  );
  syncThemeUi();
  setDevDebugMode(ui.devDebugMode, { persist: false });
  setDevToolsStatus(ui.devDebugMode ? "DEV tools idle." : "DEV tools hidden. Enable DEV DEBUG to use probes.");
  applyMidiTabVisibility({ preserveTab: false });

  themePresetButtons.forEach(btn => {
    btn.onclick = () => {
      applyThemePreset(btn.dataset.themePreset || DEFAULT_THEME_NAME);
    };
  });

  if (el.themeLogoColor) {
    el.themeLogoColor.oninput = () => {
      applyThemeConfig({ ...ui.themeConfig, accent: el.themeLogoColor.value });
      syncThemeUi();
    };
  }
  if (el.themeButtonColor) {
    el.themeButtonColor.oninput = () => {
      applyThemeConfig({ ...ui.themeConfig, btnBg: el.themeButtonColor.value });
      syncThemeUi();
    };
  }
  if (el.themeResetBtn) {
    el.themeResetBtn.onclick = () => {
      applyThemePreset(DEFAULT_THEME_NAME);
    };
  }
  if (el.devDebugToggleBtn) {
    el.devDebugToggleBtn.onclick = () => {
      const next = !ui.devDebugMode;
      if (next) {
        if (!confirmDevDebugEnableOnce()) {
          setBadge(el.health, "warn", "DEV DEBUG ENABLE CANCELED");
          return;
        }
      }

      setDevDebugMode(next);
      setDevToolsStatus(next ? "DEV tools idle." : "DEV tools hidden. Enable DEV DEBUG to use probes.");
      setBadge(el.health, next ? "warn" : "ok", next ? "DEV DEBUG ON" : "DEV DEBUG OFF");
      sync();
    };
  }
  if (el.midiTabToggleBtn) {
    el.midiTabToggleBtn.onclick = () => {
      if (ui.midiDetected) {
        setBadge(el.health, "ok", "MIDI DETECTED: TAB AUTO-VISIBLE");
        return;
      }
      setMidiTabForced(!ui.midiTabForced);
      applyMidiTabVisibility();
      setBadge(el.health, "ok", ui.midiTabForced ? "MIDI TAB FORCED ON" : "MIDI TAB AUTO-HIDDEN");
    };
  }
  if (el.devToolRuntimeBtn) {
    el.devToolRuntimeBtn.onclick = () => runDevToolsProbe("RUNTIME", "/mods/runtime");
  }
  if (el.devToolConnectivityBtn) {
    el.devToolConnectivityBtn.onclick = () => runDevToolsProbe("CONNECTIVITY", "/fixtures/connectivity");
  }
  if (el.devToolHooksBtn) {
    el.devToolHooksBtn.onclick = () => runDevToolsProbe("MOD HOOKS", "/mods/hooks");
  }
  if (el.devToolTiersBtn) {
    el.devToolTiersBtn.onclick = () => runDevToolsProbe("OC TIERS", "/rave/overclock/tiers");
  }
  if (el.devOcAckCancelBtn) {
    el.devOcAckCancelBtn.onclick = () => closeDevOverclockAckGate(false);
  }
  if (el.devOcAckConfirmBtn) {
    el.devOcAckConfirmBtn.onclick = () => {
      const typed = String(el.devOcAckInput?.value || "").trim();
      if (!typed) {
        closeDevOverclockAckGate(false);
        return;
      }
      closeDevOverclockAckGate(typed.toUpperCase() === DEV_OVERCLOCK_COMICAL_TEXT);
    };
  }
  if (el.devOcAckGate) {
    el.devOcAckGate.onclick = ev => {
      if (ev.target === el.devOcAckGate) {
        closeDevOverclockAckGate(false);
      }
    };
  }
  if (el.themeCloseBtn) {
    el.themeCloseBtn.onclick = () => toggleThemePanel(false);
  }
  if (el.themeCogBtn) {
    el.themeCogBtn.onclick = () => toggleThemePanel();
  }

  document.addEventListener("click", ev => {
    if (!el.themePanel || el.themePanel.classList.contains("hidden")) return;
    const target = ev.target;
    const clickedInsidePanel = el.themePanel.contains(target);
    const clickedCog = el.themeCogBtn && (target === el.themeCogBtn || el.themeCogBtn.contains(target));
    if (!clickedInsidePanel && !clickedCog) {
      toggleThemePanel(false);
    }
  });
}

function setObsDockCompact(compact, options = {}) {
  ui.obsDockCompact = Boolean(compact);
  document.body.classList.toggle("obsDockCompact", ui.obsDockCompact);
  if (el.obsDockCompactBtn) {
    el.obsDockCompactBtn.textContent = ui.obsDockCompact ? "DK+" : "DK";
    el.obsDockCompactBtn.title = ui.obsDockCompact
      ? "Switch to expanded OBS dock layout"
      : "Switch to compact OBS dock layout";
  }
  if (options.persist !== false) {
    localStorage.setItem(OBS_DOCK_COMPACT_KEY, ui.obsDockCompact ? "1" : "0");
  }
}

function initObsDockMode() {
  if (!ui.obsDockMode) return;
  document.body.classList.add("obsDockMode");
  if (el.obsDockCompactBtn) {
    el.obsDockCompactBtn.classList.remove("hidden");
    el.obsDockCompactBtn.onclick = () => {
      setObsDockCompact(!ui.obsDockCompact);
    };
  }
  setObsDockCompact(ui.obsDockCompact, { persist: false });
}

async function api(path) {
  try {
    const res = await fetch(withBase(path), { method: "POST" });
    return res.ok;
  } catch {
    return false;
  }
}

async function getJson(path) {
  try {
    const res = await fetch(withBase(path), { cache: "no-store" });
    if (!res.ok) return null;
    return await res.json();
  } catch {
    return null;
  }
}

async function postJson(path, body) {
  try {
    const res = await fetch(withBase(path), {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body || {})
    });

    const text = await res.text();
    let json = null;
    try { json = text ? JSON.parse(text) : null; } catch {}

    return { ok: res.ok, status: res.status, data: json };
  } catch {
    return { ok: false, status: 0, data: null };
  }
}

async function deleteJson(path) {
  try {
    const res = await fetch(withBase(path), { method: "DELETE" });
    const text = await res.text();
    let json = null;
    try { json = text ? JSON.parse(text) : null; } catch {}
    return { ok: res.ok, status: res.status, data: json };
  } catch {
    return { ok: false, status: 0, data: null };
  }
}

function normalizeApiBaseInput(raw) {
  const value = String(raw || "").trim();
  if (!value) return "";
  let candidate = value;
  // Backward-compatible: allow legacy "host:port" values by assuming http.
  if (!/^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(candidate)) {
    candidate = `http://${candidate}`;
  }
  let parsed = null;
  try {
    parsed = new URL(candidate);
  } catch {
    return "";
  }
  if (parsed.protocol !== "http:" && parsed.protocol !== "https:") {
    return "";
  }
  parsed.hash = "";
  parsed.search = "";
  return parsed.toString().replace(/\/+$/, "");
}

function applyApiBaseUi() {
  el.apiBaseInput.value = apiBase || "";
}

function setApiBase(nextBase, options = {}) {
  const normalized = normalizeApiBaseInput(nextBase);
  apiBase = normalized;

  if (options.persist !== false) {
    if (normalized) {
      localStorage.setItem("rave_api_base", normalized);
    } else {
      localStorage.removeItem("rave_api_base");
    }
  }

  applyApiBaseUi();
}

const START_TAB_VALUES = new Set(["live", "fixtures", "audio", "midi", "custom", "mods", "system"]);

function normalizeStartTabPreference(value) {
  const raw = String(value || "").trim().toLowerCase();
  return START_TAB_VALUES.has(raw) ? raw : "live";
}

function normalizeHueTransportPreference(value) {
  return String(value || "").trim().toLowerCase() === "rest" ? "rest" : "auto";
}

function shouldConfirmDangerousAction() {
  return ui.confirmDangerousActions !== false;
}

function updatePollIndicator() {
  if (!el.pollMs) return;
  el.pollMs.textContent = ui.pollPaused ? "PAUSED" : String(pollIntervalMs);
}

function renderSystemSettingsStatus() {
  if (!el.systemSettingsStatus) return;
  const startTab = normalizeStartTabPreference(ui.startTabPreference).toUpperCase();
  const confirms = ui.confirmDangerousActions ? "CONFIRM ON" : "CONFIRM OFF";
  const polling = ui.pollPaused ? "POLL PAUSED" : "POLL LIVE";
  const browserLaunch = ui.serverAutoLaunchBrowser ? "BROWSER AUTO ON" : "BROWSER AUTO OFF";
  const hueTransport = normalizeHueTransportPreference(ui.serverHueTransportPreference) === "rest"
    ? "HUE REST ONLY"
    : "HUE AUTO";
  const logsMode = ui.serverUnsafeSensitiveLogs ? "LOG REDACTION OFF (DEV RISK)" : "LOG REDACTION ON";
  el.systemSettingsStatus.value = `${startTab} | ${confirms} | ${polling} | ${browserLaunch} | ${hueTransport} | ${logsMode}`;
}

function applySystemSettingsUi() {
  if (el.systemStartTab) {
    el.systemStartTab.value = normalizeStartTabPreference(ui.startTabPreference);
  }
  if (el.systemConfirmActions) {
    el.systemConfirmActions.value = ui.confirmDangerousActions ? "true" : "false";
  }
  if (el.systemPollingMode) {
    el.systemPollingMode.value = ui.pollPaused ? "paused" : "live";
  }
  if (el.systemAutoLaunchBrowser) {
    el.systemAutoLaunchBrowser.value = ui.serverAutoLaunchBrowser ? "true" : "false";
  }
  if (el.systemHueTransportPreference) {
    el.systemHueTransportPreference.value = normalizeHueTransportPreference(ui.serverHueTransportPreference);
  }
  if (el.systemUnsafeSensitiveLogs) {
    el.systemUnsafeSensitiveLogs.value = ui.serverUnsafeSensitiveLogs ? "true" : "false";
  }
  updatePollIndicator();
  if (ui.pollPaused && el.netBadge) {
    setBadge(el.netBadge, "warn", "POLL PAUSED");
  }
  renderSystemSettingsStatus();
}

function saveSystemSettingsFromUi() {
  const previousPaused = ui.pollPaused;
  ui.startTabPreference = normalizeStartTabPreference(el.systemStartTab?.value || ui.startTabPreference);
  ui.confirmDangerousActions = String(el.systemConfirmActions?.value || "true").trim().toLowerCase() !== "false";
  ui.pollPaused = String(el.systemPollingMode?.value || "live").trim().toLowerCase() === "paused";
  ui.serverAutoLaunchBrowser = String(el.systemAutoLaunchBrowser?.value || "true").trim().toLowerCase() !== "false";
  ui.serverHueTransportPreference = normalizeHueTransportPreference(el.systemHueTransportPreference?.value || "auto");
  ui.serverUnsafeSensitiveLogs = String(el.systemUnsafeSensitiveLogs?.value || "false").trim().toLowerCase() === "true";

  localStorage.setItem(UI_START_TAB_KEY, ui.startTabPreference);
  localStorage.setItem(UI_CONFIRM_DANGER_KEY, ui.confirmDangerousActions ? "1" : "0");
  localStorage.setItem(UI_POLL_PAUSED_KEY, ui.pollPaused ? "1" : "0");
  applySystemSettingsUi();
  return { pollingChanged: previousPaused !== ui.pollPaused };
}

function resetSystemSettingsToDefaults() {
  ui.startTabPreference = "live";
  ui.confirmDangerousActions = true;
  ui.pollPaused = false;
  ui.serverAutoLaunchBrowser = true;
  ui.serverHueTransportPreference = "auto";
  ui.serverUnsafeSensitiveLogs = false;
  localStorage.removeItem(UI_START_TAB_KEY);
  localStorage.removeItem(UI_CONFIRM_DANGER_KEY);
  localStorage.removeItem(UI_POLL_PAUSED_KEY);
  applySystemSettingsUi();
}

async function loadSystemServerConfig() {
  const response = await getJson("/system/config");
  if (!response || response.ok !== true || !response.config) return false;
  ui.serverAutoLaunchBrowser = response.config.autoLaunchBrowser !== false;
  ui.serverHueTransportPreference = normalizeHueTransportPreference(response.config.hueTransportPreference);
  ui.serverUnsafeSensitiveLogs = response.config.unsafeExposeSensitiveLogs === true;
  ui.serverUnsafeSensitiveLogsBaseline = ui.serverUnsafeSensitiveLogs;
  applySystemSettingsUi();
  return true;
}

async function saveSystemServerSettingsFromUi() {
  const enablingUnsafeLogs = ui.serverUnsafeSensitiveLogs === true && ui.serverUnsafeSensitiveLogsBaseline !== true;
  let unsafeAck = "";
  if (enablingUnsafeLogs) {
    const ack = confirmUnsafeSensitiveLogEnable();
    if (!ack.ok) {
      ui.serverUnsafeSensitiveLogs = ui.serverUnsafeSensitiveLogsBaseline === true;
      applySystemSettingsUi();
      return { ok: false, error: "unsafe sensitive log mode enable cancelled" };
    }
    unsafeAck = ack.ack;
  }

  const payload = {
    autoLaunchBrowser: ui.serverAutoLaunchBrowser,
    hueTransportPreference: normalizeHueTransportPreference(ui.serverHueTransportPreference),
    unsafeExposeSensitiveLogs: ui.serverUnsafeSensitiveLogs
  };
  if (unsafeAck) payload.unsafeExposeSensitiveLogsAck = unsafeAck;
  const response = await postJson("/system/config", payload);
  if (!response.ok || response.data?.ok !== true) {
    ui.serverUnsafeSensitiveLogs = ui.serverUnsafeSensitiveLogsBaseline === true;
    applySystemSettingsUi();
    return {
      ok: false,
      error: response.data?.error || "server settings save failed"
    };
  }

  ui.serverAutoLaunchBrowser = response.data?.config?.autoLaunchBrowser !== false;
  ui.serverHueTransportPreference = normalizeHueTransportPreference(response.data?.config?.hueTransportPreference);
  ui.serverUnsafeSensitiveLogs = response.data?.config?.unsafeExposeSensitiveLogs === true;
  ui.serverUnsafeSensitiveLogsBaseline = ui.serverUnsafeSensitiveLogs;
  applySystemSettingsUi();
  return { ok: true };
}

function clearUiLocalCache() {
  return wipeUiBrowserMemory({ includeCacheStorage: true });
}

function tryParseJson(text) {
  try {
    return JSON.parse(text);
  } catch {
    return null;
  }
}

function clampFlowIntensity(value) {
  const n = Number(value);
  if (!Number.isFinite(n)) return 1;
  return Math.min(2.5, Math.max(0.35, n));
}

function applyFlowIntensityUi() {
  const value = clampFlowIntensity(ui.flowIntensity);
  ui.flowIntensity = value;
  el.flowIntensity.value = String(Math.round(value * 100));
  const text = `${value.toFixed(2)}x`;
  el.flowIntensityVal.textContent = text;
  el.flowStat.textContent = text;
}

let flowIntensityCommitTimer = null;
async function commitFlowIntensity(options = {}) {
  const silent = options.silent !== false;
  const value = clampFlowIntensity(ui.flowIntensity);
  const r = await postJson(`/rave/flow/intensity?value=${encodeURIComponent(value.toFixed(3))}`, {});
  if (!r.ok || !r.data || !r.data.ok) {
    if (!silent) setBadge(el.health, "bad", "FLOW INTENSITY FAIL");
    return false;
  }

  ui.flowIntensity = clampFlowIntensity(Number(r.data.value ?? value));
  applyFlowIntensityUi();
  if (!silent) setBadge(el.health, "ok", `FLOW X ${ui.flowIntensity.toFixed(2)}x`);
  return true;
}

async function resetFlowIntensity(options = {}) {
  if (flowIntensityCommitTimer) {
    clearTimeout(flowIntensityCommitTimer);
    flowIntensityCommitTimer = null;
  }
  ui.flowIntensity = 1;
  ui.flowIntensityInputUntil = Date.now() + 900;
  applyFlowIntensityUi();
  const ok = await commitFlowIntensity({ silent: options.silent !== false ? true : false });
  if (ok && options.silent === false) {
    setBadge(el.health, "ok", "FLOW RESET TO 1.00x");
  }
  return ok;
}

function normalizeModIdList(value) {
  if (!Array.isArray(value)) return [];
  const seen = new Set();
  const out = [];
  for (const raw of value) {
    const id = String(raw || "").trim();
    if (!id || seen.has(id)) continue;
    seen.add(id);
    out.push(id);
  }
  return out;
}

function normalizeModConfig(config = {}) {
  const source = config && typeof config === "object" ? config : {};
  return {
    enabled: normalizeModIdList(source.enabled),
    order: normalizeModIdList(source.order),
    disabled: normalizeModIdList(source.disabled)
  };
}

function cloneModConfig(config = {}) {
  const normalized = normalizeModConfig(config);
  return {
    enabled: [...normalized.enabled],
    order: [...normalized.order],
    disabled: [...normalized.disabled]
  };
}

function resolveQueuedModEnabled(modId, runtimeEnabled, draftConfig) {
  const id = String(modId || "").trim();
  if (!id) return Boolean(runtimeEnabled);
  const draft = normalizeModConfig(draftConfig);
  if (draft.disabled.includes(id)) return false;
  if (draft.enabled.includes(id)) return true;
  return Boolean(runtimeEnabled);
}

function getEffectiveModConfig() {
  return ui.modsDraftDirty
    ? cloneModConfig(ui.modsDraftConfig)
    : cloneModConfig(ui.modsRuntimeConfig);
}

function updateModHotswapUi(mods = []) {
  const effective = getEffectiveModConfig();
  let pendingCount = 0;
  for (const mod of (Array.isArray(mods) ? mods : [])) {
    const runtimeEnabled = Boolean(mod?.enabled);
    const queuedEnabled = resolveQueuedModEnabled(mod?.id, runtimeEnabled, effective);
    if (queuedEnabled !== runtimeEnabled) pendingCount += 1;
  }
  ui.modsDraftDirty = pendingCount > 0;

  const runtimeStatus = `${ui.modsActive}/${ui.modsTotal} loaded`;
  const updatedAtText = ui.modsSnapshot?.loadedAt
    ? ` | updated ${new Date(ui.modsSnapshot.loadedAt).toLocaleTimeString()}`
    : "";
  const pendingText = pendingCount > 0 ? ` | ${pendingCount} pending apply` : "";
  el.modsStatus.value = `${runtimeStatus}${updatedAtText}${pendingText}`;

  if (pendingCount > 0) {
    el.modHotswapStatus.value = `${pendingCount} queued change(s). Click APPLY HOTSWAP to load/unload mods live.`;
  } else {
    el.modHotswapStatus.value = "No pending mod changes.";
  }

  el.modApplyBtn.disabled = pendingCount <= 0;
  el.modDiscardBtn.disabled = pendingCount <= 0;
}

function getModTooltipText(mod) {
  const primary = String(mod?.tooltip || "").trim();
  const fallback = String(mod?.description || "").trim();
  const combined = (primary || fallback).replace(/\s+/g, " ").trim();
  if (!combined) return "";
  if (combined.length <= 320) return combined;
  return `${combined.slice(0, 317).trimEnd()}...`;
}

function createStatusPill(className, label) {
  const pill = document.createElement("span");
  pill.className = `statusPill ${className}`;
  pill.textContent = String(label || "");
  return pill;
}

function renderMods(modSnapshot) {
  ui.modsSnapshot = modSnapshot && typeof modSnapshot === "object"
    ? modSnapshot
    : null;

  const mods = Array.isArray(modSnapshot?.mods) ? modSnapshot.mods : [];
  ui.modsTotal = Number(modSnapshot?.total || mods.length || 0);
  ui.modsActive = Number(modSnapshot?.loaded || 0);
  ui.modsLoadedAt = Date.now();
  syncFixtureBrandOptions();
  ui.modsRuntimeConfig = normalizeModConfig(modSnapshot?.config || {});
  if (!ui.modsDraftDirty) {
    ui.modsDraftConfig = cloneModConfig(ui.modsRuntimeConfig);
  }

  const effectiveConfig = getEffectiveModConfig();

  el.modsRows.innerHTML = "";
  if (!mods.length) {
    const tr = document.createElement("tr");
    const td = document.createElement("td");
    td.colSpan = 7;
    td.textContent = "No mods discovered. Add folders under /mods with mod.json.";
    tr.appendChild(td);
    el.modsRows.appendChild(tr);
    updateModHotswapUi(mods);
    syncModUiCatalogFromModsSnapshot(modSnapshot, { forceReload: false, persist: true });
    return;
  }

  for (const mod of mods) {
    const tr = document.createElement("tr");
    const modId = String(mod.id || "").trim();
    const runtimeEnabled = Boolean(mod.enabled);
    const queuedEnabled = resolveQueuedModEnabled(modId, runtimeEnabled, effectiveConfig);
    const hasPending = queuedEnabled !== runtimeEnabled;
    const tooltipText = getModTooltipText(mod);

    const tdId = document.createElement("td");
    tdId.className = "mono";
    tdId.textContent = String(mod.id || "-");
    if (tooltipText) {
      tdId.title = tooltipText;
      tr.title = tooltipText;
    }

    const tdVersion = document.createElement("td");
    tdVersion.className = "mono";
    tdVersion.textContent = String(mod.version || "-");

    const tdEnabled = document.createElement("td");
    tdEnabled.appendChild(
      createStatusPill(runtimeEnabled ? "ok" : "bad", runtimeEnabled ? "YES" : "NO")
    );

    const tdPending = document.createElement("td");
    if (hasPending) {
      tdPending.appendChild(
        createStatusPill("warn", queuedEnabled ? "ENABLE" : "DISABLE")
      );
    } else {
      tdPending.textContent = "-";
    }

    const tdLoaded = document.createElement("td");
    tdLoaded.appendChild(
      createStatusPill(mod.loaded ? "ok" : "bad", mod.loaded ? "LOADED" : "OFFLINE")
    );

    const tdHooks = document.createElement("td");
    tdHooks.className = "mono";
    tdHooks.textContent = Array.isArray(mod.hooks) && mod.hooks.length
      ? mod.hooks.join(", ")
      : "-";

    const tdError = document.createElement("td");
    tdError.className = "mono";
    tdError.textContent = mod.error ? String(mod.error) : "-";

    tr.appendChild(tdId);
    tr.appendChild(tdVersion);
    tr.appendChild(tdEnabled);
    tr.appendChild(tdPending);
    tr.appendChild(tdLoaded);
    tr.appendChild(tdHooks);
    tr.appendChild(tdError);
    el.modsRows.appendChild(tr);
  }

  const currentEnableDraft = String(el.modEnableId.value || "").trim();
  if (!currentEnableDraft && mods.length) {
    const firstDisabled = mods.find(mod => !resolveQueuedModEnabled(mod.id, Boolean(mod.enabled), effectiveConfig));
    el.modEnableId.value = String(firstDisabled?.id || mods[0]?.id || "");
  }

  updateModHotswapUi(mods);
  syncModUiCatalogFromModsSnapshot(modSnapshot, { forceReload: false, persist: true });
}

async function loadMods() {
  const snapshot = await getJson("/mods");
  if (!snapshot || !snapshot.ok) return false;
  renderMods(snapshot);
  return true;
}

function normalizeImportRelativePath(rawPath) {
  const raw = String(rawPath || "").replace(/\\/g, "/").trim();
  if (!raw) return "";
  const cleaned = raw.replace(/^\/+/, "");
  const parts = cleaned.split("/").filter(Boolean);
  if (!parts.length) return "";
  if (parts.some(part => part === "." || part === "..")) return "";
  return parts.join("/");
}

function setModImportStatus(text) {
  if (!el.modImportStatus) return;
  el.modImportStatus.value = String(text || "").trim() || "Ready.";
}

function setModImportBusy(busy) {
  const isBusy = Boolean(busy);
  if (el.modImportBrowseBtn) el.modImportBrowseBtn.disabled = isBusy;
  if (el.modImportPicker) el.modImportPicker.disabled = isBusy;
  if (el.modImportOverwrite) el.modImportOverwrite.disabled = isBusy;
  if (el.modImportEnable) el.modImportEnable.disabled = isBusy;
}

function filesToImportDescriptors(fileList) {
  const deduped = new Map();
  for (const file of Array.from(fileList || [])) {
    const rel = normalizeImportRelativePath(file?.webkitRelativePath || file?.name || "");
    if (!rel) continue;
    deduped.set(rel, { file, relativePath: rel });
  }
  return Array.from(deduped.values());
}

async function readImportFileAsBase64(file) {
  if (!file || typeof file.arrayBuffer !== "function") return "";
  const buf = await file.arrayBuffer();
  const bytes = new Uint8Array(buf);
  let binary = "";
  const chunkSize = 0x8000;
  for (let i = 0; i < bytes.length; i += chunkSize) {
    const chunk = bytes.subarray(i, i + chunkSize);
    binary += String.fromCharCode(...chunk);
  }
  return btoa(binary);
}

async function buildImportPayloadFromDescriptors(descriptors) {
  const files = [];
  for (const descriptor of (Array.isArray(descriptors) ? descriptors : [])) {
    const rel = normalizeImportRelativePath(descriptor?.relativePath || descriptor?.file?.name || "");
    if (!rel) continue;
    const contentBase64 = await readImportFileAsBase64(descriptor.file);
    if (!contentBase64) continue;
    files.push({
      path: rel,
      contentBase64
    });
  }
  return files;
}

async function readDroppedEntriesRecursively(entry, prefix = "") {
  if (!entry) return [];

  if (entry.isFile) {
    const file = await new Promise(resolve => {
      entry.file(resolve, () => resolve(null));
    });
    if (!file) return [];
    const rel = normalizeImportRelativePath(prefix ? `${prefix}/${file.name}` : file.name);
    return rel ? [{ file, relativePath: rel }] : [];
  }

  if (entry.isDirectory) {
    const reader = entry.createReader();
    const entries = [];

    while (true) {
      const batch = await new Promise(resolve => {
        reader.readEntries(resolve, () => resolve([]));
      });
      if (!Array.isArray(batch) || !batch.length) break;
      entries.push(...batch);
    }

    const nested = [];
    const base = normalizeImportRelativePath(prefix ? `${prefix}/${entry.name}` : entry.name);
    for (const child of entries) {
      const childItems = await readDroppedEntriesRecursively(child, base);
      nested.push(...childItems);
    }
    return nested;
  }

  return [];
}

async function descriptorsFromDropEvent(event) {
  const dataTransfer = event?.dataTransfer;
  if (!dataTransfer) return [];

  const items = Array.from(dataTransfer.items || []);
  const collected = [];
  for (const item of items) {
    const entry = item?.webkitGetAsEntry?.();
    if (!entry) continue;
    const nested = await readDroppedEntriesRecursively(entry, "");
    collected.push(...nested);
  }

  if (collected.length) {
    const deduped = new Map();
    for (const item of collected) {
      const rel = normalizeImportRelativePath(item.relativePath || item.file?.name || "");
      if (!rel) continue;
      deduped.set(rel, { file: item.file, relativePath: rel });
    }
    return Array.from(deduped.values());
  }

  return filesToImportDescriptors(dataTransfer.files || []);
}

async function importModFromDescriptors(descriptors, sourceLabel = "drop") {
  const records = Array.isArray(descriptors) ? descriptors : [];
  if (!records.length) {
    setModImportStatus("No files found. Drop a folder that contains mod.json.");
    setBadge(el.health, "warn", "MOD IMPORT: NO FILES");
    return false;
  }

  setModImportBusy(true);
  setModImportStatus(`Preparing ${records.length} file(s) from ${sourceLabel}...`);

  try {
    const files = await buildImportPayloadFromDescriptors(records);
    if (!files.length) {
      setModImportStatus("No readable files found for import.");
      setBadge(el.health, "warn", "MOD IMPORT EMPTY");
      return false;
    }

    setModImportStatus(`Uploading ${files.length} file(s)...`);
    const payload = {
      files,
      overwrite: el.modImportOverwrite?.checked === true,
      enableAfterImport: el.modImportEnable?.checked !== false,
      reload: true
    };

    const response = await postJson("/mods/import", payload);
    if (!response.ok || !response.data?.ok) {
      const errorText = String(response.data?.error || `status ${response.status || 0}`);
      setModImportStatus(`Import failed: ${errorText}`);
      setBadge(el.health, "bad", "MOD IMPORT FAIL");
      return false;
    }

    const snapshot = response.data?.snapshot;
    if (snapshot?.ok) {
      ui.modsDraftDirty = false;
      ui.modsDraftConfig = cloneModConfig(snapshot.config || {});
      renderMods(snapshot);
    } else {
      await loadMods();
    }

    const modId = String(response.data?.modId || "mod").trim();
    setModImportStatus(`Imported ${modId} (${response.data?.importedFiles || files.length} files).`);
    setBadge(el.health, "ok", `MOD IMPORTED ${modId}`);
    return true;
  } catch (err) {
    setModImportStatus(`Import error: ${err?.message || err}`);
    setBadge(el.health, "bad", "MOD IMPORT ERROR");
    return false;
  } finally {
    setModImportBusy(false);
  }
}

function normalizeColorPrefixToken(value) {
  const raw = String(value || "").trim().toLowerCase();
  if (!raw) return "";
  return /^[a-z][a-z0-9_-]{0,31}$/.test(raw) ? raw : "";
}

function normalizeColorPrefixDefaultTarget(value, fallback = "both") {
  const raw = String(value || "").trim().toLowerCase();
  if (raw === "hue" || raw === "wiz" || raw === "both") return raw;
  return String(fallback || "both").trim().toLowerCase() || "both";
}

function applyColorPrefixSnapshot(snapshot = {}) {
  const config = snapshot?.config && typeof snapshot.config === "object"
    ? snapshot.config
    : snapshot;
  const prefixes = config?.prefixes && typeof config.prefixes === "object"
    ? config.prefixes
    : {};
  const capabilities = snapshot?.capabilities && typeof snapshot.capabilities === "object"
    ? snapshot.capabilities
    : {};

  const huePrefix = normalizeColorPrefixToken(prefixes.hue);
  const wizPrefix = normalizeColorPrefixToken(prefixes.wiz);
  const otherPrefix = normalizeColorPrefixToken(prefixes.other);
  const defaultTarget = normalizeColorPrefixDefaultTarget(config?.defaultTarget, "both");
  const otherEnabled = capabilities.other === true;

  ui.colorPrefixes = {
    hue: huePrefix,
    wiz: wizPrefix,
    other: otherPrefix
  };
  ui.colorPrefixDefaultTarget = defaultTarget;
  ui.colorPrefixOtherEnabled = otherEnabled;

  if (el.colorPrefixHue) el.colorPrefixHue.value = huePrefix;
  if (el.colorPrefixWiz) el.colorPrefixWiz.value = wizPrefix;
  if (el.colorPrefixDefaultTarget) el.colorPrefixDefaultTarget.value = defaultTarget;
  if (el.colorPrefixOther) el.colorPrefixOther.value = otherPrefix;
  if (el.colorPrefixOtherWrap) {
    el.colorPrefixOtherWrap.classList.toggle("prefixDisabled", !otherEnabled);
  }
  if (el.colorPrefixOther) el.colorPrefixOther.disabled = !otherEnabled;
  if (el.colorPrefixSaveBtn) el.colorPrefixSaveBtn.disabled = false;
  if (el.colorPrefixResetBtn) el.colorPrefixResetBtn.disabled = false;

  if (el.colorPrefixStatus) {
    const hueWord = huePrefix ? `hue='${huePrefix}'` : "hue=<none>";
    const wizWord = wizPrefix ? `wiz='${wizPrefix}'` : "wiz=<none>";
    const otherWord = otherEnabled
      ? (otherPrefix ? `other='${otherPrefix}'` : "other=<none>")
      : "other=<disabled>";
    const defaultWord = `unprefixed -> ${defaultTarget.toUpperCase()}`;
    if (!otherEnabled) {
      el.colorPrefixStatus.textContent =
        `${hueWord} | ${wizWord} | ${otherWord} | ${defaultWord}. Mod-brand prefix unlocks when mod-brand Twitch fixtures are detected.`;
    } else {
      el.colorPrefixStatus.textContent =
        `${hueWord} | ${wizWord} | ${otherWord} | ${defaultWord}.`;
    }
  }
}

async function loadColorPrefixConfig() {
  const snapshot = await getJson("/color/prefixes");
  if (!snapshot || !snapshot.ok) return false;
  applyColorPrefixSnapshot(snapshot);
  ui.colorPrefixConfigLoaded = true;
  return true;
}

async function saveColorPrefixConfigFromUi(options = {}) {
  const reset = options.reset === true;

  let huePrefix = normalizeColorPrefixToken(el.colorPrefixHue?.value || "");
  let wizPrefix = normalizeColorPrefixToken(el.colorPrefixWiz?.value || "");
  let defaultTarget = normalizeColorPrefixDefaultTarget(el.colorPrefixDefaultTarget?.value || "both", "both");
  let otherPrefix = normalizeColorPrefixToken(el.colorPrefixOther?.value || "");

  if (reset) {
    huePrefix = "hue";
    wizPrefix = "wiz";
    defaultTarget = "hue";
    otherPrefix = "";
  }

  const rawHue = String(el.colorPrefixHue?.value || "").trim();
  const rawWiz = String(el.colorPrefixWiz?.value || "").trim();
  const rawOther = String(el.colorPrefixOther?.value || "").trim();
  if (!reset && rawHue && !huePrefix) {
    setBadge(el.health, "bad", "INVALID HUE PREFIX (USE a-z 0-9 _ -)");
    return false;
  }
  if (!reset && rawWiz && !wizPrefix) {
    setBadge(el.health, "bad", "INVALID WIZ PREFIX (USE a-z 0-9 _ -)");
    return false;
  }
  if (!reset && rawOther && !otherPrefix) {
    setBadge(el.health, "bad", "INVALID MOD PREFIX (USE a-z 0-9 _ -)");
    return false;
  }

  const payload = {
    defaultTarget,
    prefixes: {
      hue: huePrefix,
      wiz: wizPrefix,
      other: otherPrefix
    }
  };

  if (!ui.colorPrefixOtherEnabled) {
    payload.prefixes.other = "";
  }

  const r = await postJson("/color/prefixes", payload);
  if (!r.ok || !r.data?.ok) {
    setBadge(el.health, "bad", "PREFIX CONFIG SAVE FAIL");
    return false;
  }

  applyColorPrefixSnapshot(r.data);
  setBadge(el.health, "ok", reset ? "PREFIXES RESET TO DEFAULTS" : "PREFIX CONFIG SAVED");
  return true;
}

async function runModAction() {
  const modId = String(el.modActionModId.value || "").trim();
  if (!modId) {
    setBadge(el.health, "warn", "MOD ID REQUIRED");
    return;
  }

  const action = String(el.modActionName.value || "").trim();
  const method = String(el.modActionMethod.value || "GET").toUpperCase() === "POST" ? "POST" : "GET";
  const path = action
    ? `/mods/${encodeURIComponent(modId)}/${encodeURIComponent(action)}`
    : `/mods/${encodeURIComponent(modId)}`;

  try {
    const res = await fetch(withBase(path), { method });
    const text = await res.text();
    const json = tryParseJson(text);
    const pretty = json ? JSON.stringify(json, null, 2) : (text || `(status ${res.status})`);
    el.modActionOutput.value = pretty;

    if (!res.ok) {
      setBadge(el.health, "warn", `MOD ACTION ${res.status}`);
      return;
    }

    setBadge(el.health, "ok", "MOD ACTION OK");
  } catch (err) {
    el.modActionOutput.value = String(err?.message || err || "request failed");
    setBadge(el.health, "bad", "MOD ACTION FAIL");
  }
}

async function queueModStateFromUi(shouldEnable = true) {
  const modId = String(el.modEnableId.value || "").trim();
  if (!modId) {
    setBadge(el.health, "warn", "MOD ID REQUIRED");
    return;
  }

  if (!ui.modsSnapshot?.ok || !Array.isArray(ui.modsSnapshot.mods)) {
    const loaded = await loadMods();
    if (!loaded) {
      setBadge(el.health, "bad", "MOD SNAPSHOT FAIL");
      return;
    }
  }

  const snapshot = ui.modsSnapshot;
  if (!snapshot?.ok || !Array.isArray(snapshot.mods)) {
    setBadge(el.health, "bad", "MOD SNAPSHOT FAIL");
    return;
  }

  const exists = snapshot.mods.some(mod => String(mod?.id || "") === modId);
  if (!exists) {
    setBadge(el.health, "warn", "MOD ID NOT FOUND");
    return;
  }

  const nextDraft = cloneModConfig(ui.modsDraftDirty ? ui.modsDraftConfig : ui.modsRuntimeConfig);
  const enabledSet = new Set(nextDraft.enabled);
  const disabledSet = new Set(nextDraft.disabled);
  const order = Array.isArray(nextDraft.order) ? [...nextDraft.order] : [];

  if (shouldEnable) {
    enabledSet.add(modId);
    disabledSet.delete(modId);
    if (!order.includes(modId)) order.push(modId);
  } else {
    enabledSet.delete(modId);
    disabledSet.add(modId);
  }

  nextDraft.enabled = Array.from(enabledSet);
  nextDraft.disabled = Array.from(disabledSet);
  nextDraft.order = normalizeModIdList(order);

  const hasChange = Array.isArray(snapshot.mods) && snapshot.mods.some(mod => {
    const runtimeEnabled = Boolean(mod?.enabled);
    const queuedEnabled = resolveQueuedModEnabled(mod?.id, runtimeEnabled, nextDraft);
    return queuedEnabled !== runtimeEnabled;
  });
  ui.modsDraftConfig = nextDraft;
  ui.modsDraftDirty = hasChange;
  renderMods(snapshot);

  if (!hasChange) {
    setBadge(el.health, "warn", "NO MOD HOTSWAP CHANGE");
    return;
  }

  const actionWord = shouldEnable ? "ENABLE" : "DISABLE";
  setBadge(el.health, "warn", `QUEUED ${actionWord} ${modId} (APPLY HOTSWAP)`);
}

async function enableModFromUi() {
  await queueModStateFromUi(true);
}

async function disableModFromUi() {
  await queueModStateFromUi(false);
}

async function applyModHotswapFromUi() {
  if (!ui.modsDraftDirty) {
    setBadge(el.health, "warn", "NO HOTSWAP CHANGES");
    return;
  }

  const draft = cloneModConfig(ui.modsDraftConfig);
  const update = await postJson("/mods/config", {
    enabled: draft.enabled,
    order: draft.order,
    disabled: draft.disabled,
    reload: true
  });

  if (!update.ok || !update.data?.ok) {
    setBadge(el.health, "bad", "HOTSWAP APPLY FAIL");
    return;
  }

  ui.modsDraftDirty = false;
  ui.modsDraftConfig = cloneModConfig(update.data?.config || draft);

  const nextSnapshot = update.data.snapshot;
  if (nextSnapshot?.ok) {
    renderMods(nextSnapshot);
  } else {
    await loadMods();
  }
  setBadge(el.health, "ok", "HOTSWAP APPLIED");
}

function discardModDraftFromUi() {
  if (!ui.modsDraftDirty) {
    setBadge(el.health, "warn", "NO HOTSWAP CHANGES");
    return;
  }
  ui.modsDraftDirty = false;
  ui.modsDraftConfig = cloneModConfig(ui.modsRuntimeConfig);
  if (ui.modsSnapshot?.ok) {
    renderMods(ui.modsSnapshot);
  }
  setBadge(el.health, "ok", "HOTSWAP CHANGES DISCARDED");
}

function getCanonicalZoneForBrand(brand, fallback = "custom") {
  const key = String(brand || "").trim().toLowerCase();
  if (key === "hue") return "hue";
  if (key === "wiz") return "wiz";
  return String(fallback || "custom").trim().toLowerCase() || "custom";
}

function normalizeZoneKey(value, fallback = "custom") {
  const zone = String(value || "").trim().toLowerCase();
  return zone || fallback;
}

function isBuiltinFixtureBrand(value) {
  const brand = String(value || "").trim().toLowerCase();
  return brand === "hue" || brand === "wiz";
}

function normalizeFixtureModBrandToken(value) {
  const brand = String(value || "").trim().toLowerCase();
  if (!brand || isBuiltinFixtureBrand(brand)) return "";
  return MOD_BRAND_RE.test(brand) ? brand : "";
}

function normalizeFixtureModBrandList(value) {
  if (!Array.isArray(value)) return [];
  const set = new Set();
  value.forEach(item => {
    const brand = normalizeFixtureModBrandToken(item);
    if (brand) set.add(brand);
  });
  return [...set].sort();
}

function collectFixtureModBrandsFromSnapshot(summary = {}, fixtures = []) {
  const set = new Set(normalizeFixtureModBrandList(summary?.modBrands));
  if (Array.isArray(fixtures)) {
    fixtures.forEach(fixture => {
      const brand = normalizeFixtureModBrandToken(fixture?.brand);
      if (brand) set.add(brand);
    });
  }
  return [...set].sort();
}

function formatFixtureBrandForUi(value) {
  const brand = String(value || "").trim().toLowerCase();
  if (!brand) return "";
  if (brand === "hue") return "HUE";
  if (brand === "wiz") return "WIZ";
  return brand.toUpperCase();
}

function collectActiveSceneSyncBrands(fixtures = []) {
  const set = new Set();
  const list = Array.isArray(fixtures) ? fixtures : [];
  list.forEach(fixture => {
    const brand = String(fixture?.brand || "").trim().toLowerCase();
    if (!isValidFixtureBrand(brand)) return;
    const enabled = fixture?.enabled !== false;
    const mode = String(fixture?.controlMode || "").trim().toLowerCase();
    const engineEnabled = fixture?.engineEnabled === false
      ? false
      : (fixture?.engineEnabled === true || mode === "engine" || mode === "");
    if (!enabled || !engineEnabled) return;
    set.add(brand);
  });
  const builtinOrder = { hue: 0, wiz: 1 };
  return [...set].sort((a, b) => {
    const rankA = Object.prototype.hasOwnProperty.call(builtinOrder, a) ? builtinOrder[a] : 99;
    const rankB = Object.prototype.hasOwnProperty.call(builtinOrder, b) ? builtinOrder[b] : 99;
    if (rankA !== rankB) return rankA - rankB;
    return a.localeCompare(b);
  });
}

function getSceneSyncLabelContext() {
  const brands = Array.isArray(ui.sceneSyncActiveBrands)
    ? ui.sceneSyncActiveBrands.filter(Boolean)
    : [];
  const multiBrand = brands.length > 1;
  const maxLabels = 3;
  const shown = brands.slice(0, maxLabels).map(formatFixtureBrandForUi).filter(Boolean);
  const overflow = brands.length > shown.length;
  const brandText = shown.join(" + ");
  const brandSuffix = multiBrand
    ? ` (${brandText}${overflow ? " + ..." : ""})`
    : "";

  return {
    syncButton: multiBrand && brandText
      ? `SYNC ${brandText}`
      : "SYNC FIXTURES",
    desyncButton: "FIXTURE DESYNC",
    statusSynced: `SCENE LINK: SYNCED${brandSuffix}`,
    statusDesynced: `SCENE LINK: FIXTURE DESYNC${brandSuffix}`,
    badgeSynced: multiBrand && brandText
      ? `SCENE SYNC ON (${brandText}${overflow ? " + ..." : ""})`
      : "SCENE SYNC ON",
    badgeDesynced: "FIXTURE DESYNC ON"
  };
}

function resolveFixtureFormBrand(fallback = "") {
  const fallbackBrand = isBuiltinFixtureBrand(fallback)
    ? String(fallback).trim().toLowerCase()
    : normalizeFixtureModBrandToken(fallback);
  const selectedBrand = String(el.fxBrand?.value || "").trim().toLowerCase();
  if (selectedBrand === FIXTURE_MOD_CUSTOM_BRAND_VALUE) {
    const customBrand = normalizeFixtureModBrandToken(el.fxModBrandId?.value || "");
    return customBrand || fallbackBrand;
  }
  if (isBuiltinFixtureBrand(selectedBrand)) return selectedBrand;
  return normalizeFixtureModBrandToken(selectedBrand) || fallbackBrand;
}

function syncFixtureBrandOptions(options = {}) {
  if (!el.fxBrand || !el.fxModBrandGroup) return;

  const requestedSelect = String(options.selectValue || "").trim().toLowerCase();
  const requestedCustomBrand = normalizeFixtureModBrandToken(options.customBrand || "");
  const previousSelect = String(el.fxBrand.value || "").trim().toLowerCase();
  const previousCustomBrand = normalizeFixtureModBrandToken(el.fxModBrandId?.value || "");
  const modsPresent = Number(ui.modsTotal || 0) > 0;

  const knownSet = new Set(normalizeFixtureModBrandList(ui.fixtureModBrands));
  const selectedKnownBrand = normalizeFixtureModBrandToken(requestedSelect || previousSelect);
  if (selectedKnownBrand) knownSet.add(selectedKnownBrand);
  if (requestedCustomBrand) knownSet.add(requestedCustomBrand);
  if (previousSelect === FIXTURE_MOD_CUSTOM_BRAND_VALUE && previousCustomBrand) {
    knownSet.add(previousCustomBrand);
  }

  const knownBrands = [...knownSet].sort();
  ui.fixtureModBrands = knownBrands;

  const allowCustomBrand = modsPresent;
  const locked = !allowCustomBrand && knownBrands.length === 0;
  el.fxModBrandGroup.innerHTML = "";
  el.fxModBrandGroup.label = locked ? "Mod Brands (locked)" : "Mod Brands";

  if (knownBrands.length > 0) {
    knownBrands.forEach(brand => {
      const option = document.createElement("option");
      option.value = brand;
      option.textContent = brand.toUpperCase();
      el.fxModBrandGroup.appendChild(option);
    });
  }

  if (allowCustomBrand) {
    const customOption = document.createElement("option");
    customOption.value = FIXTURE_MOD_CUSTOM_BRAND_VALUE;
    customOption.textContent = "CUSTOM MOD BRAND...";
    el.fxModBrandGroup.appendChild(customOption);
  }

  if (!knownBrands.length && !allowCustomBrand) {
    const placeholder = document.createElement("option");
    placeholder.value = "";
    placeholder.textContent = "No mod brands detected";
    placeholder.disabled = true;
    el.fxModBrandGroup.appendChild(placeholder);
  }

  el.fxModBrandGroup.disabled = locked;

  if (el.fxModBrandStatus) {
    if (knownBrands.length > 0 && allowCustomBrand) {
      el.fxModBrandStatus.textContent = `Detected mod brands: ${knownBrands.join(", ")}.`;
      el.fxModBrandStatus.classList.remove("prefixDisabled");
    } else if (knownBrands.length > 0) {
      el.fxModBrandStatus.textContent = `Configured mod brands: ${knownBrands.join(", ")}.`;
      el.fxModBrandStatus.classList.remove("prefixDisabled");
    } else if (allowCustomBrand) {
      el.fxModBrandStatus.textContent = "Mods detected. Select CUSTOM MOD BRAND... to add fixture brand ids.";
      el.fxModBrandStatus.classList.remove("prefixDisabled");
    } else {
      el.fxModBrandStatus.textContent = "Mod fixture brands unlock when mods are discovered.";
      el.fxModBrandStatus.classList.add("prefixDisabled");
    }
  }

  let nextSelect = requestedSelect || previousSelect || "hue";
  if (!isBuiltinFixtureBrand(nextSelect) && nextSelect !== FIXTURE_MOD_CUSTOM_BRAND_VALUE) {
    nextSelect = normalizeFixtureModBrandToken(nextSelect);
  }

  if (nextSelect === FIXTURE_MOD_CUSTOM_BRAND_VALUE && !allowCustomBrand) {
    nextSelect = knownBrands[0] || "hue";
  } else if (!isBuiltinFixtureBrand(nextSelect) && nextSelect !== FIXTURE_MOD_CUSTOM_BRAND_VALUE) {
    if (!nextSelect || !knownBrands.includes(nextSelect)) {
      nextSelect = knownBrands[0] || "hue";
    }
  }

  el.fxBrand.value = nextSelect;
  if (!el.fxBrand.value) {
    el.fxBrand.value = knownBrands[0] || "hue";
  }

  if (el.fxModBrandId) {
    if (el.fxBrand.value === FIXTURE_MOD_CUSTOM_BRAND_VALUE && allowCustomBrand) {
      el.fxModBrandId.value = requestedCustomBrand || previousCustomBrand || "";
    } else {
      el.fxModBrandId.value = "";
    }
  }

  if (options.applyVisibility !== false) applyFixtureBrandVisibility();
}

function isValidFixtureBrand(brandValue) {
  const brand = String(brandValue || "").trim().toLowerCase();
  if (!brand) return false;
  if (brand === "hue" || brand === "wiz") return true;
  return MOD_BRAND_RE.test(brand);
}

function parseLooseBoolean(value, fallback = false) {
  if (typeof value === "boolean") return value;
  if (value === 1 || value === "1") return true;
  if (value === 0 || value === "0") return false;
  if (typeof value === "string") {
    const raw = value.trim().toLowerCase();
    if (raw === "true" || raw === "on" || raw === "yes") return true;
    if (raw === "false" || raw === "off" || raw === "no") return false;
  }
  return fallback;
}

function isLikelyPlaceholderConfigValue(value) {
  const raw = String(value || "").trim().toLowerCase();
  if (!raw) return true;
  if (raw.includes("replace_with")) return true;
  if (raw.includes("192.168.x.x")) return true;
  if (raw.includes("x.x.x.x")) return true;
  if (raw.includes("example")) return true;
  return false;
}

function isFixtureConfiguredForOutput(fixture = {}) {
  const brand = String(fixture?.brand || "").trim().toLowerCase();
  if (brand === "hue") {
    const bridgeIp = String(fixture?.bridgeIp || "").trim();
    const username = String(fixture?.username || "").trim();
    const lightId = Number(fixture?.lightId || 0);
    return (
      !isLikelyPlaceholderConfigValue(bridgeIp) &&
      !isLikelyPlaceholderConfigValue(username) &&
      Number.isFinite(lightId) &&
      lightId > 0
    );
  }
  if (brand === "wiz") {
    const ip = String(fixture?.ip || "").trim();
    return !isLikelyPlaceholderConfigValue(ip);
  }
  return true;
}

function isFixtureEngineEnabled(fixture = {}) {
  const legacyIsEngine = String(fixture?.controlMode || "engine").trim().toLowerCase() === "engine";
  if (Object.prototype.hasOwnProperty.call(fixture, "engineEnabled")) {
    return parseLooseBoolean(fixture.engineEnabled, legacyIsEngine);
  }
  return legacyIsEngine;
}

function isFixtureTwitchEnabled(fixture = {}) {
  if (Object.prototype.hasOwnProperty.call(fixture, "twitchEnabled")) {
    return parseLooseBoolean(fixture.twitchEnabled, true);
  }
  return true;
}

function isFixtureCustomEnabled(fixture = {}) {
  const legacyIsStandalone = String(fixture?.controlMode || "engine").trim().toLowerCase() === "standalone";
  if (Object.prototype.hasOwnProperty.call(fixture, "customEnabled")) {
    return parseLooseBoolean(fixture.customEnabled, legacyIsStandalone);
  }
  return legacyIsStandalone;
}

function readFixtureModeFields() {
  const brand = resolveFixtureFormBrand("");
  const zone = normalizeZoneKey(el.fxZone.value, getCanonicalZoneForBrand(brand, "custom"));
  const engineEnabled = el.fxEngineEnabled.value === "true";
  const twitchEnabled = el.fxTwitchEnabled.value === "true";
  let customEnabled = el.fxCustomEnabled.value === "true";

  if (engineEnabled && customEnabled) {
    customEnabled = false;
    el.fxCustomEnabled.value = "false";
  }

  if (!engineEnabled && !twitchEnabled && !customEnabled) {
    customEnabled = true;
    el.fxCustomEnabled.value = "true";
  }

  const engineBinding = engineEnabled ? brand : "standalone";
  const controlMode = engineEnabled ? "engine" : "standalone";
  el.fxEngineBinding.value = engineBinding;
  el.fxControlMode.value = controlMode;

  return {
    zone,
    engineEnabled,
    twitchEnabled,
    customEnabled,
    engineBinding,
    controlMode
  };
}

function validateFixtureCoupling(brand, modeState) {
  const b = String(brand || "").trim().toLowerCase();
  const zone = normalizeZoneKey(modeState?.zone || "", getCanonicalZoneForBrand(b, "custom"));
  void zone;
  const engineEnabled = modeState?.engineEnabled === true;
  const twitchEnabled = modeState?.twitchEnabled === true;
  const customEnabled = modeState?.customEnabled === true;
  const binding = String(modeState?.engineBinding || "").trim().toLowerCase();

  if (!isValidFixtureBrand(b)) {
    return { ok: false, message: "Fixture brand must be hue, wiz, or a valid lowercase mod brand id." };
  }

  if (!engineEnabled && !twitchEnabled && !customEnabled) {
    return { ok: false, message: "Enable at least one mode: engine, twitch, or custom." };
  }

  if (engineEnabled && customEnabled) {
    return { ok: false, message: "Custom mode cannot be enabled while Engine mode is enabled." };
  }

  if (engineEnabled && binding !== b) {
    return {
      ok: false,
      message: `${b.toUpperCase()} fixtures can only bind to ${b.toUpperCase()} engine path.`
    };
  }

  const active = [];
  if (engineEnabled) active.push("engine");
  if (twitchEnabled) active.push("twitch");
  if (customEnabled) active.push("custom");
  return { ok: true, message: `Modes: ${active.join(" + ")}` };
}

function updateFixtureCompatibilityHint() {
  const modeState = readFixtureModeFields();
  const check = validateFixtureCoupling(resolveFixtureFormBrand(""), modeState);
  el.fxCompatHint.textContent = check.message;
  el.fxCompatHint.style.color = check.ok ? "#90e8b3" : "#ff8b8b";
  return check;
}

function syncFixtureCouplingDefaults(reason = "") {
  void reason;
  readFixtureModeFields();
  updateFixtureCompatibilityHint();
}

async function loadFixturesSnapshot(attempts = 1) {
  const maxAttempts = Math.max(1, Math.min(5, Number(attempts) || 1));
  for (let i = 0; i < maxAttempts; i += 1) {
    const snapshot = await getJson("/fixtures");
    if (snapshot && Array.isArray(snapshot.fixtures)) {
      return snapshot;
    }
    if (i < (maxAttempts - 1)) {
      await new Promise(resolve => setTimeout(resolve, 140));
    }
  }

  const configSnapshot = await getJson("/fixtures/config");
  if (configSnapshot?.ok && Array.isArray(configSnapshot?.config?.fixtures)) {
    return {
      fixtures: configSnapshot.config.fixtures,
      routes: configSnapshot.config.intentRoutes || {},
      summary: {},
      standalone: Array.isArray(ui.standaloneFixtures) ? ui.standaloneFixtures.slice() : [],
      connectivity: [],
      connectivitySummary: null
    };
  }
  return null;
}

async function refreshFixturesFromServer(options = {}) {
  const attempts = Math.max(1, Math.min(5, Number(options.attempts) || 1));
  const clearOnFail = options.clearOnFail === true;
  const snapshot = await loadFixturesSnapshot(attempts);
  if (snapshot) {
    updateFixtures(snapshot);
    return { ok: true, snapshot };
  }

  if (clearOnFail) {
    updateFixtures({
      fixtures: [],
      routes: {},
      summary: {},
      standalone: [],
      connectivity: [],
      connectivitySummary: null
    });
  }

  return { ok: false, snapshot: null };
}

async function getKnownFixtureCatalog() {
  const localCatalog = Array.isArray(ui.fixturesCatalog) ? ui.fixturesCatalog.slice() : [];
  if (localCatalog.length) return localCatalog;

  const snapshot = await loadFixturesSnapshot(2);
  if (snapshot && Array.isArray(snapshot.fixtures)) {
    return snapshot.fixtures.slice();
  }
  return localCatalog;
}

async function saveFixtureFromForm(options = {}) {

  const resetAfter = options.resetAfter !== false;
  const areaCheck = ensureHueEntertainmentAreaSelection({
    forcePrompt: false,
    promptIfMissing: true,
    forceWhenBridgeConfigured: true
  });
  if (!areaCheck.ok) {
    return {
      ok: false,
      error: areaCheck.message || "Hue Entertainment area is required.",
      savedFixture: null,
      routeSync: null
    };
  }

  const fixture = collectFixtureForm();
  const replaceId = String(fixture?.replaceId || "").trim();
  fixture.zone = normalizeZoneKey(fixture.zone, getCanonicalZoneForBrand(fixture.brand, "custom"));
  const coupling = validateFixtureCoupling(fixture.brand, fixture);
  if (!coupling.ok) {
    return {
      ok: false,
      error: coupling.message,
      savedFixture: null,
      routeSync: null
    };
  }

  const r = await postJson("/fixtures/fixture", fixture);
  if (!r.ok) {
    return {
      ok: false,
      error: r.data?.error || "fixture save failed",
      savedFixture: null,
      routeSync: null
    };
  }

  const savedFixture = r.data?.fixture || fixture;
  const catalogSeed = await getKnownFixtureCatalog();
  const localCatalog = upsertFixtureCatalogEntry(savedFixture, { replaceId, catalogSeed });
  applyFixtureCatalogToUi(localCatalog);
  let refreshOk = localCatalog.length > 0;
  if (savedFixture?.id && el.fxOriginalId && !resetAfter) {
    el.fxOriginalId.value = String(savedFixture.id).trim();
  }

  let fixtureSnapshot = await loadFixturesSnapshot(3);
  if (!fixtureSnapshot) {
    await api("/fixtures/reload");
    fixtureSnapshot = await loadFixturesSnapshot(2);
  }
  if (fixtureSnapshot) {
    updateFixtures(fixtureSnapshot);
    refreshOk = true;
  }

  if (!refreshOk && localCatalog.length > 0) {
    refreshOk = true;
  }

  if (resetAfter) resetFixtureForm();

  return {
    ok: true,
    savedFixture,
    refreshOk,
    routeSync: { ok: true, changed: false }
  };
}

async function discoverHueBridgeAndFill(preferredIp = "") {
  const discovered = await getJson("/hue/discover");
  const bridges = Array.isArray(discovered?.bridges) ? discovered.bridges : [];
  if (!bridges.length) {
    return { ok: false, error: discovered?.error || "No Hue bridge found on local network" };
  }

  const prefer = String(preferredIp || el.fxBridgeIp.value || "").trim();
  const selected =
    bridges.find(b => String(b?.ip || "").trim() === prefer) ||
    bridges[0];

  const ip = String(selected?.ip || "").trim();
  const id = String(selected?.id || "").trim().toUpperCase();
  if (ip) el.fxBridgeIp.value = ip;
  if (id) el.fxBridgeId.value = id;

  return {
    ok: true,
    bridge: {
      ip,
      id
    },
    total: bridges.length
  };
}

function ensureHueEntertainmentAreaSelection(options = {}) {
  const forcePrompt = options.forcePrompt === true;
  const promptIfMissing = options.promptIfMissing !== false;
  const forceWhenBridgeConfigured = options.forceWhenBridgeConfigured !== false;
  const brand = resolveFixtureFormBrand("");
  if (brand !== "hue") return { ok: true, areaId: "" };

  const bridgeIp = String(el.fxBridgeIp?.value || "").trim();
  const username = String(el.fxUsername?.value || "").trim();
  const bridgeId = String(el.fxBridgeId?.value || "").trim();
  const clientKey = String(el.fxClientKey?.value || "").trim();
  let areaId = String(el.fxEntertainmentAreaId?.value || "").trim();

  const bridgeConfigured = Boolean((bridgeIp && username) || (bridgeId && clientKey));
  const mustRequireArea = forcePrompt || (forceWhenBridgeConfigured && bridgeConfigured);
  if (!mustRequireArea) return { ok: true, areaId };

  if (forcePrompt || (!areaId && promptIfMissing)) {
    const prompted = window.prompt(
      "Hue Entertainment Area is required for reliable Hue streaming.\n\nEnter the exact Entertainment Area name or id:",
      areaId
    );
    if (prompted === null) {
      return {
        ok: false,
        cancelled: true,
        message: "Hue setup cancelled (entertainment area is required)."
      };
    }
    areaId = String(prompted || "").trim();
  }

  if (!areaId) {
    return {
      ok: false,
      cancelled: false,
      message: "Set ENT AREA before pairing or saving Hue bridge edits."
    };
  }

  el.fxEntertainmentAreaId.value = areaId;
  return { ok: true, areaId };
}

function toFixedSafe(v, digits, fallback = "0") {
  const n = Number(v);
  return Number.isFinite(n) ? n.toFixed(digits) : fallback;
}

function boolFromSelect(value) {
  const raw = String(value || "").toLowerCase().trim();
  return raw === "true" || raw === "1" || raw === "on" || raw === "yes";
}

function clampInt(value, min, max, fallback) {
  const n = Math.round(Number(value));
  if (!Number.isFinite(n)) return fallback;
  return Math.min(max, Math.max(min, n));
}

function clampNumber(value, min, max, fallback) {
  const n = Number(value);
  if (!Number.isFinite(n)) return fallback;
  return Math.min(max, Math.max(min, n));
}

function syncAutomationPercentLabels() {
  const startPercent = clampInt(el.autoStartPercent.value, 1, 100, 80);
  const stopPercent = clampInt(el.autoStopPercent.value, 1, 100, 100);
  el.autoStartPercentVal.textContent = `${startPercent}%`;
  el.autoStopPercentVal.textContent = `${stopPercent}%`;
}

function syncAutomationControlAccessibility() {
  const legacyLocked = !ui.legacyAutomationUnlocked;
  const enabled = boolFromSelect(el.autoRulesEnabled.value) && !legacyLocked;
  [
    el.autoRulesEnabled,
    el.autoRulesTargetZone,
    el.autoRulesTransitionMs,
    el.autoStartEnabled,
    el.autoStartPercent,
    el.autoStartDelayMs,
    el.autoStopEnabled,
    el.autoStopPercent,
    el.autoStopDelayMs,
    el.autoRulesSaveBtn,
    el.autoRulesReloadBtn,
    el.autoRulesTestStartBtn,
    el.autoRulesTestStopBtn
  ].forEach(node => {
    if (!node) return;
    if (legacyLocked) {
      node.disabled = true;
    } else {
      const requiresAutomationOn =
        node === el.autoRulesTargetZone ||
        node === el.autoRulesTransitionMs ||
        node === el.autoStartEnabled ||
        node === el.autoStartPercent ||
        node === el.autoStartDelayMs ||
        node === el.autoStopEnabled ||
        node === el.autoStopPercent ||
        node === el.autoStopDelayMs ||
        node === el.autoRulesTestStartBtn ||
        node === el.autoRulesTestStopBtn;
      node.disabled = requiresAutomationOn ? !enabled : false;
    }
  });
}

function syncLegacyAutomationUi() {
  const unlocked = ui.legacyAutomationUnlocked === true;
  if (el.legacyAutomationWrap) {
    el.legacyAutomationWrap.classList.toggle("legacyLocked", !unlocked);
  }
  if (el.legacyAutomationUnlockBtn) {
    el.legacyAutomationUnlockBtn.classList.toggle("hidden", unlocked);
  }
  if (el.legacyAutomationLockBtn) {
    el.legacyAutomationLockBtn.classList.toggle("hidden", !unlocked);
  }
}

function setLegacyAutomationUnlocked(enabled, options = {}) {
  const unlocked = Boolean(enabled);
  ui.legacyAutomationUnlocked = unlocked;
  if (options.persist !== false) {
    if (unlocked) localStorage.setItem(LEGACY_AUTOMATION_UNLOCK_KEY, "1");
    else localStorage.removeItem(LEGACY_AUTOMATION_UNLOCK_KEY);
  }
  syncLegacyAutomationUi();
  syncAutomationControlAccessibility();
}

function refreshAutomationZoneOptions(fixtures = []) {
  const current = String(el.autoRulesTargetZone.value || "all");
  const hueZones = [...new Set(
    (Array.isArray(fixtures) ? fixtures : [])
      .filter(f => String(f?.brand || "").toLowerCase() === "hue")
      .map(f => String(f?.zone || "").trim())
      .filter(Boolean)
  )].sort((a, b) => a.localeCompare(b));

  const nextOptions = ["all", ...hueZones];
  el.autoRulesTargetZone.innerHTML = "";
  for (const value of nextOptions) {
    const option = document.createElement("option");
    option.value = value;
    option.textContent = value === "all" ? "all hue fixtures" : value;
    el.autoRulesTargetZone.appendChild(option);
  }

  if (!nextOptions.includes(current)) {
    const extra = document.createElement("option");
    extra.value = current;
    extra.textContent = current;
    el.autoRulesTargetZone.appendChild(extra);
  }
  el.autoRulesTargetZone.value = current;
}

function applyFixtureCatalogToUi(fixtures = []) {
  const catalog = Array.isArray(fixtures) ? fixtures.slice() : [];
  ui.fixturesCatalog = catalog;
  try {
    refreshAutomationZoneOptions(catalog);
  } catch (err) {
    console.warn("[FIXTURES][UI] automation zone refresh failed:", err?.message || err);
  }
  try {
    renderRouteFixtureOptions(catalog);
  } catch (err) {
    console.warn("[FIXTURES][UI] route selector render failed:", err?.message || err);
  }
  try {
    renderFixtureRows(catalog);
  } catch (err) {
    console.warn("[FIXTURES][UI] fixture table render failed:", err?.message || err);
  }
}

function upsertFixtureCatalogEntry(fixture, options = {}) {
  if (!fixture || typeof fixture !== "object") {
    return Array.isArray(ui.fixturesCatalog) ? ui.fixturesCatalog.slice() : [];
  }

  const replaceId = String(options?.replaceId || "").trim();
  const nextId = String(fixture?.id || "").trim();
  const seedCatalog = Array.isArray(options?.catalogSeed)
    ? options.catalogSeed
    : ui.fixturesCatalog;
  const catalog = Array.isArray(seedCatalog) ? seedCatalog.slice() : [];

  if (replaceId && replaceId !== nextId) {
    for (let i = catalog.length - 1; i >= 0; i -= 1) {
      if (String(catalog[i]?.id || "").trim() === replaceId) {
        catalog.splice(i, 1);
      }
    }
  }

  if (!nextId) {
    catalog.push(fixture);
    return catalog;
  }

  const idx = catalog.findIndex(item => String(item?.id || "").trim() === nextId);
  if (idx >= 0) {
    catalog[idx] = {
      ...catalog[idx],
      ...fixture
    };
  } else {
    catalog.push(fixture);
  }
  return catalog;
}

function renderAutomationSummary(config = {}, meta = {}) {
  const start = config.start || {};
  const stop = config.stop || {};

  el.autoRulesState.textContent = config.enabled === false ? "DISABLED" : "ENABLED";
  el.autoRulesZone.textContent = String(config.targetZone || "all");
  el.autoRulesTransition.textContent = `${clampInt(config.transitionMs, 0, 10000, 400)}ms`;
  el.autoRulesStart.textContent = start.enabled === false
    ? "OFF"
    : `${clampInt(start.brightnessPercent, 1, 100, 80)}% @ ${clampInt(start.delayMs, 0, 60000, 0)}ms`;
  el.autoRulesStop.textContent = stop.enabled === false
    ? "OFF"
    : `${clampInt(stop.brightnessPercent, 1, 100, 100)}% @ ${clampInt(stop.delayMs, 0, 60000, 0)}ms`;
  el.autoRulesVersion.textContent = String(meta.version ?? 0);
  el.autoRulesLoadedAt.textContent = meta.loadedAt
    ? new Date(meta.loadedAt).toLocaleTimeString()
    : "-";

  const backupPath = String(meta.lastBackupPath || "");
  el.autoRulesBackup.textContent = backupPath
    ? backupPath.split(/[/\\]/).pop()
    : "-";
}

function applyAutomationConfigToInputs(config = {}, meta = {}) {
  const start = config.start || {};
  const stop = config.stop || {};

  el.autoRulesEnabled.value = config.enabled === false ? "false" : "true";
  el.autoRulesTargetZone.value = String(config.targetZone || "all");
  if (!Array.from(el.autoRulesTargetZone.options).some(o => o.value === el.autoRulesTargetZone.value)) {
    const extra = document.createElement("option");
    extra.value = el.autoRulesTargetZone.value;
    extra.textContent = el.autoRulesTargetZone.value;
    el.autoRulesTargetZone.appendChild(extra);
  }

  el.autoRulesTransitionMs.value = String(clampInt(config.transitionMs, 0, 10000, 400));
  el.autoStartEnabled.value = start.enabled === false ? "false" : "true";
  el.autoStartPercent.value = String(clampInt(start.brightnessPercent, 1, 100, 80));
  el.autoStartDelayMs.value = String(clampInt(start.delayMs, 0, 60000, 0));
  el.autoStopEnabled.value = stop.enabled === false ? "false" : "true";
  el.autoStopPercent.value = String(clampInt(stop.brightnessPercent, 1, 100, 100));
  el.autoStopDelayMs.value = String(clampInt(stop.delayMs, 0, 60000, 0));
  syncAutomationPercentLabels();
  syncAutomationControlAccessibility();
  renderAutomationSummary(config, meta);
}

function collectAutomationConfigFromInputs() {
  return {
    enabled: boolFromSelect(el.autoRulesEnabled.value),
    targetZone: String(el.autoRulesTargetZone.value || "all").trim() || "all",
    transitionMs: clampInt(el.autoRulesTransitionMs.value, 0, 10000, 400),
    start: {
      enabled: boolFromSelect(el.autoStartEnabled.value),
      brightnessPercent: clampInt(el.autoStartPercent.value, 1, 100, 80),
      delayMs: clampInt(el.autoStartDelayMs.value, 0, 60000, 0)
    },
    stop: {
      enabled: boolFromSelect(el.autoStopEnabled.value),
      brightnessPercent: clampInt(el.autoStopPercent.value, 1, 100, 100),
      delayMs: clampInt(el.autoStopDelayMs.value, 0, 60000, 0)
    }
  };
}

async function loadAutomationConfig() {
  const r = await getJson("/automation/config");
  if (!r || !r.ok || !r.config) return false;
  applyAutomationConfigToInputs(r.config, r.meta || {});
  ui.automationConfigLoaded = true;
  return true;
}

function renderGenreButtons(genres = []) {
  if (!Array.isArray(genres) || !genres.length) return;

  el.genreGrid.innerHTML = "";
  for (const g of genres) {
    if (!g || !g.id) continue;
    const btn = document.createElement("button");
    btn.type = "button";
    btn.dataset.genre = String(g.id);
    btn.textContent = String(g.label || g.id).toUpperCase();
    el.genreGrid.appendChild(btn);
  }
}

async function loadGenreCatalog() {
  const r = await getJson("/rave/genres");
  if (!r || !r.ok || !Array.isArray(r.genres)) return false;
  renderGenreButtons(r.genres);
  return true;
}

function getCollapseStorageKey(panel) {
  const key = String(panel?.dataset?.collapsibleKey || panel?.id || "").trim();
  if (!key) return "";
  return `ravelink_ui_collapsed_${key}`;
}

function setCollapsibleState(panel, collapsed, options = {}) {
  if (!panel) return;
  const nextCollapsed = Boolean(collapsed);
  const body = panel.querySelector(".clusterBody");
  const btn = panel.querySelector("[data-collapse-btn]");
  const storageKey = getCollapseStorageKey(panel);

  panel.classList.toggle("collapsed", nextCollapsed);
  if (body) body.setAttribute("aria-hidden", nextCollapsed ? "true" : "false");
  if (btn) {
    btn.textContent = nextCollapsed ? "EXPAND" : "COLLAPSE";
    btn.setAttribute("aria-expanded", nextCollapsed ? "false" : "true");
    btn.title = nextCollapsed ? "Expand this section." : "Collapse this section.";
  }

  if (options.persist !== false && storageKey) {
    localStorage.setItem(storageKey, nextCollapsed ? "1" : "0");
  }
}

function initCollapsiblePanels() {
  const panels = Array.from(document.querySelectorAll(".cluster.collapsible, .subcluster.collapsible"));
  const compactViewport =
    window.matchMedia("(max-width: 980px), (max-height: 760px)").matches ||
    ui.obsDockMode ||
    ui.obsDockCompact;
  panels.forEach(panel => {
    const btn = panel.querySelector("[data-collapse-btn]");
    if (!btn) return;

    const storageKey = getCollapseStorageKey(panel);
    const defaultCollapsed = panel.dataset.collapsedDefault === "1" ||
      (compactViewport && panel.dataset.collapsedDefaultMobile === "1");
    const stored = storageKey ? localStorage.getItem(storageKey) : null;
    const startCollapsed = stored === "1"
      ? true
      : stored === "0"
        ? false
        : defaultCollapsed;

    setCollapsibleState(panel, startCollapsed, { persist: false });
    btn.onclick = () => {
      setCollapsibleState(panel, !panel.classList.contains("collapsed"));
    };
  });
}

function setOnboardingLock(locked) {
  const nextLocked = Boolean(locked);
  document.body.classList.toggle("onboardLock", nextLocked);
  if (el.onboardGate) {
    el.onboardGate.classList.toggle("hidden", !nextLocked);
  }

  if (nextLocked) {
    showTab("live");
  }
}

function initOnboardingGate() {
  if (ui.obsDockMode) {
    ui.onboardingAcknowledged = true;
    setOnboardingLock(false);
    return;
  }

  const acknowledged = localStorage.getItem(ONBOARD_ACK_KEY) === "1";
  ui.onboardingAcknowledged = acknowledged;
  setOnboardingLock(!acknowledged);

  if (el.onboardAckBtn) {
    el.onboardAckBtn.onclick = () => {
      localStorage.setItem(ONBOARD_ACK_KEY, "1");
      ui.onboardingAcknowledged = true;
      setOnboardingLock(false);
      setBadge(el.health, "ok", "SETUP CONFIRMED");
      maybeAutoStartGuidedOnboarding();
    };
  }
}

function setHueEntGuideLock(locked) {
  const nextLocked = Boolean(locked);
  document.body.classList.toggle("hueEntGuideLock", nextLocked);
  if (el.hueEntGuideGate) {
    el.hueEntGuideGate.classList.toggle("hidden", !nextLocked);
  }

  if (nextLocked) {
    showTab("fixtures");
    el.fxHueBridgeBlock?.scrollIntoView({ behavior: "smooth", block: "center" });
  }
}

function initHueEntGuideGate() {
  ui.hueEntGuideAcknowledged = localStorage.getItem(HUE_ENT_GUIDE_ACK_KEY) === "1";
  setHueEntGuideLock(false);

  if (el.hueEntGuideAckBtn) {
    el.hueEntGuideAckBtn.onclick = () => {
      localStorage.setItem(HUE_ENT_GUIDE_ACK_KEY, "1");
      ui.hueEntGuideAcknowledged = true;
      setHueEntGuideLock(false);
      const resolve = hueEntGuideAckResolver;
      hueEntGuideAckResolver = null;
      hueEntGuideAckPromise = null;
      if (typeof resolve === "function") resolve(true);
    };
  }
}

function ensureHueEntGuideAcknowledged() {
  if (ui.hueEntGuideAcknowledged) {
    return Promise.resolve(true);
  }
  if (hueEntGuideAckPromise) {
    return hueEntGuideAckPromise;
  }
  hueEntGuideAckPromise = new Promise(resolve => {
    hueEntGuideAckResolver = resolve;
    setHueEntGuideLock(true);
  });
  return hueEntGuideAckPromise;
}

function getGuidedOnboardingSteps() {
  return [
    {
      tab: "live",
      selector: ".liveMainCluster",
      title: "Live Control Surface",
      text: "RAVE ON starts the reactive engine. RAVE OFF stops it. PANIC forces immediate blackout intent."
    },
    {
      tab: "fixtures",
      selector: "#fxHueBridgeBlock",
      title: "Pair Hue + Entertainment",
      text: "Use Discover -> Pair, then confirm ENT AREA is set. This enables low-latency Hue Entertainment streaming.",
      onBefore: () => {
        if (el.fxBrand?.value !== "hue") {
          el.fxBrand.value = "hue";
          applyFixtureBrandVisibility();
        }
      }
    },
    {
      tab: "audio",
      selector: "#aDevices",
      title: "Pick Audio Input",
      text: "Select the capture source that actually carries stream/music audio, then click APPLY AUDIO CFG."
    },
    {
      tab: "fixtures",
      selector: "[data-collapsible-key=\"deviceRouting\"]",
      expandSelector: "[data-collapsible-key=\"deviceRouting\"]",
      title: "Route Devices To Engine/Twitch/Custom",
      text: "Per fixture, toggle ENGINE/TWITCH/CUSTOM and APPLY ROUTING. ENGINE + TWITCH can run together."
    },
    {
      tab: "mods",
      selector: "#modCenter",
      expandSelector: "#modCenter",
      title: "Mod Center",
      text: "Import mods, hotswap enable/disable changes, and verify runtime mod actions from one place."
    },
    {
      tab: "system",
      selector: "[data-collapsible-key=\"systemSettings\"]",
      expandSelector: "[data-collapsible-key=\"systemSettings\"]",
      title: "System Settings",
      text: "Set startup tab, safety confirmations, API base, and polling behavior for this browser session."
    },
    {
      tab: "live",
      selector: "#themeCogBtn",
      title: "Settings Cog",
      text: "Use the cog for themes and to replay onboarding later. Skipping this tour does not remove that option."
    }
  ];
}

function readGuidedOnboardingState() {
  const raw = String(localStorage.getItem(GUIDED_ONBOARDING_STATE_KEY) || "").trim().toLowerCase();
  if (raw === "completed" || raw === "skipped") return raw;
  return "";
}

function writeGuidedOnboardingState(nextState) {
  const value = String(nextState || "").trim().toLowerCase();
  if (!value) {
    localStorage.removeItem(GUIDED_ONBOARDING_STATE_KEY);
    ui.guidedOnboardingStatus = "";
    return;
  }
  ui.guidedOnboardingStatus = value;
  localStorage.setItem(GUIDED_ONBOARDING_STATE_KEY, value);
}

function updateOnboardingLauncherText() {
  if (!el.onboardStartBtn) return;
  const replay = ui.guidedOnboardingStatus === "completed" || ui.guidedOnboardingStatus === "skipped";
  el.onboardStartBtn.textContent = replay ? "REPLAY ONBOARDING" : "START ONBOARDING";
}

function clearGuidedTourFocus() {
  if (guidedTourFocusEl && guidedTourFocusEl.classList) {
    guidedTourFocusEl.classList.remove("guidedTourFocus");
  }
  guidedTourFocusEl = null;
}

function setGuidedTourFocus(target) {
  clearGuidedTourFocus();
  if (!target || !target.classList) return;
  guidedTourFocusEl = target;
  guidedTourFocusEl.classList.add("guidedTourFocus");
}

function setGuidedTourLock(locked) {
  const nextLocked = Boolean(locked);
  document.body.classList.toggle("guidedTourLock", nextLocked);
  if (el.guidedTourGate) {
    el.guidedTourGate.classList.toggle("hidden", !nextLocked);
  }
}

function resolveGuidedTourStepTarget(step = {}) {
  const expandSelector = String(step.expandSelector || "").trim();
  if (expandSelector) {
    const panel = document.querySelector(expandSelector);
    if (panel?.classList?.contains("collapsible")) {
      setCollapsibleState(panel, false);
    }
  }
  const selector = String(step.selector || "").trim();
  if (!selector) return null;
  return document.querySelector(selector);
}

function renderGuidedOnboardingStep() {
  const steps = getGuidedOnboardingSteps();
  const maxIndex = Math.max(0, steps.length - 1);
  ui.guidedOnboardingStep = Math.max(0, Math.min(maxIndex, Number(ui.guidedOnboardingStep) || 0));
  const step = steps[ui.guidedOnboardingStep];
  if (!step) return;

  if (step.tab) showTab(step.tab);
  if (typeof step.onBefore === "function") {
    step.onBefore();
  }

  const target = resolveGuidedTourStepTarget(step);
  if (target) {
    target.scrollIntoView({ behavior: "smooth", block: "center" });
    setGuidedTourFocus(target);
  } else {
    clearGuidedTourFocus();
  }

  const currentStep = ui.guidedOnboardingStep + 1;
  const totalSteps = steps.length;
  if (el.guidedTourStep) {
    el.guidedTourStep.textContent = `${currentStep} / ${totalSteps}`;
  }
  if (el.guidedTourTitle) {
    el.guidedTourTitle.textContent = step.title || "Onboarding";
  }
  if (el.guidedTourText) {
    el.guidedTourText.textContent = step.text || "";
  }
  if (el.guidedTourPrevBtn) {
    el.guidedTourPrevBtn.disabled = currentStep <= 1;
  }
  if (el.guidedTourNextBtn) {
    el.guidedTourNextBtn.textContent = currentStep >= totalSteps ? "FINISH" : "NEXT";
  }
}

function finishGuidedOnboarding(reason = "completed") {
  if (!ui.guidedOnboardingActive) return;

  ui.guidedOnboardingActive = false;
  clearGuidedTourFocus();
  setGuidedTourLock(false);

  if (reason === "completed") {
    writeGuidedOnboardingState("completed");
    setBadge(el.health, "ok", "ONBOARDING COMPLETE");
  } else if (reason === "skipped") {
    writeGuidedOnboardingState("skipped");
    setBadge(el.health, "warn", "ONBOARDING SKIPPED: SETTINGS COG -> START ONBOARDING");
  }

  updateOnboardingLauncherText();
}

function startGuidedOnboarding(options = {}) {
  if (ui.guidedOnboardingActive) return;
  const manual = options.manual === true;

  if (guidedTourAutoStartTimer) {
    clearTimeout(guidedTourAutoStartTimer);
    guidedTourAutoStartTimer = null;
  }

  ui.guidedOnboardingActive = true;
  ui.guidedOnboardingStep = 0;
  setGuidedTourLock(true);
  renderGuidedOnboardingStep();
  if (manual) {
    setBadge(el.health, "ok", "ONBOARDING STARTED");
  }
}

function maybeAutoStartGuidedOnboarding() {
  if (ui.obsDockMode) return;
  if (!ui.onboardingAcknowledged) return;
  if (ui.guidedOnboardingActive) return;
  if (ui.guidedOnboardingStatus === "completed" || ui.guidedOnboardingStatus === "skipped") return;
  if (guidedTourAutoStartTimer) return;

  guidedTourAutoStartTimer = setTimeout(() => {
    guidedTourAutoStartTimer = null;
    if (ui.guidedOnboardingActive) return;
    if (!ui.onboardingAcknowledged) return;
    if (ui.guidedOnboardingStatus === "completed" || ui.guidedOnboardingStatus === "skipped") return;
    startGuidedOnboarding({ manual: false });
  }, 260);
}

function initGuidedOnboarding() {
  ui.guidedOnboardingStatus = readGuidedOnboardingState();
  updateOnboardingLauncherText();
  setGuidedTourLock(false);

  if (el.onboardStartBtn) {
    el.onboardStartBtn.onclick = () => {
      startGuidedOnboarding({ manual: true });
      toggleThemePanel(false);
    };
  }

  if (el.onboardResetBtn) {
    el.onboardResetBtn.onclick = () => {
      writeGuidedOnboardingState("");
      updateOnboardingLauncherText();
      setBadge(el.health, "ok", "ONBOARDING RESET: WILL AUTO-START NEXT LOAD");
    };
  }

  if (el.guidedTourPrevBtn) {
    el.guidedTourPrevBtn.onclick = () => {
      if (!ui.guidedOnboardingActive) return;
      ui.guidedOnboardingStep = Math.max(0, ui.guidedOnboardingStep - 1);
      renderGuidedOnboardingStep();
    };
  }

  if (el.guidedTourNextBtn) {
    el.guidedTourNextBtn.onclick = () => {
      if (!ui.guidedOnboardingActive) return;
      const total = getGuidedOnboardingSteps().length;
      if (ui.guidedOnboardingStep >= total - 1) {
        finishGuidedOnboarding("completed");
        return;
      }
      ui.guidedOnboardingStep += 1;
      renderGuidedOnboardingStep();
    };
  }

  if (el.guidedTourSkipBtn) {
    el.guidedTourSkipBtn.onclick = () => {
      finishGuidedOnboarding("skipped");
    };
  }

  maybeAutoStartGuidedOnboarding();
}

function showTab(name) {
  const requested = String(name || "").trim().toLowerCase();
  const canUseRequested = tabButtons.some(btn =>
    btn.dataset.tabBtn === requested && !btn.classList.contains("hidden")
  ) && tabPages.some(page =>
    page.dataset.tab === requested && !page.classList.contains("hidden")
  );
  const fallback = tabButtons.find(btn => !btn.classList.contains("hidden"))?.dataset?.tabBtn || "live";
  const nextTab = canUseRequested ? requested : fallback;

  ui.activeTab = nextTab;
  tabButtons.forEach(btn => {
    btn.classList.toggle("active", btn.dataset.tabBtn === nextTab);
  });
  tabPages.forEach(page => {
    page.classList.toggle("active", page.dataset.tab === nextTab);
  });

  if (nextTab === "custom") {
    applyCustomFixtureSelectionFromTab({ notify: false });
  }
  if (nextTab === "mods") {
    renderModUiFrame({ forceReload: false });
  }

  updateMonitorRenderingState();
  syncDynamicModUiTabButtons();
}

function activateTabAndScroll(tabName, sectionId) {
  showTab(tabName);
  const section = document.getElementById(sectionId);
  if (!section) return;
  if (section.classList.contains("collapsible")) {
    setCollapsibleState(section, false);
  }
  section.scrollIntoView({ behavior: "smooth", block: "start" });
}

function applyFixtureBrandVisibility() {
  const selectedBrand = String(el.fxBrand.value || "hue").trim().toLowerCase();
  const effectiveBrand = resolveFixtureFormBrand("");
  const isHue = selectedBrand === "hue" || effectiveBrand === "hue";
  const isCustomModBrand = selectedBrand === FIXTURE_MOD_CUSTOM_BRAND_VALUE;
  el.fxHueBridgeBlock.classList.toggle("hidden", !isHue);
  el.fxHueBridgeWrap.classList.toggle("hidden", !isHue);
  el.fxHueUserWrap.classList.toggle("hidden", !isHue);
  el.fxHueLightWrap.classList.toggle("hidden", !isHue);
  el.fxHueBridgeIdWrap.classList.toggle("hidden", !isHue);
  el.fxHueClientKeyWrap.classList.toggle("hidden", !isHue);
  el.fxHueEntWrap.classList.toggle("hidden", !isHue);
  el.fxHuePairWrap.classList.toggle("hidden", !isHue);
  el.fxWizIpWrap.classList.toggle("hidden", isHue);
  if (el.fxModBrandWrap) {
    el.fxModBrandWrap.classList.toggle("hidden", !isCustomModBrand);
  }
  if (el.fxWizIpLabel) {
    const infoTipTitle = effectiveBrand === "wiz"
      ? "LAN IP of the WiZ fixture. One fixture per entry in this form."
      : "Adapter-defined target value for non-Hue fixtures. Keep empty if your mod brand adapter does not need this field.";
    const infoLabelText = effectiveBrand === "wiz" ? "WIZ IP" : "MOD TARGET / IP (OPTIONAL)";
    const infoTip = document.createElement("span");
    infoTip.className = "infoTip";
    infoTip.title = infoTipTitle;
    infoTip.textContent = "?";
    el.fxWizIpLabel.replaceChildren(document.createTextNode(`${infoLabelText} `), infoTip);
  }
  syncFixtureCouplingDefaults();
}

function resetFixtureForm() {
  syncFixtureBrandOptions({ selectValue: "hue", customBrand: "", applyVisibility: false });
  el.fxBrand.value = "hue";
  if (el.fxModBrandId) el.fxModBrandId.value = "";
  el.fxId.value = "";
  if (el.fxOriginalId) el.fxOriginalId.value = "";
  el.fxZone.value = "";
  el.fxEnabled.value = "true";
  el.fxEngineEnabled.value = "true";
  el.fxCustomEnabled.value = "false";
  el.fxTwitchEnabled.value = "true";
  el.fxControlMode.value = "engine";
  el.fxEngineBinding.value = "hue";
  el.fxBridgeIp.value = "";
  el.fxUsername.value = "";
  el.fxLightId.value = "1";
  el.fxBridgeId.value = "";
  el.fxClientKey.value = "";
  el.fxEntertainmentAreaId.value = "";
  el.fxWizIp.value = "";
  setSensitiveFieldVisibility(el.fxBridgeIp, el.fxBridgeIpShowBtn, false, "HUE BRIDGE IP");
  setSensitiveFieldVisibility(el.fxUsername, el.fxUsernameShowBtn, false, "HUE USERNAME");
  setSensitiveFieldVisibility(el.fxClientKey, el.fxClientKeyShowBtn, false, "HUE CLIENT KEY");
  setSensitiveFieldVisibility(el.fxWizIp, el.fxWizIpShowBtn, false, "WIZ IP / MOD TARGET");
  applyFixtureBrandVisibility();
}

function setSensitiveFieldVisibility(input, button, show, label = "sensitive field") {
  if (!input || !button) return;
  input.type = show ? "text" : "password";
  button.textContent = show ? "HIDE" : "SHOW";
  button.dataset.revealed = show ? "1" : "0";
  button.title = show
    ? `Hide ${label}.`
    : `Reveal ${label}.`;
}

function bindSensitiveFieldToggle(input, button, label = "this sensitive field") {
  if (!input || !button) return;
  setSensitiveFieldVisibility(input, button, false, label);
  button.onclick = () => {
    const revealed = button.dataset.revealed === "1";
    if (!revealed) {
      const ok = window.confirm(
        `Warning: revealing ${label} can expose sensitive data on stream/screen-share.\n\nShow now?`
      );
      if (!ok) return;
    }
    setSensitiveFieldVisibility(input, button, !revealed, label);
  };
}

function collectFixtureForm() {
  const brand = resolveFixtureFormBrand("");
  const modeState = readFixtureModeFields();
  const nextId = el.fxId.value.trim();
  const replaceIdRaw = String(el.fxOriginalId?.value || "").trim();
  // Only send replaceId when this save has an explicit target ID.
  const replaceId = replaceIdRaw && nextId ? replaceIdRaw : "";
  const base = {
    id: nextId || undefined,
    replaceId: replaceId || undefined,
    brand,
    zone: modeState.zone,
    enabled: el.fxEnabled.value === "true",
    controlMode: modeState.controlMode,
    engineBinding: modeState.engineBinding,
    engineEnabled: modeState.engineEnabled,
    twitchEnabled: modeState.twitchEnabled,
    customEnabled: modeState.customEnabled
  };

  if (brand === "hue") {
    return {
      ...base,
      bridgeIp: el.fxBridgeIp.value.trim(),
      username: el.fxUsername.value.trim(),
      lightId: Number(el.fxLightId.value || 1),
      bridgeId: el.fxBridgeId.value.trim(),
      clientKey: el.fxClientKey.value.trim(),
      entertainmentAreaId: el.fxEntertainmentAreaId.value.trim()
    };
  }

  return {
    ...base,
    ip: el.fxWizIp.value.trim()
  };
}

function fillFixtureForm(fixture) {
  if (!fixture) return;
  const rawBrand = String(fixture.brand || "hue").trim().toLowerCase();
  const brand = isBuiltinFixtureBrand(rawBrand)
    ? rawBrand
    : (normalizeFixtureModBrandToken(rawBrand) || "hue");
  if (!isBuiltinFixtureBrand(brand)) {
    const knownSet = new Set(normalizeFixtureModBrandList(ui.fixtureModBrands));
    knownSet.add(brand);
    ui.fixtureModBrands = [...knownSet].sort();
  }
  syncFixtureBrandOptions({ selectValue: brand, customBrand: brand, applyVisibility: false });
  const engineEnabled = isFixtureEngineEnabled(fixture);
  const twitchEnabled = isFixtureTwitchEnabled(fixture);
  const customEnabled = isFixtureCustomEnabled(fixture);
  const controlMode = engineEnabled ? "engine" : "standalone";
  const engineBinding = engineEnabled ? String(fixture.engineBinding || brand) : "standalone";

  el.fxBrand.value = brand;
  if (!isBuiltinFixtureBrand(brand) && el.fxBrand.value !== brand && el.fxModBrandId) {
    el.fxBrand.value = FIXTURE_MOD_CUSTOM_BRAND_VALUE;
    el.fxModBrandId.value = brand;
  } else if (isBuiltinFixtureBrand(brand) && el.fxModBrandId) {
    el.fxModBrandId.value = "";
  }
  el.fxId.value = fixture.id || "";
  if (el.fxOriginalId) el.fxOriginalId.value = fixture.id || "";
  el.fxZone.value = fixture.zone || getCanonicalZoneForBrand(brand, "custom");
  el.fxEnabled.value = fixture.enabled === false ? "false" : "true";
  el.fxEngineEnabled.value = engineEnabled ? "true" : "false";
  el.fxCustomEnabled.value = customEnabled ? "true" : "false";
  el.fxTwitchEnabled.value = twitchEnabled ? "true" : "false";
  el.fxControlMode.value = controlMode;
  el.fxEngineBinding.value = engineBinding;
  el.fxBridgeIp.value = fixture.bridgeIp || "";
  el.fxUsername.value = fixture.username || "";
  el.fxLightId.value = String(fixture.lightId || 1);
  el.fxBridgeId.value = fixture.bridgeId || "";
  el.fxClientKey.value = fixture.clientKey || "";
  el.fxEntertainmentAreaId.value = fixture.entertainmentAreaId || "";
  el.fxWizIp.value = fixture.ip || "";
  setSensitiveFieldVisibility(el.fxBridgeIp, el.fxBridgeIpShowBtn, false, "HUE BRIDGE IP");
  setSensitiveFieldVisibility(el.fxUsername, el.fxUsernameShowBtn, false, "HUE USERNAME");
  setSensitiveFieldVisibility(el.fxClientKey, el.fxClientKeyShowBtn, false, "HUE CLIENT KEY");
  setSensitiveFieldVisibility(el.fxWizIp, el.fxWizIpShowBtn, false, "WIZ IP / MOD TARGET");
  applyFixtureBrandVisibility();
  showTab("fixtures");
}

async function openFixtureEditor(id) {
  const fixtureId = String(id || "").trim();
  if (!fixtureId) return;
  const fx = await getJson("/fixtures");
  const catalog = Array.isArray(fx?.fixtures)
    ? fx.fixtures
    : (Array.isArray(ui.fixturesCatalog) ? ui.fixturesCatalog : []);
  const target = catalog.find(x => String(x.id) === fixtureId);
  if (target) fillFixtureForm(target);
}

async function requestFixtureDelete(id) {
  const fixtureId = String(id || "").trim();
  if (!fixtureId) return { ok: false, status: 0, data: { error: "missing id" } };

  // Prefer POST delete for maximum compatibility, then fallback to DELETE.
  const tryPostBody = await postJson("/fixtures/fixture/delete", { id: fixtureId });
  if (tryPostBody.ok) return tryPostBody;

  const tryPostQuery = await postJson(`/fixtures/fixture/delete?id=${encodeURIComponent(fixtureId)}`, {});
  if (tryPostQuery.ok) return tryPostQuery;

  const tryDelete = await deleteJson(`/fixtures/fixture?id=${encodeURIComponent(fixtureId)}`);
  if (tryDelete.ok) return tryDelete;

  return tryPostBody.status >= tryPostQuery.status ? tryPostBody : tryPostQuery;
}

async function deleteFixtureFromUi(id) {
  const fixtureId = String(id || "").trim();
  if (!fixtureId) return;
  if (!window.confirm(`Delete fixture ${fixtureId}?`)) return;

  const r = await requestFixtureDelete(fixtureId);
  if (!r.ok) {
    const reason = r?.data?.error || `status ${r.status || 0}`;
    setBadge(el.health, "bad", `FIXTURE DELETE FAIL: ${reason}`);
    return;
  }

  setBadge(el.health, "ok", "FIXTURE DELETED");
  const f = await getJson("/fixtures");
  if (f) {
    updateFixtures(f);
    return;
  }

  const nextCatalog = (Array.isArray(ui.fixturesCatalog) ? ui.fixturesCatalog : []).filter(
    item => String(item?.id || "").trim() !== fixtureId
  );
  applyFixtureCatalogToUi(nextCatalog);
}

function renderFixtureRows(fixtures = []) {
  el.fixtureRows.innerHTML = "";
  if (!fixtures.length) {
    const tr = document.createElement("tr");
    const td = document.createElement("td");
    td.colSpan = 8;
    td.textContent = "No fixtures configured.";
    tr.appendChild(td);
    el.fixtureRows.appendChild(tr);
    return;
  }

  for (const f of fixtures) {
    const tr = document.createElement("tr");
    const brandKey = String(f?.brand || "").trim().toLowerCase();
    const target = brandKey === "hue"
      ? `hue light ${f.lightId || "-"}`
      : brandKey === "wiz"
        ? (isFixtureConfiguredForOutput(f) ? "wiz device configured" : "wiz device pending")
        : `${String(f?.brand || "mod").toUpperCase()} target managed by adapter`;

    const rawId = f.id === undefined || f.id === null || f.id === "" ? null : String(f.id);
    const id = rawId || "-";
    const brand = String((f.brand || "-").toUpperCase());
    const zone = String(f.zone || "-");
    const enabled = f.enabled === false ? "false" : "true";
    const engineEnabled = isFixtureEngineEnabled(f);
    const twitchEnabled = isFixtureTwitchEnabled(f);
    const customEnabled = isFixtureCustomEnabled(f);
    const appliedModes = [
      `ENG ${engineEnabled ? "ON" : "OFF"}`,
      `TWITCH ${twitchEnabled ? "ON" : "OFF"}`,
      `CUSTOM ${customEnabled ? "ON" : "OFF"}`
    ].join(" | ");

    const routeParts = [];
    if (engineEnabled) routeParts.push(String(f.engineBinding || f.brand || "-"));
    if (twitchEnabled) routeParts.push("twitch");
    if (customEnabled) routeParts.push("custom");
    const routePath = routeParts.length ? routeParts.join(" + ") : "-";

    const tdId = document.createElement("td");
    tdId.className = "mono";
    tdId.textContent = id;

    const tdBrand = document.createElement("td");
    tdBrand.textContent = brand;

    const tdZone = document.createElement("td");
    tdZone.className = "mono";
    tdZone.textContent = zone;

    const tdMode = document.createElement("td");
    tdMode.className = "mono";
    tdMode.textContent = appliedModes;

    const tdBinding = document.createElement("td");
    tdBinding.className = "mono";
    tdBinding.textContent = routePath;

    const tdTarget = document.createElement("td");
    tdTarget.className = "mono";
    tdTarget.textContent = target;

    const tdEnabled = document.createElement("td");
    tdEnabled.textContent = enabled;

    const tdActions = document.createElement("td");
    tdActions.className = "grid2";

    const editBtn = document.createElement("button");
    editBtn.type = "button";
    editBtn.textContent = "EDIT";
    editBtn.title = "Open this fixture in the editor form above.";
    if (rawId) {
      editBtn.dataset.editId = rawId;
      editBtn.onclick = () => { openFixtureEditor(rawId); };
    } else editBtn.disabled = true;

    const delBtn = document.createElement("button");
    delBtn.type = "button";
    delBtn.className = "bad";
    delBtn.textContent = "DEL";
    delBtn.title = "Delete this fixture from fixtures.config.json.";
    if (rawId) {
      delBtn.dataset.delId = rawId;
      delBtn.onclick = () => { deleteFixtureFromUi(rawId); };
    } else delBtn.disabled = true;

    tdActions.appendChild(editBtn);
    tdActions.appendChild(delBtn);

    tr.appendChild(tdId);
    tr.appendChild(tdBrand);
    tr.appendChild(tdZone);
    tr.appendChild(tdMode);
    tr.appendChild(tdBinding);
    tr.appendChild(tdTarget);
    tr.appendChild(tdEnabled);
    tr.appendChild(tdActions);
    el.fixtureRows.appendChild(tr);
  }
}

function syncStandaloneValueLabels() {
  el.standBrightnessVal.textContent = String(clampInt(el.standBrightness.value, 1, 100, 70));
  el.standHueVal.textContent = String(clampInt(el.standHue.value, 0, 359, 210));
  el.standSatVal.textContent = String(clampInt(el.standSat.value, 0, 100, 80));
  el.standHueMinVal.textContent = String(clampInt(el.standHueMin.value, 0, 359, 0));
  el.standHueMaxVal.textContent = String(clampInt(el.standHueMax.value, 0, 359, 359));
  el.standSatMinVal.textContent = String(clampInt(el.standSatMin.value, 0, 100, 45));
  el.standSatMaxVal.textContent = String(clampInt(el.standSatMax.value, 0, 100, 100));
  el.standCctKelvinVal.textContent = String(clampInt(el.standCctKelvin.value, 2200, 6500, 4000));
  el.standCctMinKelvinVal.textContent = String(clampInt(el.standCctMinKelvin.value, 2200, 6500, 2700));
  el.standCctMaxKelvinVal.textContent = String(clampInt(el.standCctMaxKelvin.value, 2200, 6500, 6500));
  el.standSpeedMinHzVal.textContent = clampNumber(el.standSpeedMinHz.value, 0.2, 12, 0.6).toFixed(1);
  el.standSpeedMaxHzVal.textContent = clampNumber(el.standSpeedMaxHz.value, 0.2, 12, 3.2).toFixed(1);
}

function getFixtureById(id) {
  const key = String(id || "").trim();
  if (!key) return null;
  return ui.fixturesCatalog.find(f => String(f.id) === key) || null;
}

function getFixtureRouteFlags(fixture) {
  return {
    engineEnabled: isFixtureEngineEnabled(fixture || {}),
    twitchEnabled: isFixtureTwitchEnabled(fixture || {}),
    customEnabled: isFixtureCustomEnabled(fixture || {})
  };
}

function summarizeRouteFlags(flags = {}) {
  const active = [];
  if (flags.engineEnabled) active.push("engine");
  if (flags.twitchEnabled) active.push("twitch");
  if (flags.customEnabled) active.push("custom");
  return active.length ? active.join("+") : "none";
}

function getFixtureConnectivityRecord(id) {
  const key = String(id || "").trim();
  if (!key) return null;
  return ui.fixtureConnectivityById[key] || null;
}

function getConnectivityStatusLabel(fixture, record) {
  const brand = String(fixture?.brand || "").trim().toLowerCase();
  if (!record) {
    if (brand !== "hue" && brand !== "wiz") return "MOD-BRAND (ADAPTER OWNED)";
    return "CHECK PENDING";
  }

  const status = String(record.status || "").trim().toLowerCase();
  if (status === "reachable") return "TARGET READY";
  if (status === "unreachable") return "TARGET UNREACHABLE";
  if (status === "not_configured") return "TARGET NOT CONFIGURED";
  if (status === "skipped") return "MOD-BRAND (ADAPTER OWNED)";
  if (status === "pending") return "CHECK PENDING";
  return "TARGET UNKNOWN";
}

function maskHostForDisplay(hostValue) {
  const raw = String(hostValue || "").trim();
  if (!raw) return "-";

  const bracketIpv6WithPort = raw.match(/^\[([^\]]+)\]:(\d{1,5})$/);
  if (bracketIpv6WithPort) {
    return `[${String(bracketIpv6WithPort[1] || "").slice(0, 2)}***]:${bracketIpv6WithPort[2]}`;
  }

  const ipv4WithPort = raw.match(/^(\d{1,3}(?:\.\d{1,3}){3}):(\d{1,5})$/);
  if (ipv4WithPort) {
    const parts = ipv4WithPort[1].split(".");
    return `${parts[0]}.***.***.${parts[3]}:${ipv4WithPort[2]}`;
  }

  const ipv4Only = raw.match(/^(\d{1,3})(?:\.(\d{1,3})){3}$/);
  if (ipv4Only) {
    const parts = raw.split(".");
    return `${parts[0]}.***.***.${parts[3]}`;
  }

  const hostWithPort = raw.match(/^([^:]+):(\d{1,5})$/);
  if (hostWithPort) {
    const host = String(hostWithPort[1] || "").trim();
    const maskedHost = host.length <= 2
      ? `${host.slice(0, 1)}*`
      : `${host.slice(0, 2)}***${host.slice(-1)}`;
    return `${maskedHost}:${hostWithPort[2]}`;
  }

  if (raw.startsWith("[") && raw.endsWith("]")) {
    const core = raw.slice(1, -1);
    return `[${core.slice(0, 2)}***]`;
  }

  if (raw.length <= 2) return `${raw.slice(0, 1)}*`;
  return `${raw.slice(0, 2)}***${raw.slice(-1)}`;
}

function renderSelectedFixtureConnectivityStatus(fixture) {
  if (!fixture) {
    el.standConnectivityStatus.value = "No fixture selected.";
    return;
  }

  const record = getFixtureConnectivityRecord(fixture.id);
  const host = String(record?.host || "").trim() || (fixture.brand === "hue"
    ? String(fixture.bridgeIp || "").trim()
    : String(fixture.ip || "").trim()) || "-";
  const maskedHost = maskHostForDisplay(host);
  const label = getConnectivityStatusLabel(fixture, record);
  const detail = String(record?.detail || "").trim();
  const checkedAt = Number(record?.checkedAt || 0) > 0
    ? new Date(Number(record.checkedAt)).toLocaleTimeString()
    : "-";
  el.standConnectivityStatus.value = `${fixture.id} | ${label} | host ${maskedHost} | ${detail || "no detail"} | checked ${checkedAt}`;
}

function updateConnectivityCache(entries, options = {}) {
  const merge = options && options.merge === true;
  const next = merge ? { ...ui.fixtureConnectivityById } : {};
  for (const entry of (Array.isArray(entries) ? entries : [])) {
    const id = String(entry?.id || "").trim();
    if (!id) continue;
    next[id] = entry;
  }
  ui.fixtureConnectivityById = next;
}

function normalizeStandaloneMode(value) {
  const mode = String(value || "").trim().toLowerCase();
  if (mode === "rgb" || mode === "scene" || mode === "auto") return mode;
  return "scene";
}

function normalizeStandaloneScene(value) {
  const scene = String(value || "").trim().toLowerCase();
  if (scene === "sweep" || scene === "bounce" || scene === "pulse" || scene === "spark") return scene;
  return "sweep";
}

function normalizeStandaloneSpeedMode(value) {
  const mode = String(value || "").trim().toLowerCase();
  if (mode === "fixed" || mode === "audio") return mode;
  return "fixed";
}

function normalizeStandaloneColorMode(value) {
  const mode = String(value || "").trim().toLowerCase();
  if (mode === "hsv" || mode === "cct") return mode;
  return "hsv";
}

function setStandaloneToggleState(node, enabled, labels = {}) {
  if (!node) return;
  const on = Boolean(enabled);
  const onLabel = String(labels.on || "ON");
  const offLabel = String(labels.off || "OFF");
  node.dataset.on = on ? "true" : "false";
  node.setAttribute("aria-pressed", on ? "true" : "false");
  node.classList.toggle("active", on);
  node.textContent = on ? onLabel : offLabel;
}

function getStandaloneToggleState(node) {
  return node?.dataset?.on === "true";
}

function resolveStandaloneModeForFixture(entry) {
  const id = String(entry?.id || ui.standaloneSelectedId || "").trim();
  const stored = id ? ui.standaloneModeByFixture[id] : "";
  if (stored === "rgb" || stored === "scene" || stored === "auto") return stored;
  const explicitRaw = String(entry?.state?.mode || "").trim().toLowerCase();
  const explicit = normalizeStandaloneMode(explicitRaw);
  if (explicitRaw && (explicit === "rgb" || explicit === "scene" || explicit === "auto")) return explicit;
  return entry?.state?.animate ? "scene" : "rgb";
}

function getAutoStandaloneHz() {
  const bpm = Number(ui.lastBpm || 0);
  if (!Number.isFinite(bpm) || bpm <= 0) return 1.2;
  return clampNumber(bpm / 90, 0.4, 8, 1.2);
}

function syncStandaloneModeUi(options = {}) {
  const mode = normalizeStandaloneMode(el.standMode.value);
  const enabled = options.enabled !== false;
  const fixtureId = String(el.standFixtureSelect.value || "").trim();
  const isRgb = mode === "rgb";
  const isAuto = mode === "auto";
  const staticOn = getStandaloneToggleState(el.standStaticBtn);
  const speedMode = normalizeStandaloneSpeedMode(el.standSpeedMode.value);
  const colorMode = normalizeStandaloneColorMode(el.standColorMode.value);
  const useAudioSpeed = speedMode === "audio" && !isRgb && !isAuto && !staticOn;

  el.standMode.value = mode;
  el.standScene.value = normalizeStandaloneScene(el.standScene.value);
  el.standSpeedMode.value = speedMode;
  el.standColorMode.value = colorMode;
  el.standAnimate.value = isRgb ? "false" : "true";

  if (isAuto) {
    const autoHz = getAutoStandaloneHz();
    el.standSpeedHz.value = String(Number(autoHz.toFixed(2)));
  }

  el.standMode.disabled = !enabled;
  el.standScene.disabled = !enabled || isRgb;
  el.standSpeedMode.disabled = !enabled || isRgb || isAuto || staticOn;
  el.standSpeedHz.disabled = !enabled || isRgb || isAuto || staticOn || useAudioSpeed;
  el.standSpeedMinHz.disabled = !enabled || !useAudioSpeed;
  el.standSpeedMaxHz.disabled = !enabled || !useAudioSpeed;
  el.standColorMode.disabled = !enabled;
  el.standStaticBtn.disabled = !enabled || isRgb;
  el.standRaveStartBtn.disabled = !enabled;
  el.standRaveStopBtn.disabled = !enabled;
  el.standSpeedHz.title = isRgb
    ? "RGB STATIC mode does not animate."
    : (isAuto
      ? "AUTO HZ follows live BPM telemetry."
      : (staticOn
        ? "STATIC is on, so speed is frozen."
        : (useAudioSpeed
          ? "Audio-reactive speed uses MIN/MAX sliders."
          : "Scene speed in Hz.")));

  if (Number(el.standSpeedMinHz.value) > Number(el.standSpeedMaxHz.value)) {
    el.standSpeedMaxHz.value = String(el.standSpeedMinHz.value);
  }
  if (Number(el.standHueMin.value) > Number(el.standHueMax.value)) {
    el.standHueMax.value = String(el.standHueMin.value);
  }
  if (Number(el.standSatMin.value) > Number(el.standSatMax.value)) {
    el.standSatMax.value = String(el.standSatMin.value);
  }
  if (Number(el.standCctMinKelvin.value) > Number(el.standCctMaxKelvin.value)) {
    el.standCctMaxKelvin.value = String(el.standCctMinKelvin.value);
  }

  const showCct = colorMode === "cct";
  el.standHsvSingleWrap.classList.toggle("hidden", showCct);
  el.standHsvRangeRow.classList.toggle("hidden", showCct);
  el.standCctRangeRow.classList.toggle("hidden", !showCct);
  el.standHue.disabled = !enabled || showCct;
  el.standSat.disabled = !enabled || showCct;
  el.standHueMin.disabled = !enabled || showCct;
  el.standHueMax.disabled = !enabled || showCct;
  el.standSatMin.disabled = !enabled || showCct;
  el.standSatMax.disabled = !enabled || showCct;
  el.standCctKelvin.disabled = !enabled || !showCct;
  el.standCctMinKelvin.disabled = !enabled || !showCct;
  el.standCctMaxKelvin.disabled = !enabled || !showCct;

  syncStandaloneValueLabels();

  if (fixtureId) {
    ui.standaloneModeByFixture[fixtureId] = mode;
  }
}

function setCustomClusterVisible(visible) {
  el.standCustomCluster.classList.toggle("hidden", !visible);
}

function setRouteChipState(node, enabled) {
  if (!node) return;
  const on = Boolean(enabled);
  node.dataset.on = on ? "true" : "false";
  node.classList.toggle("active", on);
  node.setAttribute("aria-pressed", on ? "true" : "false");
}

function getRouteChipState(node) {
  return node?.dataset?.on === "true";
}

function clearRouteDraftState() {
  ui.routeDraftDirty = false;
  ui.routeDraftFixtureId = "";
  ui.routeDraftFlags = null;
}

function clearStandaloneDraftState() {
  ui.standaloneDraftDirty = false;
  ui.standaloneDraftFixtureId = "";
  ui.standaloneDraftTouchedAt = 0;
}

function hasStandaloneDraftForFixture(id) {
  const fixtureId = String(id || "").trim();
  if (!fixtureId) return false;
  if (!ui.standaloneDraftDirty) return false;
  return String(ui.standaloneDraftFixtureId || "") === fixtureId;
}

function markStandaloneDraftDirty() {
  const fixtureId = String(el.standFixtureSelect?.value || ui.standaloneSelectedId || "").trim();
  if (!fixtureId) return;
  ui.standaloneDraftDirty = true;
  ui.standaloneDraftFixtureId = fixtureId;
  ui.standaloneDraftTouchedAt = Date.now();
  refreshStandaloneDraftStatus();
}

function setRouteDraftStateFromCurrentChips() {
  const id = String(el.standFixtureSelect.value || "").trim();
  if (!id) {
    clearRouteDraftState();
    return;
  }

  ui.routeDraftDirty = true;
  ui.routeDraftFixtureId = id;
  ui.routeDraftFlags = {
    engineEnabled: getRouteChipState(el.standRouteEngine),
    twitchEnabled: getRouteChipState(el.standRouteTwitch),
    customEnabled: getRouteChipState(el.standRouteCustom)
  };
}

function getRouteDraftFlagsForFixture(id) {
  const fixtureId = String(id || "").trim();
  if (!fixtureId || !ui.routeDraftDirty) return null;
  if (String(ui.routeDraftFixtureId || "") !== fixtureId) return null;
  const flags = ui.routeDraftFlags && typeof ui.routeDraftFlags === "object"
    ? ui.routeDraftFlags
    : null;
  if (!flags) return null;
  return {
    engineEnabled: flags.engineEnabled === true,
    twitchEnabled: flags.twitchEnabled === true,
    customEnabled: flags.customEnabled === true
  };
}

function toggleRouteChip(node) {
  if (!node) return;
  setRouteChipState(node, !getRouteChipState(node));
}

function enforceRouteToggleConstraints(options = {}) {
  const source = String(options.source || "").trim().toLowerCase();
  let engineOn = getRouteChipState(el.standRouteEngine);
  let customOn = getRouteChipState(el.standRouteCustom);

  if (engineOn && customOn) {
    if (source === "custom") {
      // Last user action wins: enabling CUSTOM turns ENGINE off.
      setRouteChipState(el.standRouteEngine, false);
      engineOn = false;
      setBadge(el.health, "warn", "ENGINE DISABLED (CUSTOM ENABLED)");
    } else {
      // Default/fallback behavior keeps ENGINE and turns CUSTOM off.
      setRouteChipState(el.standRouteCustom, false);
      customOn = false;
      if (source === "engine") {
        setBadge(el.health, "warn", "CUSTOM DISABLED (ENGINE ENABLED)");
      }
    }
  }

  el.standRouteCustom.disabled = false;
  el.standRouteCustom.title = engineOn
    ? "Enable CUSTOM to take control and automatically disable ENGINE."
    : "Enable standalone custom control for this fixture.";

  setCustomClusterVisible(customOn);
}

function setStandaloneControlEnabled(enabled) {
  const isEnabled = Boolean(enabled);
  [
    el.standPower,
    el.standMode,
    el.standScene,
    el.standAnimate,
    el.standSpeedMode,
    el.standBrightness,
    el.standHue,
    el.standHueMin,
    el.standHueMax,
    el.standSat,
    el.standSatMin,
    el.standSatMax,
    el.standCctKelvin,
    el.standCctMinKelvin,
    el.standCctMaxKelvin,
    el.standSpeedHz,
    el.standSpeedMinHz,
    el.standSpeedMaxHz,
    el.standColorMode,
    el.standStaticBtn,
    el.standRaveStartBtn,
    el.standRaveStopBtn,
    el.standTransitionMs,
    el.standApplyBtn
  ].forEach(node => {
    node.disabled = !isEnabled;
  });
  syncStandaloneModeUi({ enabled: isEnabled });
}

function initCustomControlTabMount() {
  if (!el.customStandaloneMount || !el.standCustomCluster) return;
  if (el.standCustomCluster.parentElement !== el.customStandaloneMount) {
    el.customStandaloneMount.appendChild(el.standCustomCluster);
  }
}

function renderCustomFixtureSelector(fixtures = []) {
  if (!el.customFixtureSelect) return;
  const catalog = (Array.isArray(fixtures) ? fixtures : [])
    .filter(fixture => fixture && isFixtureCustomEnabled(fixture));
  const previous = String(
    el.customFixtureSelect.value ||
    (isFixtureCustomEnabled(getFixtureById(ui.standaloneSelectedId)) ? ui.standaloneSelectedId : "")
  ).trim();

  el.customFixtureSelect.innerHTML = "";
  const placeholder = document.createElement("option");
  placeholder.value = "";
  placeholder.textContent = catalog.length
    ? "select custom fixture"
    : "no fixtures routed as CUSTOM";
  el.customFixtureSelect.appendChild(placeholder);

  for (const fixture of catalog) {
    const id = String(fixture?.id || "").trim();
    if (!id) continue;
    const option = document.createElement("option");
    const brand = String(fixture.brand || "").toUpperCase();
    const zone = String(
      fixture.zone ||
      (String(fixture.brand || "").trim().toLowerCase() === "hue" ? "hue" : "wiz")
    );
    option.value = id;
    option.textContent = `${id} | ${brand} | ${zone}`;
    el.customFixtureSelect.appendChild(option);
  }

  const hasPrevious = previous && catalog.some(fixture => String(fixture.id) === previous);
  el.customFixtureSelect.value = hasPrevious ? previous : String(catalog[0]?.id || "");
}

function syncCustomFixtureSelectorFromCurrentSelection() {
  if (!el.customFixtureSelect) return;
  const selectedId = String(ui.standaloneSelectedId || "").trim();
  if (!selectedId) return;
  const fixture = getFixtureById(selectedId);
  if (!fixture || !isFixtureCustomEnabled(fixture)) return;
  const option = Array.from(el.customFixtureSelect.options).find(opt => opt.value === selectedId);
  if (!option) return;
  el.customFixtureSelect.value = selectedId;
}

function applyCustomFixtureSelectionFromTab(options = {}) {
  const selectedId = String(el.customFixtureSelect?.value || "").trim();
  if (!selectedId) {
    clearStandaloneDraftState();
    setCustomClusterVisible(false);
    applyStandaloneEntryToControls(null);
    if (options.notify) {
      setBadge(el.health, "warn", "NO CUSTOM FIXTURE ROUTED");
    }
    return false;
  }

  el.standFixtureSelect.value = selectedId;
  syncRouteSelectionUi();
  if (options.notify) {
    setBadge(el.health, "ok", `CUSTOM FIXTURE ${selectedId}`);
  }
  return true;
}

function renderRouteFixtureOptions(fixtures = []) {
  const previous = String(ui.standaloneSelectedId || el.standFixtureSelect.value || "").trim();
  const optionsCatalog = Array.isArray(fixtures) ? fixtures.slice() : [];

  el.standFixtureSelect.innerHTML = "";
  const placeholder = document.createElement("option");
  placeholder.value = "";
  placeholder.textContent = "select fixture";
  el.standFixtureSelect.appendChild(placeholder);

  for (const fixture of optionsCatalog) {
    const id = String(fixture?.id || "").trim();
    if (!id) continue;
    const option = document.createElement("option");
    const brand = String(fixture.brand || "").toUpperCase();
    const brandKey = String(fixture.brand || "").trim().toLowerCase();
    const zone = String(
      fixture.zone ||
      (brandKey === "hue" ? "hue" : (brandKey === "wiz" ? "wiz" : "custom"))
    );
    const customWord = isFixtureCustomEnabled(fixture) ? "custom:on" : "custom:off";
    option.value = id;
    option.textContent = `${id} | ${brand} | ${zone} | ${customWord}`;
    el.standFixtureSelect.appendChild(option);
  }

  const hasPrevious = previous && optionsCatalog.some(f => String(f.id) === previous);
  ui.standaloneSelectedId = hasPrevious ? previous : "";
  el.standFixtureSelect.value = ui.standaloneSelectedId;
  renderCustomFixtureSelector(ui.fixturesCatalog);
  syncRouteSelectionUi();
}

function getStandaloneEntryById(id) {
  const key = String(id || "").trim();
  if (!key) return null;
  return ui.standaloneFixtures.find(f => String(f.id) === key) || null;
}

function renderRouteDraftStatus(fixture) {
  if (!fixture) return;
  const currentFlags = {
    engineEnabled: getRouteChipState(el.standRouteEngine),
    twitchEnabled: getRouteChipState(el.standRouteTwitch),
    customEnabled: getRouteChipState(el.standRouteCustom)
  };
  const statusWord = getRouteDraftFlagsForFixture(fixture.id) ? "DRAFT" : "APPLIED";
  const connectivityRecord = getFixtureConnectivityRecord(fixture.id);
  const configuredWord = connectivityRecord
    ? getConnectivityStatusLabel(fixture, connectivityRecord)
    : (isFixtureConfiguredForOutput(fixture) ? "TARGET CONFIGURED" : "TARGET NOT CONFIGURED");
  const savedAtText = ui.routeLastSavedAt
    ? new Date(ui.routeLastSavedAt).toLocaleTimeString()
    : "-";
  const brandKey = String(fixture.brand || "").trim().toLowerCase();
  const zone = String(
    fixture.zone ||
    (brandKey === "hue" ? "hue" : (brandKey === "wiz" ? "wiz" : "custom"))
  );
  el.standRouteStatus.value =
    `${fixture.id} | zone ${zone} | ` +
    `modes ${summarizeRouteFlags(currentFlags).toUpperCase()} | ${statusWord} | ${configuredWord} | last save ${savedAtText}`;
  renderSelectedFixtureConnectivityStatus(fixture);
}

function applyStandaloneEntryToControls(entry) {
  if (!entry || !entry.state) {
    el.standPower.value = "true";
    el.standMode.value = "rgb";
    el.standScene.value = "sweep";
    el.standAnimate.value = "false";
    el.standSpeedMode.value = "fixed";
    el.standSpeedHz.value = "1.2";
    el.standSpeedMinHz.value = "0.6";
    el.standSpeedMaxHz.value = "3.2";
    el.standBrightness.value = "70";
    el.standHue.value = "210";
    el.standHueMin.value = "0";
    el.standHueMax.value = "359";
    el.standSat.value = "80";
    el.standSatMin.value = "45";
    el.standSatMax.value = "100";
    el.standColorMode.value = "hsv";
    el.standCctKelvin.value = "4000";
    el.standCctMinKelvin.value = "2700";
    el.standCctMaxKelvin.value = "6500";
    setStandaloneToggleState(el.standStaticBtn, false, { on: "STATIC ON", off: "STATIC OFF" });
    setStandaloneToggleState(el.standRaveStartBtn, false, { on: "RAVE-START UPDATE ON", off: "RAVE-START UPDATE OFF" });
    setStandaloneToggleState(el.standRaveStopBtn, false, { on: "RAVE-END UPDATE ON", off: "RAVE-END UPDATE OFF" });
    el.standTransitionMs.value = "350";
    syncStandaloneValueLabels();
    setStandaloneControlEnabled(false);
    el.standStatus.value = "No standalone fixture selected.";
    return;
  }

  const state = entry.state || {};
  const mode = resolveStandaloneModeForFixture(entry);
  el.standPower.value = state.on === false ? "false" : "true";
  el.standMode.value = mode;
  el.standScene.value = normalizeStandaloneScene(state.scene);
  el.standAnimate.value = mode === "rgb" ? "false" : "true";
  el.standSpeedMode.value = normalizeStandaloneSpeedMode(state.speedMode);
  el.standSpeedHz.value = String(clampNumber(state.speedHz, 0.2, 12, 1.2));
  el.standSpeedMinHz.value = String(clampNumber(state.speedHzMin, 0.2, 12, 0.6));
  el.standSpeedMaxHz.value = String(clampNumber(state.speedHzMax, 0.2, 12, 3.2));
  el.standBrightness.value = String(clampInt(state.bri, 1, 100, 70));
  el.standHue.value = String(clampInt(state.hue, 0, 359, 210));
  el.standHueMin.value = String(clampInt(state.hueMin, 0, 359, 0));
  el.standHueMax.value = String(clampInt(state.hueMax, 0, 359, 359));
  el.standSat.value = String(clampInt(state.sat, 0, 100, 80));
  el.standSatMin.value = String(clampInt(state.satMin, 0, 100, 45));
  el.standSatMax.value = String(clampInt(state.satMax, 0, 100, 100));
  el.standColorMode.value = normalizeStandaloneColorMode(state.colorMode);
  el.standCctKelvin.value = String(clampInt(state.cctKelvin, 2200, 6500, 4000));
  el.standCctMinKelvin.value = String(clampInt(state.cctMinKelvin, 2200, 6500, 2700));
  el.standCctMaxKelvin.value = String(clampInt(state.cctMaxKelvin, 2200, 6500, 6500));
  setStandaloneToggleState(el.standStaticBtn, state.static === true, { on: "STATIC ON", off: "STATIC OFF" });
  setStandaloneToggleState(el.standRaveStartBtn, state.updateOnRaveStart === true, { on: "RAVE-START UPDATE ON", off: "RAVE-START UPDATE OFF" });
  setStandaloneToggleState(el.standRaveStopBtn, state.updateOnRaveStop === true, { on: "RAVE-END UPDATE ON", off: "RAVE-END UPDATE OFF" });
  el.standTransitionMs.value = String(clampInt(state.transitionMs, 0, 10000, 350));
  syncStandaloneValueLabels();
  const supportsStandaloneUi = entry.brand === "hue" || entry.brand === "wiz";
  const controlsEnabled = entry.enabled !== false && supportsStandaloneUi;
  setStandaloneControlEnabled(controlsEnabled);
  syncStandaloneModeUi({ enabled: controlsEnabled });

  const brand = String(entry.brand || "").toUpperCase();
  const zone = String(entry.zone || "-");
  const sceneWord = normalizeStandaloneScene(state.scene).toUpperCase();
  const colorWord = normalizeStandaloneColorMode(state.colorMode).toUpperCase();
  const staticWord = state.static ? "static" : (entry.animating ? "animating" : "ready");
  const startWord = state.updateOnRaveStart ? "start:on" : "start:off";
  const stopWord = state.updateOnRaveStop ? "stop:on" : "stop:off";
  const stateWord = entry.enabled === false ? "disabled" : `${staticWord} | scene ${sceneWord} | ${colorWord} | ${startWord} | ${stopWord}`;
  if (!supportsStandaloneUi) {
    el.standStatus.value = `${entry.id} | ${brand} | zone ${zone} | mode ${mode.toUpperCase()} | standalone UI unsupported for this brand (use mod actions)`;
    return;
  }
  el.standStatus.value = `${entry.id} | ${brand} | zone ${zone} | mode ${mode.toUpperCase()} | ${stateWord}`;
}

function syncRouteSelectionUi() {
  const selectedId = String(el.standFixtureSelect.value || "").trim();
  const previousSelectedId = String(ui.standaloneSelectedId || "").trim();
  if (previousSelectedId && previousSelectedId !== selectedId) {
    clearStandaloneDraftState();
  }
  if (ui.routeDraftDirty && ui.routeDraftFixtureId && ui.routeDraftFixtureId !== selectedId) {
    clearRouteDraftState();
  }
  ui.standaloneSelectedId = selectedId;
  const fixture = getFixtureById(selectedId);
  if (!fixture) {
    clearRouteDraftState();
    clearStandaloneDraftState();
    el.standRouteStatus.value = "Select a fixture, choose ENGINE/TWITCH/CUSTOM, then click APPLY ROUTING.";
    el.standConnectivityStatus.value = "No fixture selected.";
    setRouteChipState(el.standRouteEngine, false);
    setRouteChipState(el.standRouteTwitch, false);
    setRouteChipState(el.standRouteCustom, false);
    enforceRouteToggleConstraints();
    setCustomClusterVisible(false);
    applyStandaloneEntryToControls(null);
    return;
  }

  const flags = getRouteDraftFlagsForFixture(fixture.id) || getFixtureRouteFlags(fixture);
  setRouteChipState(el.standRouteEngine, flags.engineEnabled);
  setRouteChipState(el.standRouteTwitch, flags.twitchEnabled);
  setRouteChipState(el.standRouteCustom, flags.customEnabled);
  enforceRouteToggleConstraints();

  const currentFlags = {
    engineEnabled: getRouteChipState(el.standRouteEngine),
    twitchEnabled: getRouteChipState(el.standRouteTwitch),
    customEnabled: getRouteChipState(el.standRouteCustom)
  };
  renderRouteDraftStatus(fixture);

  const showCustom = currentFlags.customEnabled;
  setCustomClusterVisible(showCustom);
  if (!showCustom) {
    clearStandaloneDraftState();
    applyStandaloneEntryToControls(null);
    syncCustomFixtureSelectorFromCurrentSelection();
    return;
  }

  const standaloneEntry = getStandaloneEntryById(fixture.id);
  if (hasStandaloneDraftForFixture(fixture.id)) {
    refreshStandaloneDraftStatus();
  } else {
    applyStandaloneEntryToControls(standaloneEntry);
  }
  syncCustomFixtureSelectorFromCurrentSelection();
}

function renderStandaloneFixtures(entries = [], options = {}) {
  const preserveDraft = options && options.preserveDraft === true;
  const safeEntries = Array.isArray(entries) ? entries : [];
  ui.standaloneFixtures = safeEntries.slice();

  if (!preserveDraft) {
    syncRouteSelectionUi();
    return;
  }

  const fixture = getFixtureById(ui.standaloneSelectedId);
  const customEnabled = getRouteChipState(el.standRouteCustom);
  if (customEnabled && fixture) {
    const selected = getStandaloneEntryById(ui.standaloneSelectedId);
    if (selected && !hasStandaloneDraftForFixture(ui.standaloneSelectedId)) {
      applyStandaloneEntryToControls(selected);
    } else if (selected) {
      refreshStandaloneDraftStatus();
    }
  }
}

function collectStandaloneStateFromControls() {
  const fixtureId = String(el.standFixtureSelect.value || "").trim();
  const mode = normalizeStandaloneMode(el.standMode.value);
  const scene = normalizeStandaloneScene(el.standScene.value);
  const speedMode = normalizeStandaloneSpeedMode(el.standSpeedMode.value);
  const colorMode = normalizeStandaloneColorMode(el.standColorMode.value);
  const staticOn = getStandaloneToggleState(el.standStaticBtn);
  const updateOnRaveStart = getStandaloneToggleState(el.standRaveStartBtn);
  const updateOnRaveStop = getStandaloneToggleState(el.standRaveStopBtn);
  if (fixtureId) {
    ui.standaloneModeByFixture[fixtureId] = mode;
  }
  const sceneHz = clampNumber(el.standSpeedHz.value, 0.2, 12, 1.2);
  const autoHz = getAutoStandaloneHz();
  const animate = mode !== "rgb";
  const speedHz = mode === "auto" ? autoHz : sceneHz;

  return {
    on: el.standPower.value === "true",
    animate,
    static: staticOn,
    updateOnRaveStart,
    updateOnRaveStop,
    speedHz,
    speedMode,
    speedHzMin: clampNumber(el.standSpeedMinHz.value, 0.2, 12, 0.6),
    speedHzMax: clampNumber(el.standSpeedMaxHz.value, 0.2, 12, 3.2),
    mode,
    scene,
    bri: clampInt(el.standBrightness.value, 1, 100, 70),
    hue: clampInt(el.standHue.value, 0, 359, 210),
    hueMin: clampInt(el.standHueMin.value, 0, 359, 0),
    hueMax: clampInt(el.standHueMax.value, 0, 359, 359),
    sat: clampInt(el.standSat.value, 0, 100, 80),
    satMin: clampInt(el.standSatMin.value, 0, 100, 45),
    satMax: clampInt(el.standSatMax.value, 0, 100, 100),
    colorMode,
    cctKelvin: clampInt(el.standCctKelvin.value, 2200, 6500, 4000),
    cctMinKelvin: clampInt(el.standCctMinKelvin.value, 2200, 6500, 2700),
    cctMaxKelvin: clampInt(el.standCctMaxKelvin.value, 2200, 6500, 6500),
    transitionMs: clampInt(el.standTransitionMs.value, 0, 10000, 350)
  };
}

async function refreshStandaloneFixtures() {
  const snapshot = await getJson("/fixtures/standalone");
  if (!snapshot || !snapshot.ok || !Array.isArray(snapshot.fixtures)) {
    return false;
  }
  renderStandaloneFixtures(snapshot.fixtures, { preserveDraft: true });
  return true;
}

async function testFixtureConnectivity() {
  const fixtureId = String(el.standFixtureSelect.value || "").trim();
  const fixture = getFixtureById(fixtureId);
  if (!fixture) {
    setBadge(el.health, "warn", "SELECT FIXTURE");
    return false;
  }

  el.standConnectivityStatus.value = `${fixtureId} | CHECKING CONNECTIVITY...`;
  const response = await postJson("/fixtures/connectivity/test", { id: fixtureId, timeoutMs: 1200 });
  if (!response.ok || !response.data?.ok) {
    const reason = response.data?.error || "connectivity test failed";
    setBadge(el.health, "bad", `CONNECTIVITY FAIL: ${reason}`);
    el.standConnectivityStatus.value = `${fixtureId} | TARGET UNKNOWN | ${reason}`;
    return false;
  }

  updateConnectivityCache(response.data.results || [], { merge: true });
  ui.connectivitySummary = response.data.summary || null;
  const record = getFixtureConnectivityRecord(fixtureId);
  renderSelectedFixtureConnectivityStatus(fixture);
  renderRouteDraftStatus(fixture);

  const status = String(record?.status || "").trim().toLowerCase();
  if (status === "reachable") {
    setBadge(el.health, "ok", "CONNECTIVITY OK");
  } else if (status === "unreachable") {
    setBadge(el.health, "warn", "TARGET UNREACHABLE");
  } else if (status === "not_configured") {
    setBadge(el.health, "warn", "TARGET NOT CONFIGURED");
  } else if (status === "skipped") {
    setBadge(el.health, "ok", "MOD BRAND CONNECTIVITY BY ADAPTER");
  } else {
    setBadge(el.health, "warn", "CONNECTIVITY UNKNOWN");
  }
  return status === "reachable";
}

async function applyFixtureRouteMode() {
  const id = String(el.standFixtureSelect.value || "").trim();
  const fixture = getFixtureById(id);
  if (!fixture) {
    setBadge(el.health, "warn", "SELECT FIXTURE");
    return;
  }

  const engineEnabled = getRouteChipState(el.standRouteEngine);
  const twitchEnabled = getRouteChipState(el.standRouteTwitch);
  let customEnabled = getRouteChipState(el.standRouteCustom);
  if (engineEnabled && customEnabled) {
    customEnabled = false;
    setRouteChipState(el.standRouteCustom, false);
  }
  if (!engineEnabled && !twitchEnabled && !customEnabled) {
    setBadge(el.health, "warn", "ENABLE AT LEAST ONE MODE");
    return;
  }

  const brand = String(fixture.brand || "").trim().toLowerCase();
  if (!isValidFixtureBrand(brand)) {
    setBadge(el.health, "bad", "INVALID FIXTURE BRAND");
    return;
  }

  const next = {
    ...fixture,
    controlMode: engineEnabled ? "engine" : "standalone",
    engineBinding: engineEnabled ? brand : "standalone",
    engineEnabled,
    twitchEnabled,
    customEnabled
  };

  setRouteDraftStateFromCurrentChips();
  const save = await postJson("/fixtures/fixture", next);
  if (!save.ok || !save.data?.ok) {
    setBadge(el.health, "bad", `ROUTING SAVE FAIL: ${save.data?.error || "invalid payload"}`);
    return;
  }

  ui.routeLastSavedAt = Date.now();
  setBadge(el.health, "ok", "ROUTING SAVED");

  const f = await getJson("/fixtures");
  clearRouteDraftState();
  if (f) updateFixtures(f);
}

async function applyStandaloneState() {
  const id = String(el.standFixtureSelect.value || "").trim();
  if (!id) {
    setBadge(el.health, "warn", "SELECT FIXTURE");
    return;
  }

  if (!getRouteChipState(el.standRouteCustom)) {
    setBadge(el.health, "warn", "CUSTOM MODE MUST BE ON");
    return;
  }

  const payload = {
    id,
    state: collectStandaloneStateFromControls()
  };
  const r = await postJson("/fixtures/standalone/state", payload);
  if (!r.ok || !r.data?.ok) {
    const errText = r.data?.error || "apply failed";
    setBadge(el.health, "bad", `STANDALONE APPLY FAIL: ${errText}`);
    return;
  }

  const returned = r.data.fixture || null;
  if (returned && returned.id) {
    const idx = ui.standaloneFixtures.findIndex(f => String(f.id) === String(returned.id));
    if (idx >= 0) ui.standaloneFixtures[idx] = returned;
    else ui.standaloneFixtures.push(returned);
    clearStandaloneDraftState();
    renderStandaloneFixtures(ui.standaloneFixtures, { preserveDraft: true });
    ui.standaloneSelectedId = String(returned.id);
    el.standFixtureSelect.value = ui.standaloneSelectedId;
    applyStandaloneEntryToControls(returned);
  }

  setBadge(el.health, "ok", "STANDALONE APPLIED");
}

el.apiBaseSaveBtn.onclick = async () => {
  const nextBase = normalizeApiBaseInput(el.apiBaseInput.value);
  setApiBase(nextBase);
  setBadge(el.health, "ok", nextBase ? "API BASE SAVED" : "API BASE CLEARED");
  await poll({ force: true });
};

el.apiBaseResetBtn.onclick = async () => {
  setApiBase(inferredApiBase);
  setBadge(el.health, "ok", "API BASE RESET");
  await poll({ force: true });
};

if (el.systemSettingsSaveBtn) {
  el.systemSettingsSaveBtn.onclick = async () => {
    const { pollingChanged } = saveSystemSettingsFromUi();
    const savedServer = await saveSystemServerSettingsFromUi();
    if (!savedServer.ok) {
      setBadge(el.health, "warn", `SYSTEM SETTINGS SAVED (SERVER CONFIG FAIL: ${savedServer.error || "request failed"})`);
    } else {
      setBadge(el.health, "ok", "SYSTEM SETTINGS SAVED");
    }
    if (!ui.pollPaused) {
      await poll({ force: true });
    } else if (pollingChanged) {
      renderSystemSettingsStatus();
    }
  };
}

if (el.systemSettingsResetBtn) {
  el.systemSettingsResetBtn.onclick = async () => {
    resetSystemSettingsToDefaults();
    const savedServer = await saveSystemServerSettingsFromUi();
    setBadge(
      el.health,
      savedServer.ok ? "ok" : "warn",
      savedServer.ok ? "SYSTEM SETTINGS RESET" : `SYSTEM RESET (SERVER CONFIG FAIL: ${savedServer.error || "request failed"})`
    );
    await poll({ force: true });
  };
}

if (el.systemPollNowBtn) {
  el.systemPollNowBtn.onclick = async () => {
    await poll({ force: true });
    setBadge(el.health, "ok", "MANUAL POLL COMPLETE");
  };
}

if (el.systemClearCacheBtn) {
  el.systemClearCacheBtn.onclick = async () => {
    const proceed = window.confirm("Clear UI local/session/cache memory and reload now?");
    if (!proceed) return;
    try {
      await clearUiLocalCache();
    } finally {
      window.location.reload();
    }
  };
}

if (el.tabsBar) {
  el.tabsBar.onclick = event => {
    const target = event.target instanceof Element ? event.target : null;
    if (!target) return;

    const modTabBtn = target.closest(".modUiDynamicTab");
    if (modTabBtn && el.tabsBar.contains(modTabBtn)) {
      const modId = normalizeModUiId(modTabBtn.dataset.modUiTabId);
      if (!modId) return;

      ui.modUiSelectedId = modId;
      localStorage.setItem(MOD_UI_SELECTED_KEY, modId);
      if (el.modUiSelect) el.modUiSelect.value = modId;
      showTab("mods");
      renderModUiFrame({ forceReload: true });
      return;
    }

    const tabBtn = target.closest("[data-tab-btn]");
    if (tabBtn && el.tabsBar.contains(tabBtn)) {
      showTab(tabBtn.dataset.tabBtn);
    }
  };
}

if (el.modUiSelect) {
  el.modUiSelect.onchange = () => {
    ui.modUiSelectedId = normalizeModUiId(el.modUiSelect.value);
    if (ui.modUiSelectedId) {
      localStorage.setItem(MOD_UI_SELECTED_KEY, ui.modUiSelectedId);
    } else {
      localStorage.removeItem(MOD_UI_SELECTED_KEY);
    }
    renderModUiFrame({ forceReload: true });
  };
}

if (el.modUiRefreshBtn) {
  el.modUiRefreshBtn.onclick = async () => {
    const ok = await refreshModUiCatalog({ preferRemote: true, forceReload: true, persist: true });
    setBadge(el.health, ok ? "ok" : "bad", ok ? "MOD UI CATALOG REFRESHED" : "MOD UI CATALOG FAIL");
  };
}

if (el.modUiReloadBtn) {
  el.modUiReloadBtn.onclick = () => {
    renderModUiFrame({ forceReload: true });
    setBadge(el.health, "ok", "MOD UI FRAME RELOADED");
  };
}

if (el.modUiOpenBtn) {
  el.modUiOpenBtn.onclick = () => {
    const descriptor = getSelectedModUiDescriptor();
    if (!descriptor || !descriptor.loaded || !descriptor.url) {
      setBadge(el.health, "warn", "SELECT A LOADED MOD UI FIRST");
      return;
    }
    window.open(withBase(descriptor.url), "_blank", "noopener");
  };
}

if (el.moddingReadmeBtn) {
  el.moddingReadmeBtn.onclick = () => {
    const proceed = window.confirm(
      "You are about to open developer modding documentation in a separate page.\n\nContinue?"
    );
    if (!proceed) return;
    window.open(withBase("/modding-readme.html"), "_blank", "noopener");
  };
}

if (el.jumpRoutingLink) {
  el.jumpRoutingLink.onclick = event => {
    event.preventDefault();
    activateTabAndScroll("fixtures", "deviceRouting");
  };
}

el.jumpModsLink.onclick = event => {
  event.preventDefault();
  activateTabAndScroll("mods", "modCenter");
};

el.fxBrand.onchange = () => {
  const selectedBrand = resolveFixtureFormBrand("");
  const originalId = String(el.fxOriginalId?.value || "").trim();
  if (originalId) {
    const originalFixture = getFixtureById(originalId);
    const originalBrand = String(originalFixture?.brand || "").trim().toLowerCase();
    if (originalBrand && originalBrand !== selectedBrand) {
      if (String(el.fxId?.value || "").trim() === originalId) {
        el.fxId.value = "";
      }
      if (el.fxOriginalId) el.fxOriginalId.value = "";
    }
  }

  if (!el.fxZone.value.trim()) {
    el.fxZone.value = getCanonicalZoneForBrand(selectedBrand, "custom");
  }
  syncFixtureCouplingDefaults("brand");
  applyFixtureBrandVisibility();
};

if (el.fxModBrandId) {
  el.fxModBrandId.oninput = () => {
    el.fxModBrandId.value = String(el.fxModBrandId.value || "").toLowerCase().trim();
    syncFixtureCouplingDefaults("mod-brand");
    applyFixtureBrandVisibility();
  };
}

el.fxControlMode.onchange = () => {
  syncFixtureCouplingDefaults("mode");
};

el.fxEngineBinding.onchange = () => {
  updateFixtureCompatibilityHint();
};

el.fxResetBtn.onclick = () => {
  resetFixtureForm();
};

bindSensitiveFieldToggle(el.fxBridgeIp, el.fxBridgeIpShowBtn, "HUE BRIDGE IP");
bindSensitiveFieldToggle(el.fxUsername, el.fxUsernameShowBtn, "HUE USERNAME");
bindSensitiveFieldToggle(el.fxClientKey, el.fxClientKeyShowBtn, "HUE CLIENT KEY");
bindSensitiveFieldToggle(el.fxWizIp, el.fxWizIpShowBtn, "WIZ IP / MOD TARGET");

el.fxHueDiscoverBtn.onclick = async () => {
  if (el.fxBrand.value !== "hue") {
    el.fxBrand.value = "hue";
    applyFixtureBrandVisibility();
  }

  const areaCheck = ensureHueEntertainmentAreaSelection({
    forcePrompt: false,
    promptIfMissing: false,
    forceWhenBridgeConfigured: true
  });
  if (!areaCheck.ok) {
    setBadge(el.health, "warn", areaCheck.message || "ENT AREA REQUIRED");
    return;
  }

  await ensureHueEntGuideAcknowledged();

  const found = await discoverHueBridgeAndFill();
  if (!found.ok) {
    setBadge(el.health, "bad", "HUE DISCOVERY FAIL");
    return;
  }

  setBadge(
    el.health,
    "ok",
    found.bridge.id
      ? `HUE BRIDGE FOUND (${found.bridge.id})`
      : "HUE BRIDGE FOUND"
  );
};

el.fxHuePairBtn.onclick = async () => {
  if (el.fxBrand.value !== "hue") {
    el.fxBrand.value = "hue";
    applyFixtureBrandVisibility();
  }

  let bridgeIp = el.fxBridgeIp.value.trim();
  if (!bridgeIp) {
    const found = await discoverHueBridgeAndFill();
    if (!found.ok) {
      setBadge(el.health, "bad", "PAIR FAIL: NO BRIDGE");
      return;
    }
    bridgeIp = found.bridge.ip;
  }

  const areaCheck = ensureHueEntertainmentAreaSelection({
    forcePrompt: true,
    promptIfMissing: true,
    forceWhenBridgeConfigured: true
  });
  if (!areaCheck.ok) {
    setBadge(el.health, "warn", areaCheck.message || "ENT AREA REQUIRED");
    return;
  }

  if (!window.confirm(
    "Press the LINK button on your Hue Bridge now, then click OK to start pairing (about 30s timeout)."
  )) {
    return;
  }

  el.fxHueDiscoverBtn.disabled = true;
  el.fxHuePairBtn.disabled = true;
  if (el.fxHueSaveBridgeBtn) el.fxHueSaveBridgeBtn.disabled = true;
  setBadge(el.health, "warn", "PAIRING HUE: PRESS LINK BUTTON");

  const modeState = readFixtureModeFields();
  const fixtureHint = {
    id: el.fxId.value.trim(),
    zone: modeState.zone,
    enabled: el.fxEnabled.value === "true",
    engineEnabled: modeState.engineEnabled,
    twitchEnabled: modeState.twitchEnabled,
    customEnabled: modeState.customEnabled,
    lightId: Number(el.fxLightId.value || 1),
    entertainmentAreaId: el.fxEntertainmentAreaId.value.trim()
  };

  const pair = await postJson("/hue/pair", {
    bridgeIp,
    bridgeId: el.fxBridgeId.value.trim(),
    appName: "hue-bridge-final",
    timeoutMs: 30000,
    pollMs: 1200,
    lightId: fixtureHint.lightId,
    entertainmentAreaId: fixtureHint.entertainmentAreaId,
    saveFixture: true,
    fixture: fixtureHint
  });

  el.fxHueDiscoverBtn.disabled = false;
  el.fxHuePairBtn.disabled = false;
  if (el.fxHueSaveBridgeBtn) el.fxHueSaveBridgeBtn.disabled = false;

  if (!pair.ok || !pair.data?.ok) {
    const code = pair.data?.error || "pair_failed";
    if (code === "link_button_timeout") {
      setBadge(el.health, "warn", "PAIR TIMEOUT: PRESS LINK + RETRY");
    } else if (code === "missing_entertainment_area") {
      setBadge(el.health, "warn", "PAIR BLOCKED: SET ENT AREA");
    } else if (code === "invalid_bridge_ip") {
      setBadge(el.health, "bad", "PAIR FAIL: INVALID BRIDGE IP");
    } else {
      setBadge(el.health, "bad", "HUE PAIR FAIL");
    }
    return;
  }

  const bridge = pair.data.bridge || {};
  const creds = pair.data.credentials || {};
  const areas = Array.isArray(pair.data.entertainmentAreas) ? pair.data.entertainmentAreas : [];
  const pairedFixture = pair.data.fixture && typeof pair.data.fixture === "object"
    ? pair.data.fixture
    : null;
  const fixtureSavedByPair = pair.data.fixtureSaved === true && Boolean(pairedFixture);
  const fixtureSaveError = String(pair.data.fixtureSaveError || "").trim();

  if (bridge.ip) el.fxBridgeIp.value = String(bridge.ip).trim();
  if (bridge.id) el.fxBridgeId.value = String(bridge.id).trim().toUpperCase();
  if (creds.username) el.fxUsername.value = String(creds.username).trim();
  if (creds.clientKey) el.fxClientKey.value = String(creds.clientKey).trim().toUpperCase();
  if (pairedFixture?.id) el.fxId.value = String(pairedFixture.id).trim();
  if (pairedFixture?.id && el.fxOriginalId) el.fxOriginalId.value = String(pairedFixture.id).trim();
  if (pairedFixture?.zone && !el.fxZone.value.trim()) {
    el.fxZone.value = String(pairedFixture.zone).trim();
  }
  if (!el.fxEntertainmentAreaId.value.trim() && areas.length) {
    const first = areas[0] || {};
    el.fxEntertainmentAreaId.value = String(first.name || first.id || "").trim();
  }

  let saved = null;
  if (fixtureSavedByPair) {
    const catalogSeed = await getKnownFixtureCatalog();
    const localCatalog = upsertFixtureCatalogEntry(pairedFixture, { catalogSeed });
    applyFixtureCatalogToUi(localCatalog);
    const refreshed = await refreshFixturesFromServer({ attempts: 5 });
    saved = {
      ok: true,
      savedFixture: pairedFixture,
      refreshOk: refreshed.ok,
      routeSync: { ok: true, changed: false }
    };
  } else {
    saved = await saveFixtureFromForm({ resetAfter: false });
  }

  if (!saved.ok) {
    const detail = saved.error || fixtureSaveError || "fixture save failed";
    const msg = `HUE PAIRED (SAVE FAIL: ${detail})`;
    setBadge(el.health, pair.data.warning ? "warn" : "bad", msg);
    return;
  }

  if (saved.savedFixture?.id) {
    el.fxId.value = String(saved.savedFixture.id);
    if (el.fxOriginalId) el.fxOriginalId.value = String(saved.savedFixture.id).trim();
  }

  const routeSync = saved.routeSync || { ok: true, changed: false };
  if (!routeSync.ok) {
    setBadge(el.health, "warn", "HUE PAIRED + SAVED (ROUTE UPDATE FAIL)");
    return;
  }

  if (pair.data.warning) {
    setBadge(
      el.health,
      "warn",
      routeSync.changed
        ? "HUE PAIRED + SAVED + ROUTE (AREA WARN)"
        : "HUE PAIRED + SAVED (AREA WARN)"
    );
    return;
  }

  if (routeSync.changed) {
    setBadge(el.health, "ok", "HUE PAIRED + SAVED + ROUTE UPDATED");
  } else {
    setBadge(el.health, "ok", "HUE PAIRED + SAVED");
  }
};

if (el.fxHueSaveBridgeBtn) {
  el.fxHueSaveBridgeBtn.onclick = async () => {
    if (el.fxBrand.value !== "hue") {
      el.fxBrand.value = "hue";
      applyFixtureBrandVisibility();
    }

    const areaCheck = ensureHueEntertainmentAreaSelection({
      forcePrompt: false,
      promptIfMissing: true,
      forceWhenBridgeConfigured: true
    });
    if (!areaCheck.ok) {
      setBadge(el.health, "warn", areaCheck.message || "ENT AREA REQUIRED");
      return;
    }

    const saved = await saveFixtureFromForm({ resetAfter: false });
    if (!saved.ok) {
      setBadge(el.health, "bad", `BRIDGE EDIT SAVE FAIL: ${saved.error || "invalid payload"}`);
      return;
    }

    const routeSync = saved.routeSync || { ok: true, changed: false };
    if (!routeSync.ok) {
      setBadge(el.health, "warn", "BRIDGE EDITS SAVED (ROUTE UPDATE FAIL)");
      return;
    }

    if (routeSync.changed) {
      setBadge(el.health, "ok", "BRIDGE EDITS SAVED + ROUTE UPDATED");
    } else {
      setBadge(el.health, "ok", "BRIDGE EDITS SAVED");
    }
  };
}

el.fxSaveBtn.onclick = async () => {
  const saved = await saveFixtureFromForm({ resetAfter: true });
  if (!saved.ok) {
    setBadge(el.health, "bad", `FIXTURE SAVE FAIL: ${saved.error || "invalid payload"}`);
    return;
  }

  const routeSync = saved.routeSync || { ok: true, changed: false };
  if (routeSync.ok && routeSync.changed) {
    setBadge(el.health, "ok", "FIXTURE SAVED + ROUTE UPDATED");
  } else if (!routeSync.ok) {
    setBadge(el.health, "warn", "FIXTURE SAVED (ROUTE UPDATE FAIL)");
  } else {
    setBadge(el.health, "ok", "FIXTURE SAVED");
  }
};

el.standFixtureSelect.onchange = () => {
  syncRouteSelectionUi();
};

const onRouteToggleChange = (source = "") => {
  enforceRouteToggleConstraints({ source });
  setRouteDraftStateFromCurrentChips();
  const fixture = getFixtureById(el.standFixtureSelect.value);
  if (fixture) {
    renderRouteDraftStatus(fixture);
  }

  if (!getRouteChipState(el.standRouteCustom)) {
    applyStandaloneEntryToControls(null);
  }
};
el.standRouteEngine.onclick = () => {
  toggleRouteChip(el.standRouteEngine);
  onRouteToggleChange("engine");
};
el.standRouteTwitch.onclick = () => {
  toggleRouteChip(el.standRouteTwitch);
  onRouteToggleChange("twitch");
};
el.standRouteCustom.onclick = () => {
  toggleRouteChip(el.standRouteCustom);
  onRouteToggleChange("custom");
};

el.standRouteApplyBtn.onclick = async () => {
  await applyFixtureRouteMode();
};

el.standConnectivityBtn.onclick = async () => {
  await testFixtureConnectivity();
};

const refreshStandaloneDraftStatus = () => {
  const fixtureId = String(ui.standaloneSelectedId || "").trim();
  const fixture = getFixtureById(fixtureId);
  if (!fixture) return;
  const mode = normalizeStandaloneMode(el.standMode.value).toUpperCase();
  const scene = normalizeStandaloneScene(el.standScene.value).toUpperCase();
  const speedSource = normalizeStandaloneSpeedMode(el.standSpeedMode.value).toUpperCase();
  const staticWord = getStandaloneToggleState(el.standStaticBtn) ? "STATIC" : "LIVE";
  const startWord = getStandaloneToggleState(el.standRaveStartBtn) ? "START_EVT_ON" : "START_EVT_OFF";
  const stopWord = getStandaloneToggleState(el.standRaveStopBtn) ? "STOP_EVT_ON" : "STOP_EVT_OFF";
  const colorWord = normalizeStandaloneColorMode(el.standColorMode.value).toUpperCase();
  const brandKey = String(fixture.brand || "").trim().toLowerCase();
  const zone = String(
    fixture.zone ||
    (brandKey === "hue" ? "hue" : (brandKey === "wiz" ? "wiz" : "custom"))
  );
  el.standStatus.value =
    `${fixtureId} | ${String(fixture.brand || "").toUpperCase()} | zone ${zone} | ` +
    `mode ${mode} | scene ${scene} | ${speedSource} | ${colorWord} | ${staticWord} | ${startWord} | ${stopWord} | draft (press APPLY TO DEVICE)`;
};

function bindStandaloneDraftTracking() {
  const trackedNodes = [
    el.standPower,
    el.standMode,
    el.standScene,
    el.standSpeedMode,
    el.standSpeedHz,
    el.standSpeedMinHz,
    el.standSpeedMaxHz,
    el.standBrightness,
    el.standHue,
    el.standHueMin,
    el.standHueMax,
    el.standSat,
    el.standSatMin,
    el.standSatMax,
    el.standColorMode,
    el.standCctKelvin,
    el.standCctMinKelvin,
    el.standCctMaxKelvin,
    el.standTransitionMs
  ];

  const onDraftChange = () => {
    markStandaloneDraftDirty();
  };

  for (const node of trackedNodes) {
    if (!node) continue;
    node.addEventListener("input", onDraftChange);
    node.addEventListener("change", onDraftChange);
  }
}

el.standBrightness.oninput = syncStandaloneValueLabels;
el.standHue.oninput = syncStandaloneValueLabels;
el.standSat.oninput = syncStandaloneValueLabels;
el.standHueMin.oninput = () => {
  syncStandaloneValueLabels();
  syncStandaloneModeUi({ enabled: !el.standMode.disabled });
};
el.standHueMax.oninput = () => {
  syncStandaloneValueLabels();
  syncStandaloneModeUi({ enabled: !el.standMode.disabled });
};
el.standSatMin.oninput = () => {
  syncStandaloneValueLabels();
  syncStandaloneModeUi({ enabled: !el.standMode.disabled });
};
el.standSatMax.oninput = () => {
  syncStandaloneValueLabels();
  syncStandaloneModeUi({ enabled: !el.standMode.disabled });
};
el.standCctKelvin.oninput = syncStandaloneValueLabels;
el.standCctMinKelvin.oninput = () => {
  syncStandaloneValueLabels();
  syncStandaloneModeUi({ enabled: !el.standMode.disabled });
};
el.standCctMaxKelvin.oninput = () => {
  syncStandaloneValueLabels();
  syncStandaloneModeUi({ enabled: !el.standMode.disabled });
};
el.standSpeedMinHz.oninput = () => {
  syncStandaloneValueLabels();
  syncStandaloneModeUi({ enabled: !el.standMode.disabled });
};
el.standSpeedMaxHz.oninput = () => {
  syncStandaloneValueLabels();
  syncStandaloneModeUi({ enabled: !el.standMode.disabled });
};
el.standMode.onchange = () => {
  syncStandaloneModeUi({ enabled: !el.standMode.disabled });
  refreshStandaloneDraftStatus();
};
el.standScene.onchange = refreshStandaloneDraftStatus;
el.standSpeedMode.onchange = () => {
  syncStandaloneModeUi({ enabled: !el.standMode.disabled });
  refreshStandaloneDraftStatus();
};
el.standColorMode.onchange = () => {
  syncStandaloneModeUi({ enabled: !el.standMode.disabled });
  refreshStandaloneDraftStatus();
};
el.standStaticBtn.onclick = () => {
  const nextOn = !getStandaloneToggleState(el.standStaticBtn);
  setStandaloneToggleState(el.standStaticBtn, nextOn, { on: "STATIC ON", off: "STATIC OFF" });
  syncStandaloneModeUi({ enabled: !el.standMode.disabled });
  markStandaloneDraftDirty();
};
el.standRaveStartBtn.onclick = () => {
  const nextOn = !getStandaloneToggleState(el.standRaveStartBtn);
  setStandaloneToggleState(el.standRaveStartBtn, nextOn, { on: "RAVE-START UPDATE ON", off: "RAVE-START UPDATE OFF" });
  markStandaloneDraftDirty();
};
el.standRaveStopBtn.onclick = () => {
  const nextOn = !getStandaloneToggleState(el.standRaveStopBtn);
  setStandaloneToggleState(el.standRaveStopBtn, nextOn, { on: "RAVE-END UPDATE ON", off: "RAVE-END UPDATE OFF" });
  markStandaloneDraftDirty();
};

if (el.customFixtureSelect) {
  el.customFixtureSelect.onchange = () => {
    applyCustomFixtureSelectionFromTab({ notify: false });
  };
}

if (el.customFixtureSyncBtn) {
  el.customFixtureSyncBtn.onclick = () => {
    applyCustomFixtureSelectionFromTab({ notify: true });
  };
}

el.standApplyBtn.onclick = async () => {
  await applyStandaloneState();
};

el.standRefreshBtn.onclick = async () => {
  clearStandaloneDraftState();
  const f = await getJson("/fixtures");
  if (f) updateFixtures(f);
  const ok = await refreshStandaloneFixtures();
  setBadge(el.health, ok ? "ok" : "bad", ok ? "FIXTURE REFRESH" : "FIXTURE REFRESH FAIL");
};
bindStandaloneDraftTracking();

el.modsRefreshBtn.onclick = async () => {
  const ok = await loadMods();
  setBadge(el.health, ok ? "ok" : "bad", ok ? "MODS REFRESHED" : "MODS REFRESH FAIL");
};

el.modsReloadBtn.onclick = async () => {
  if (ui.modsDraftDirty) {
    const proceed = window.confirm(
      "You have queued mod hotswap changes that are not applied yet.\n\nContinue reload anyway?"
    );
    if (!proceed) return;
  }
  const r = await postJson("/mods/reload", {});
  if (!r.ok || !r.data || !r.data.ok) {
    setBadge(el.health, "bad", "MODS RELOAD FAIL");
    return;
  }
  ui.modsDraftDirty = false;
  ui.modsDraftConfig = cloneModConfig(r.data?.config || {});
  renderMods(r.data);
  setBadge(el.health, "ok", "MODS RELOADED");
};

if (el.modImportBrowseBtn && el.modImportPicker) {
  el.modImportBrowseBtn.onclick = () => {
    el.modImportPicker.value = "";
    el.modImportPicker.click();
  };
}

if (el.modImportPicker) {
  el.modImportPicker.onchange = async () => {
    const descriptors = filesToImportDescriptors(el.modImportPicker.files || []);
    if (!descriptors.length) {
      setModImportStatus("No files selected.");
      return;
    }
    await importModFromDescriptors(descriptors, "folder picker");
  };
}

if (el.modDropZone) {
  const stopDefault = ev => {
    ev.preventDefault();
    ev.stopPropagation();
  };

  el.modDropZone.addEventListener("dragenter", ev => {
    stopDefault(ev);
    el.modDropZone.classList.add("dragOver");
  });
  el.modDropZone.addEventListener("dragover", ev => {
    stopDefault(ev);
    el.modDropZone.classList.add("dragOver");
  });
  el.modDropZone.addEventListener("dragleave", ev => {
    stopDefault(ev);
    el.modDropZone.classList.remove("dragOver");
  });
  el.modDropZone.addEventListener("drop", async ev => {
    stopDefault(ev);
    el.modDropZone.classList.remove("dragOver");
    const descriptors = await descriptorsFromDropEvent(ev);
    await importModFromDescriptors(descriptors, "drag/drop");
  });
}

el.modEnableBtn.onclick = enableModFromUi;
el.modDisableBtn.onclick = disableModFromUi;
el.modApplyBtn.onclick = applyModHotswapFromUi;
el.modDiscardBtn.onclick = discardModDraftFromUi;
el.modActionRunBtn.onclick = runModAction;

/* POWER */
el.onBtn.onclick = async () => {
  const ok = await api("/rave/on");
  ui.raveOn = ok;
  setBadge(el.health, ok ? "ok" : "bad", ok ? "RAVE ON" : "RAVE ON FAIL");
  sync();
};

el.offBtn.onclick = async () => {
  const ok = await api("/rave/off");
  if (ok) ui.raveOn = false;
  setBadge(el.health, ok ? "ok" : "bad", ok ? "RAVE OFF" : "RAVE OFF FAIL");
  sync();
};

el.panicBtn.onclick = async () => {
  if (shouldConfirmDangerousAction() && !window.confirm("Trigger PANIC blackout?")) return;
  await api("/rave/panic");
  ui.raveOn = false;
  sync();
};

/* ENGINE */
el.reloadBtn.onclick = async () => {
  if (shouldConfirmDangerousAction() && !window.confirm("Hot reload engine runtime now?")) return;
  const ok = await api("/rave/reload");
  setBadge(el.health, ok ? "ok" : "bad", ok ? "ENGINE RELOADED" : "RELOAD FAIL");
};
el.dropBtn.onclick = async () => {
  if (!ui.audioReactivityMap?.dropEnabled) {
    setBadge(el.health, "warn", "DROP DISABLED (AUDIO REACT MAP)");
    return;
  }
  const r = await postJson("/rave/drop", {});
  if (!r.ok || !r.data?.ok) {
    setBadge(el.health, "bad", "DROP HIT FAIL");
    return;
  }
  setBadge(el.health, "ok", "DROP HIT");
};
el.hueEntBtn.onclick = async () => {
  const r = await postJson("/hue/transport?mode=entertainment", {});
  if (!r.ok || !r.data) {
    setBadge(el.health, "bad", "HUE ENT FAIL");
    return;
  }

  if (r.data.active === "entertainment") {
    setBadge(el.health, "ok", "HUE ENTERTAINMENT");
  } else {
    setBadge(el.health, "warn", "HUE ENT FALLBACK");
  }
};
el.hueRestBtn.onclick = async () => {
  const r = await postJson("/hue/transport?mode=rest", {});
  setBadge(el.health, r.ok ? "ok" : "bad", r.ok ? "HUE REST" : "HUE REST FAIL");
};
el.serverStopBtn.onclick = async () => {
  if (shouldConfirmDangerousAction() && !window.confirm("Stop the local RaveLink server now?")) return;

  setBadge(el.health, "warn", "SERVER STOPPING...");
  const r = await postJson("/system/stop", {});
  if (!r.ok && r.status !== 0) {
    setBadge(el.health, "bad", "SERVER STOP FAIL");
    return;
  }

  setTimeout(() => {
    window.location.reload();
  }, 1800);
};
el.fixturesReloadBtn.onclick = async () => {
  const ok = await api("/fixtures/reload");
  setBadge(el.health, ok ? "ok" : "bad", ok ? "FIXTURES RELOADED" : "FIXTURES RELOAD FAIL");
  const f = await getJson("/fixtures");
  if (f) updateFixtures(f);
  await loadColorPrefixConfig();
};

el.colorPrefixSaveBtn.onclick = async () => {
  await saveColorPrefixConfigFromUi({ reset: false });
};

el.colorPrefixResetBtn.onclick = async () => {
  await saveColorPrefixConfigFromUi({ reset: true });
};

if (el.legacyAutomationUnlockBtn) {
  el.legacyAutomationUnlockBtn.onclick = () => {
    setLegacyAutomationUnlocked(true);
    setBadge(el.health, "warn", "LEGACY AUTOMATION OPENED");
  };
}
if (el.legacyAutomationLockBtn) {
  el.legacyAutomationLockBtn.onclick = () => {
    setLegacyAutomationUnlocked(false);
    setBadge(el.health, "ok", "LEGACY AUTOMATION HIDDEN");
  };
}
if (el.legacyAutomationJumpCustomBtn) {
  el.legacyAutomationJumpCustomBtn.onclick = () => {
    activateTabAndScroll("custom", "standCustomCluster");
  };
}

el.autoStartPercent.oninput = syncAutomationPercentLabels;
el.autoStopPercent.oninput = syncAutomationPercentLabels;
el.autoRulesEnabled.onchange = () => {
  syncAutomationControlAccessibility();
};

el.autoRulesSaveBtn.onclick = async () => {
  const patch = collectAutomationConfigFromInputs();
  const r = await postJson("/automation/config", patch);
  if (!r.ok || !r.data) {
    setBadge(el.health, "bad", "AUTO RULES SAVE FAIL");
    return;
  }

  applyAutomationConfigToInputs(r.data.config || patch, r.data.meta || {});
  setBadge(el.health, "ok", "AUTO RULES SAVED");
};

el.autoRulesReloadBtn.onclick = async () => {
  const r = await postJson("/automation/reload", {});
  if (!r.ok || !r.data) {
    setBadge(el.health, "bad", "AUTO RULES RELOAD FAIL");
    return;
  }

  applyAutomationConfigToInputs(r.data.config || {}, r.data.meta || {});
  setBadge(el.health, "ok", "AUTO RULES RELOADED");
};

el.autoRulesTestStartBtn.onclick = async () => {
  const r = await postJson("/automation/apply?event=start", {});
  if (!r.ok || !r.data) {
    setBadge(el.health, "bad", "AUTO START TEST FAIL");
    return;
  }
  const ok = Boolean(r.data.result?.ok);
  setBadge(el.health, ok ? "ok" : "warn", ok ? "AUTO START TEST OK" : "AUTO START TEST WARN");
};

el.autoRulesTestStopBtn.onclick = async () => {
  const r = await postJson("/automation/apply?event=stop", {});
  if (!r.ok || !r.data) {
    setBadge(el.health, "bad", "AUTO STOP TEST FAIL");
    return;
  }
  const ok = Boolean(r.data.result?.ok);
  setBadge(el.health, ok ? "ok" : "warn", ok ? "AUTO STOP TEST OK" : "AUTO STOP TEST WARN");
};

/* AUDIO CONTROL */
el.aDevices.onchange = () => {
  if (el.aDevices.value === "") {
    el.aDeviceId.value = "";
  } else {
    el.aDeviceId.value = el.aDevices.value;
  }
};

el.aSampleRate.onchange = () => {
  syncAudioQuickPresetButtons();
};

el.aFrames.onchange = () => {
  syncAudioQuickPresetButtons();
};

bindAudioReactivityMapUi();

if (el.reactMapApplyBtn) {
  el.reactMapApplyBtn.onclick = async () => {
    const result = await saveAudioReactivityMap({ reset: false });
    if (!result.ok) {
      setBadge(el.health, "bad", "REACT MAP APPLY FAIL");
      return;
    }
    setBadge(el.health, "ok", "REACT MAP APPLIED");
    sync();
  };
}

if (el.reactMapResetBtn) {
  el.reactMapResetBtn.onclick = async () => {
    if (!window.confirm("Reset audio reactivity map to defaults?")) return;
    const result = await saveAudioReactivityMap({ reset: true });
    if (!result.ok) {
      setBadge(el.health, "bad", "REACT MAP RESET FAIL");
      return;
    }
    setBadge(el.health, "ok", "REACT MAP RESET");
    sync();
  };
}

audioQuickPresetButtons.forEach(btn => {
  btn.onclick = () => {
    const name = String(btn.dataset.audioQuick || "").trim().toLowerCase();
    const ok = applyAudioQuickProfile(name);
    if (!ok) return;
    setBadge(el.health, "ok", `AUDIO PROFILE ${name.toUpperCase()}`);
    sync();
  };
});

el.aRefreshBtn.onclick = async () => {
  const [cfgOk, reactOk] = await Promise.all([
    loadAudioConfig(),
    loadAudioReactivityMap()
  ]);
  const ok = cfgOk && reactOk;
  setBadge(el.health, ok ? "ok" : "bad", ok ? "AUDIO CFG+REACT REFRESH" : "AUDIO REFRESH FAIL");
};

el.aScanBtn.onclick = async () => {
  const ok = await loadAudioDevices();
  setBadge(el.health, ok ? "ok" : "bad", ok ? "AUDIO DEVICES SCANNED" : "AUDIO SCAN FAIL");
};

el.aApplyBtn.onclick = async () => {
  const patch = collectAudioConfigFromInputs();
  const r = await postJson("/audio/config", patch);
  if (!r.ok) {
    setBadge(el.health, "bad", "AUDIO APPLY FAIL");
    return;
  }

  if (r.data && r.data.config) {
    applyAudioConfigToInputs(r.data.config);
  }

  setBadge(
    el.health,
    "ok",
    r.data && r.data.restarted ? "AUDIO CFG APPLIED + RESTART" : "AUDIO CFG APPLIED"
  );
};

el.aRestartBtn.onclick = async () => {
  const r = await api("/audio/restart");
  setBadge(el.health, r ? "ok" : "bad", r ? "AUDIO RESTART" : "AUDIO RESTART FAIL");
};

el.aResetDefaultsBtn.onclick = async () => {
  if (!window.confirm("Reset audio settings to defaults and apply now?")) return;

  const r = await postJson("/audio/config", AUDIO_CONFIG_DEFAULTS);
  if (!r.ok) {
    setBadge(el.health, "bad", "AUDIO RESET FAIL");
    return;
  }

  applyAudioConfigToInputs(r.data?.config || AUDIO_CONFIG_DEFAULTS);
  setBadge(
    el.health,
    "ok",
    r.data && r.data.restarted ? "AUDIO DEFAULTS APPLIED + RESTART" : "AUDIO DEFAULTS APPLIED"
  );
  sync();
};

limiterPresetButtons.forEach(btn => {
  btn.onclick = async () => {
    const presetName = btn.dataset.limiterPreset;
    const preset = LIMITER_PRESETS[presetName];
    if (!preset) return;

    const r = await postJson("/audio/config", preset);
    if (!r.ok) {
      setBadge(el.health, "bad", "LIMITER PRESET FAIL");
      return;
    }

    el.aLimiterThreshold.value = String(preset.limiterThreshold);
    el.aLimiterKnee.value = String(preset.limiterKnee);
    ui.limiterPreset = presetName;

    if (r.data && r.data.config) {
      applyAudioConfigToInputs(r.data.config);
    }

    setBadge(el.health, "ok", `LIMITER ${presetName.toUpperCase()}`);
    sync();
  };
});

/* MODE */
el.modeAutoBtn.onclick = async () => {
  ui.modeLock = "auto";
  await api("/rave/mode?name=auto");
  maybeApplySmartLiveReactivityPolicy("MODE AUTO");
  sync();
};

el.gameBtn.onclick = async () => {
  ui.modeLock = "clamp";
  await api("/rave/mode?name=game");
  maybeApplySmartLiveReactivityPolicy("MODE GAME");
  sync();
};

el.bpmBtn.onclick = async () => {
  ui.modeLock = "interpret";
  await api("/rave/mode?name=bpm");
  maybeApplySmartLiveReactivityPolicy("MODE BPM");
  sync();
};

el.metaAutoOnBtn.onclick = async () => {
  const r = await postJson("/rave/meta/auto?enabled=true", {});
  if (!r.ok || !r.data) {
    setBadge(el.health, "bad", "META AUTO FAIL");
    return;
  }

  ui.metaAutoEnabled = Boolean(r.data.enabled);
  ui.metaAutoReason = "enabled";
  maybeApplySmartLiveReactivityPolicy("META AUTO ON");
  setBadge(el.health, "ok", "META AUTO ON");
  sync();
};

el.metaAutoOffBtn.onclick = async () => {
  const r = await postJson("/rave/meta/auto?enabled=false", {});
  if (!r.ok || !r.data) {
    setBadge(el.health, "bad", "META AUTO FAIL");
    return;
  }

  ui.metaAutoEnabled = Boolean(r.data.enabled);
  ui.metaAutoReason = "off";
  maybeApplySmartLiveReactivityPolicy("META AUTO OFF");
  setBadge(el.health, "ok", "META AUTO OFF");
  sync();
};

/* AUTO PROFILE */
autoProfileButtons.forEach(btn => {
  btn.onclick = async () => {
    const name = btn.dataset.autoProfile;
    const metaOk = await disableMetaAutoForManualOverride({ announce: false });
    if (!metaOk) return;

    const ok = await api(`/rave/auto/profile?name=${name}`);
    if (!ok) {
      setBadge(el.health, "bad", "AUTO PROFILE FAIL");
      return;
    }

    ui.autoProfile = name;
    maybeApplySmartLiveReactivityPolicy(`AUTO ${String(name || "").toUpperCase()}`);
    setBadge(el.health, "ok", `AUTO ${name.toUpperCase()}`);
    sync();
  };
});

/* AUDIO REACTIVITY */
audioReactivityButtons.forEach(btn => {
  btn.onclick = async () => {
    const name = btn.dataset.audioReactivity;
    const metaOk = await disableMetaAutoForManualOverride({ announce: false });
    if (!metaOk) return;

    const ok = await api(`/rave/audio/reactivity?name=${name}`);
    if (!ok) {
      setBadge(el.health, "bad", "AUDIO REACT FAIL");
      return;
    }

    ui.audioReactivityPreset = name;
    maybeApplySmartLiveReactivityPolicy(`A-REACT ${String(name || "").toUpperCase()}`);
    setBadge(el.health, "ok", `A-REACT ${name.toUpperCase()}`);
    sync();
  };
});

/* SCENE LOCK */
sceneButtons.forEach(btn => {
  btn.onclick = async () => {
    const scene = btn.dataset.scene;
    if (scene === "auto") {
      ui.sceneLock = "auto";
      await api("/rave/scene/auto");
    } else {
      ui.sceneLock = scene;
      await api(`/rave/scene?name=${scene}`);
    }
    maybeApplySmartLiveReactivityPolicy(`SCENE ${String(ui.sceneLock || "auto").toUpperCase()}`);
    sync();
  };
});

async function setSceneSyncMode(enabled) {
  const response = await postJson("/rave/scene/sync", { enabled: Boolean(enabled) });
  if (!response.ok || !response.data) {
    setBadge(el.health, "bad", "SCENE SYNC FAIL");
    return false;
  }

  ui.wizSceneSync = Boolean(response.data.enabled);
  const sceneSyncLabels = getSceneSyncLabelContext();
  setBadge(
    el.health,
    "ok",
    ui.wizSceneSync ? sceneSyncLabels.badgeSynced : sceneSyncLabels.badgeDesynced
  );
  sync();
  return true;
}

if (el.sceneSyncOnBtn) {
  el.sceneSyncOnBtn.onclick = async () => {
    await setSceneSyncMode(true);
  };
}

if (el.sceneSyncOffBtn) {
  el.sceneSyncOffBtn.onclick = async () => {
    await setSceneSyncMode(false);
  };
}

/* OVERCLOCK */
async function setOverclockPreset(level, route, label = "") {
  const metaOk = await disableMetaAutoForManualOverride({ announce: false });
  if (!metaOk) return false;

  const ok = await api(route);
  if (!ok) {
    setBadge(el.health, "bad", "OVERCLOCK FAIL");
    return false;
  }
  ui.overclockLevel = Number(level);
  ui.overclock = ui.overclockLevel > 0;
  if (label) {
    setBadge(el.health, "ok", label);
  }
  maybeApplySmartLiveReactivityPolicy(label || "OVERCLOCK");
  sync();
  return true;
}

async function disableMetaAutoForManualOverride(options = {}) {
  const announce = options.announce !== false;
  if (!ui.metaAutoEnabled) return true;

  const r = await postJson("/rave/meta/auto?enabled=false", {});
  if (!r.ok || !r.data) {
    setBadge(el.health, "bad", "META AUTO DISABLE FAIL");
    return false;
  }
  ui.metaAutoEnabled = false;
  ui.metaAutoReason = "off";
  if (announce) {
    setBadge(el.health, "warn", "META AUTO OFF (MANUAL OVERRIDE)");
  }
  return true;
}

async function confirmUnsafeDevOverclock(hz) {
  if (!ui.devOverclockComicalAcked) {
    const step1 = window.confirm(
      `Unsafe DEV ${hz}Hz overclock requested.\n\nAre you sure?`
    );
    if (!step1) return false;
    const step2 = window.confirm("Really really sure?");
    if (!step2) return false;
    const step3 = window.confirm("Really really sure?");
    if (!step3) return false;

    const acked = await openDevOverclockAckGate(hz);
    if (!acked) return false;
    ui.devOverclockComicalAcked = true;
    localStorage.setItem(DEV_OVERCLOCK_COMICAL_ACK_KEY, "1");
    return true;
  }

  window.alert(
    "Warning: 20Hz and above is aggressive and destructive.\n\n" +
    "Behavior can become unstable or unpredictable."
  );
  return true;
}

async function setUnsafeDevOverclock(hz) {
  const parsedHz = Number(hz);
  const level = DEV_OVERCLOCK_LEVEL_BY_HZ[parsedHz];
  if (!Number.isFinite(parsedHz) || !Number.isFinite(level)) {
    setBadge(el.health, "bad", "INVALID DEV OVERCLOCK");
    return false;
  }
  if (!ui.devDebugMode) {
    setBadge(el.health, "warn", "ENABLE DEV DEBUG IN SETTINGS COG");
    return false;
  }
  if (!(await confirmUnsafeDevOverclock(parsedHz))) {
    setBadge(el.health, "warn", "DEV OVERCLOCK CANCELED");
    return false;
  }
  const metaOk = await disableMetaAutoForManualOverride();
  if (!metaOk) return false;

  const r = await postJson(`/rave/overclock/dev/${parsedHz}/on?unsafe=true`, { unsafe: true });
  if (!r.ok || !r.data || !r.data.ok) {
    const reason = r.data?.error ? `: ${r.data.error}` : "";
    setBadge(el.health, "bad", `DEV OVERCLOCK FAIL${reason}`);
    return false;
  }

  ui.overclockLevel = Number(level);
  ui.overclock = true;
  maybeApplySmartLiveReactivityPolicy(`DEV ${parsedHz}HZ`);
  setBadge(el.health, "warn", `DEV ${parsedHz}HZ ARMED`);
  sync();
  return true;
}

el.ocLudicrousBtn.onclick = () => setOverclockPreset(7, "/rave/overclock/ludicrous/on", "OC 16HZ");
el.ocHyperBtn.onclick = () => setOverclockPreset(6, "/rave/overclock/hyper/on", "OC 14HZ");
el.ocInsaneBtn.onclick = () => setOverclockPreset(5, "/rave/overclock/insane/on", "OC 12HZ");
el.ocExtremeBtn.onclick = () => setOverclockPreset(4, "/rave/overclock/extreme/on", "OC 10HZ");
el.ocUltraBtn.onclick = () => setOverclockPreset(3, "/rave/overclock/ultra/on", "OC 8HZ");
el.ocTurboBtn.onclick = () => setOverclockPreset(2, "/rave/overclock/turbo/on", "OC 6HZ");
el.ocOnBtn.onclick = () => setOverclockPreset(1, "/rave/overclock/on", "OC 4HZ");
el.ocOffBtn.onclick = () => setOverclockPreset(0, "/rave/overclock/off", "OC 2HZ");

if (el.ocDev20Btn) el.ocDev20Btn.onclick = () => setUnsafeDevOverclock(20);
if (el.ocDev30Btn) el.ocDev30Btn.onclick = () => setUnsafeDevOverclock(30);
if (el.ocDev40Btn) el.ocDev40Btn.onclick = () => setUnsafeDevOverclock(40);
if (el.ocDev50Btn) el.ocDev50Btn.onclick = () => setUnsafeDevOverclock(50);
if (el.ocDev60Btn) el.ocDev60Btn.onclick = () => setUnsafeDevOverclock(60);

/* GENRE */
el.genreGrid.onclick = async e => {
  const btn = e.target.closest("[data-genre]");
  if (!btn) return;

  const requested = String(btn.dataset.genre || "").trim();
  if (!requested) return;
  const metaOk = await disableMetaAutoForManualOverride({ announce: false });
  if (!metaOk) return;

  const ok = await api(`/rave/genre?name=${encodeURIComponent(requested)}`);
  if (!ok) {
    setBadge(el.health, "bad", "GENRE FAIL");
    return;
  }

  ui.genre = requested;
  maybeApplySmartLiveReactivityPolicy(`GENRE ${String(requested || "").toUpperCase()}`);
  sync();
};

/* DECADE TUNE */
decadeButtons.forEach(btn => {
  btn.onclick = async () => {
    const mode = String(btn.dataset.decadeMode || "").trim().toLowerCase();
    if (!mode) return;
    const metaOk = await disableMetaAutoForManualOverride({ announce: false });
    if (!metaOk) return;

    const r = await postJson(`/rave/genre/decade?mode=${encodeURIComponent(mode)}`, {});
    if (!r.ok || !r.data) {
      setBadge(el.health, "bad", "DECADE FAIL");
      return;
    }

    ui.genreDecadeMode = String(r.data.mode || mode).toLowerCase();
    ui.genreDecadeResolved = String(r.data.resolved || ui.genreDecadeResolved || "10s").toLowerCase();
    setBadge(
      el.health,
      "ok",
      `DECADE ${ui.genreDecadeMode === "auto" ? `AUTO ${ui.genreDecadeResolved.toUpperCase()}` : ui.genreDecadeMode.toUpperCase()}`
    );
    maybeApplySmartLiveReactivityPolicy(`DECADE ${ui.genreDecadeMode.toUpperCase()}`);
    sync();
  };
});

/* MIDI CONTROL */
if (el.midiBindingAction) {
  el.midiBindingAction.onchange = () => {
    applyMidiBindingEditor(ui.midiSnapshot);
  };
}

if (el.midiBindingType) {
  el.midiBindingType.onchange = () => {
    const type = String(el.midiBindingType.value || "note").toLowerCase();
    const defaultMin = type === "cc" ? 64 : 1;
    const current = Number(el.midiBindingMinValue?.value);
    if (!Number.isFinite(current) || current < 0 || current > 127) {
      if (el.midiBindingMinValue) el.midiBindingMinValue.value = String(defaultMin);
    }
  };
}

if (el.midiLearnAction) {
  el.midiLearnAction.onchange = () => {
    if (el.midiBindingAction) {
      const next = normalizeMidiAction(el.midiLearnAction.value);
      if (next) {
        el.midiBindingAction.value = next;
        applyMidiBindingEditor(ui.midiSnapshot);
      }
    }
  };
}

if (el.midiRefreshBtn) {
  el.midiRefreshBtn.onclick = async () => {
    const ok = await loadMidiStatus({ refresh: true });
    setBadge(el.health, ok ? "ok" : "bad", ok ? "MIDI PORTS REFRESHED" : "MIDI REFRESH FAIL");
  };
}

if (el.midiSaveCfgBtn) {
  el.midiSaveCfgBtn.onclick = async () => {
    const patch = collectMidiConfigPatch();
    const response = await postJson("/midi/config", patch);
    if (!response.ok || !response.data) {
      setBadge(el.health, "bad", "MIDI CONFIG SAVE FAIL");
      return;
    }
    applyMidiSnapshot(response.data);
    setBadge(el.health, "ok", "MIDI CONFIG SAVED");
  };
}

if (el.midiLearnArmBtn) {
  el.midiLearnArmBtn.onclick = async () => {
    const action = normalizeMidiAction(el.midiLearnAction?.value);
    if (!action) {
      setBadge(el.health, "warn", "SELECT MIDI ACTION");
      return;
    }
    const response = await postJson(`/midi/learn/${encodeURIComponent(action)}`, {});
    if (!response.ok || !response.data) {
      setBadge(el.health, "bad", "MIDI LEARN ARM FAIL");
      return;
    }
    applyMidiSnapshot(response.data);
    setBadge(el.health, "ok", `MIDI LEARN ${formatMidiActionLabel(action)}`);
  };
}

if (el.midiLearnCancelBtn) {
  el.midiLearnCancelBtn.onclick = async () => {
    const response = await postJson("/midi/learn/cancel", {});
    if (!response.ok || !response.data) {
      setBadge(el.health, "bad", "MIDI LEARN CANCEL FAIL");
      return;
    }
    applyMidiSnapshot(response.data);
    setBadge(el.health, "ok", "MIDI LEARN CANCELED");
  };
}

if (el.midiTriggerBtn) {
  el.midiTriggerBtn.onclick = async () => {
    const action = normalizeMidiAction(el.midiLearnAction?.value);
    if (!action) {
      setBadge(el.health, "warn", "SELECT MIDI ACTION");
      return;
    }
    const response = await postJson(`/midi/trigger/${encodeURIComponent(action)}`, {});
    if (!response.ok || !response.data) {
      setBadge(el.health, "bad", "MIDI ACTION TRIGGER FAIL");
      return;
    }
    applyMidiSnapshot(response.data);
    setBadge(el.health, "ok", `MIDI TRIGGERED ${formatMidiActionLabel(action)}`);
  };
}

if (el.midiBindingSaveBtn) {
  el.midiBindingSaveBtn.onclick = async () => {
    const action = normalizeMidiAction(el.midiBindingAction?.value);
    if (!action) {
      setBadge(el.health, "warn", "SELECT BINDING ACTION");
      return;
    }
    const patch = collectMidiBindingPatch();
    const response = await postJson(`/midi/bindings/${encodeURIComponent(action)}`, patch);
    if (!response.ok || !response.data) {
      setBadge(el.health, "bad", "MIDI BINDING SAVE FAIL");
      return;
    }
    applyMidiSnapshot(response.data);
    setBadge(el.health, "ok", `MIDI BINDING SAVED ${formatMidiActionLabel(action)}`);
  };
}

if (el.midiBindingClearBtn) {
  el.midiBindingClearBtn.onclick = async () => {
    const action = normalizeMidiAction(el.midiBindingAction?.value);
    if (!action) {
      setBadge(el.health, "warn", "SELECT BINDING ACTION");
      return;
    }
    const response = await deleteJson(`/midi/bindings/${encodeURIComponent(action)}`);
    if (!response.ok || !response.data) {
      setBadge(el.health, "bad", "MIDI BINDING CLEAR FAIL");
      return;
    }
    applyMidiSnapshot(response.data);
    setBadge(el.health, "ok", `MIDI BINDING CLEARED ${formatMidiActionLabel(action)}`);
  };
}

if (el.midiBindingResetBtn) {
  el.midiBindingResetBtn.onclick = async () => {
    const response = await postJson("/midi/bindings/reset", {});
    if (!response.ok || !response.data) {
      setBadge(el.health, "bad", "MIDI DEFAULT RESET FAIL");
      return;
    }
    applyMidiSnapshot(response.data);
    setBadge(el.health, "ok", "MIDI DEFAULT BINDINGS RESTORED");
  };
}

const REACTOR_DEFAULTS = Object.freeze({
  master: 1.0,
  dropImpact: 1.0
});

function normalizeVisualMaster(value) {
  const n = Number(value);
  if (!Number.isFinite(n)) return REACTOR_DEFAULTS.master;
  return Math.min(2, Math.max(0, n));
}

function normalizeDropImpact(value) {
  const n = Number(value);
  if (!Number.isFinite(n)) return REACTOR_DEFAULTS.dropImpact;
  return Math.min(2, Math.max(0.5, n));
}

function getReactorRiskState() {
  const overclockLevel = Number(ui.overclockLevel || 0);
  const master = normalizeVisualMaster(ui.visualMaster);
  const drop = normalizeDropImpact(ui.dropIntensity);
  const boosted = master > 1.05 || drop > 1.05;
  const aggressive = master >= 1.2 || drop >= 1.25;

  if (overclockLevel >= 8) {
    return {
      level: "bad",
      text: "Critical risk: DEV overclock tiers (>=20Hz) are destructive and may cause transport collapse, erratic flashing, or unpredictable fixture behavior."
    };
  }

  if (overclockLevel >= 4 && aggressive) {
    return {
      level: "bad",
      text: "High risk: boosted MASTER/DROP with >=10Hz overclock can cause clipping, harsh flashes, and unstable device behavior. Lower sliders or lower overclock."
    };
  }

  if ((overclockLevel >= 2 && boosted) || aggressive) {
    return {
      level: "warn",
      text: "Caution: higher MASTER/DROP often degrades quality. Combine carefully with overclock tiers >=6Hz."
    };
  }

  return {
    level: "base",
    text: "Safe baseline: keep MASTER near 1.00 and DROP near 1.0, then tune gradually."
  };
}

function updateReactorRiskNotice() {
  if (!el.reactorRiskNotice) return;
  const state = getReactorRiskState();
  el.reactorRiskNotice.textContent = state.text;
  el.reactorRiskNotice.classList.remove("warn", "bad");
  if (state.level === "warn") {
    el.reactorRiskNotice.classList.add("warn");
  } else if (state.level === "bad") {
    el.reactorRiskNotice.classList.add("bad");
  }
}

function applyReactorSliderUi() {
  ui.visualMaster = normalizeVisualMaster(ui.visualMaster);
  ui.dropIntensity = normalizeDropImpact(ui.dropIntensity);
  if (el.master) el.master.value = String(Math.round(ui.visualMaster * 50));
  if (el.dropIntensity) el.dropIntensity.value = String(Math.round(ui.dropIntensity * 100));
  if (el.masterVal) el.masterVal.textContent = ui.visualMaster.toFixed(2);
  if (el.dropVal) el.dropVal.textContent = ui.dropIntensity.toFixed(1);
  updateReactorRiskNotice();
}

function resetReactorControls(mode = "both") {
  if (mode === "master" || mode === "both") {
    ui.visualMaster = REACTOR_DEFAULTS.master;
  }
  if (mode === "drop" || mode === "both") {
    ui.dropIntensity = REACTOR_DEFAULTS.dropImpact;
  }
  applyReactorSliderUi();
}

/* SLIDERS */
el.master.oninput = () => {
  ui.visualMaster = normalizeVisualMaster(Number(el.master.value) / 50);
  applyReactorSliderUi();
};
el.master.ondblclick = () => {
  resetReactorControls("master");
  setBadge(el.health, "ok", "MASTER RESET TO 1.00");
};

el.flowIntensity.oninput = () => {
  ui.flowIntensity = clampFlowIntensity(Number(el.flowIntensity.value) / 100);
  ui.flowIntensityInputUntil = Date.now() + 900;
  applyFlowIntensityUi();

  if (flowIntensityCommitTimer) clearTimeout(flowIntensityCommitTimer);
  flowIntensityCommitTimer = setTimeout(() => {
    commitFlowIntensity({ silent: true });
  }, 170);
};

el.flowIntensity.onchange = () => {
  if (flowIntensityCommitTimer) {
    clearTimeout(flowIntensityCommitTimer);
    flowIntensityCommitTimer = null;
  }
  commitFlowIntensity({ silent: false });
};
el.flowIntensity.ondblclick = () => {
  resetFlowIntensity({ silent: false });
};

el.dropIntensity.oninput = () => {
  ui.dropIntensity = normalizeDropImpact(Number(el.dropIntensity.value) / 100);
  applyReactorSliderUi();
};
el.dropIntensity.ondblclick = () => {
  resetReactorControls("drop");
  setBadge(el.health, "ok", "DROP IMPACT RESET TO 1.0");
};

el.masterInlineResetBtn.onclick = () => {
  resetReactorControls("master");
  setBadge(el.health, "ok", "MASTER RESET TO 1.00");
};

el.flowResetBtn.onclick = () => {
  resetFlowIntensity({ silent: false });
};

el.dropInlineResetBtn.onclick = () => {
  resetReactorControls("drop");
  setBadge(el.health, "ok", "DROP IMPACT RESET TO 1.0");
};

el.reactorResetBtn.onclick = () => {
  resetReactorControls("both");
  setBadge(el.health, "ok", "REACTOR SLIDERS RESET");
};

/* OSCILLOSCOPE */
const mainScopeCtx = el.canvas.getContext("2d");
const telemetryScopeCtx = el.telemetryCanvas.getContext("2d");
const SCOPE_MAX_PIXEL_RATIO = 1.0;
const MAIN_SCOPE_MAX_FPS = 24;
const MAIN_SCOPE_FRAME_MS = Math.round(1000 / MAIN_SCOPE_MAX_FPS);
const telemetrySeriesMax = 240;
const telemetrySeries = {
  energy: [],
  rms: [],
  flux: [],
  hueLat: [],
  wizLat: [],
  drop: []
};

let telemetryGridCache = null;
let mainGridCache = null;

function getCanvasResolutionScale() {
  const dpr = Math.max(1, Number(window.devicePixelRatio) || 1);
  return Math.min(1, SCOPE_MAX_PIXEL_RATIO / dpr);
}

function resizeOneCanvas(canvas) {
  const scale = getCanvasResolutionScale();
  const nextW = Math.max(1, Math.floor(canvas.offsetWidth * scale));
  const nextH = Math.max(1, Math.floor(canvas.offsetHeight * scale));
  if (canvas.width !== nextW) canvas.width = nextW;
  if (canvas.height !== nextH) canvas.height = nextH;
}

function rebuildTelemetryGridCache() {
  const w = el.telemetryCanvas.width;
  const h = el.telemetryCanvas.height;
  if (!w || !h) return;

  const cache = document.createElement("canvas");
  cache.width = w;
  cache.height = h;
  const ctx = cache.getContext("2d");

  ctx.fillStyle = "#030711";
  ctx.fillRect(0, 0, w, h);
  ctx.strokeStyle = "#17213d";
  ctx.lineWidth = 1;

  for (let i = 1; i < 6; i++) {
    const y = (i / 6) * h;
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(w, y);
    ctx.stroke();
  }

  for (let i = 1; i < 12; i++) {
    const x = (i / 12) * w;
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, h);
    ctx.stroke();
  }

  telemetryGridCache = cache;
}

function rebuildMainGridCache() {
  const w = el.canvas.width;
  const h = el.canvas.height;
  if (!w || !h) return;

  const cache = document.createElement("canvas");
  cache.width = w;
  cache.height = h;
  const ctx = cache.getContext("2d");

  ctx.fillStyle = "#030711";
  ctx.fillRect(0, 0, w, h);

  ctx.strokeStyle = "rgba(23,33,61,0.85)";
  ctx.lineWidth = 1;
  for (let i = 1; i < 8; i++) {
    const y = (i / 8) * h;
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(w, y);
    ctx.stroke();
  }
  for (let i = 1; i < 14; i++) {
    const x = (i / 14) * w;
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, h);
    ctx.stroke();
  }

  // Scope center reference
  ctx.strokeStyle = "rgba(70,96,148,0.55)";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(0, h * 0.5);
  ctx.lineTo(w, h * 0.5);
  ctx.stroke();

  mainGridCache = cache;
}

function resizeCanvas() {
  resizeOneCanvas(el.canvas);
  resizeOneCanvas(el.telemetryCanvas);
  rebuildMainGridCache();
  rebuildTelemetryGridCache();
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

const clamp01 = v => Math.min(1, Math.max(0, Number(v) || 0));
const scopeInput = {
  energy: 0.05,
  rms: 0.03,
  transient: 0,
  flux: 0,
  beat: 0,
  low: 0,
  mid: 0,
  high: 0,
  drop: false
};
const scopeState = {
  energy: 0.05,
  rms: 0.03,
  transient: 0,
  flux: 0,
  beat: 0,
  low: 0,
  mid: 0,
  high: 0
};

function updateMainScopeInput(t, a) {
  scopeInput.energy = clamp01((Number(t?.energy || 0) / 1.2));
  scopeInput.rms = clamp01(a?.level ?? t?.rms ?? 0);
  scopeInput.transient = clamp01(a?.transient ?? t?.audioTransient ?? 0);
  scopeInput.flux = clamp01(a?.spectralFlux ?? t?.audioFlux ?? 0);
  scopeInput.beat = clamp01((Number(t?.beatConfidence || 0) || 0));
  scopeInput.low = clamp01(a?.bandLow ?? t?.audioBandLow ?? scopeInput.rms);
  scopeInput.mid = clamp01(a?.bandMid ?? t?.audioBandMid ?? scopeInput.rms * 0.9);
  scopeInput.high = clamp01(a?.bandHigh ?? t?.audioBandHigh ?? scopeInput.rms * 0.8);
  scopeInput.drop = Boolean(t?.drop);
}

function updateScopeHud(t, a) {
  const rms = clamp01(a?.level ?? t?.rms ?? 0);
  const eng = clamp01((Number(t?.energy || 0) / 1.2));
  const tr = clamp01(a?.transient ?? t?.audioTransient ?? 0);
  const flx = clamp01(a?.spectralFlux ?? t?.audioFlux ?? 0);
  const beat = clamp01(Number(t?.beatConfidence || 0));
  const drive = clamp01(rms * 0.46 + eng * 0.42 + tr * 0.12);
  const motion = clamp01(tr * 0.46 + flx * 0.34 + beat * 0.2);

  el.scopeDrive.textContent = drive.toFixed(2);
  el.scopeMotion.textContent = motion.toFixed(2);
  el.scopeScene.textContent = String(t?.scene || "-").replace(/^flow_/, "F:");
  el.scopeBehav.textContent = String(t?.behavior || "-").toUpperCase();
}

let ph = 0;
let mainScopeAnim = null;
let mainScopeLastFrameAt = 0;

function monitorsActive() {
  return ui.activeTab === "live" && !document.hidden;
}

function drawWave() {
  const w = el.canvas.width;
  const h = el.canvas.height;
  if (!w || !h) return;

  scopeState.energy += (scopeInput.energy - scopeState.energy) * 0.16;
  scopeState.rms += (scopeInput.rms - scopeState.rms) * 0.2;
  scopeState.transient += (scopeInput.transient - scopeState.transient) * 0.22;
  scopeState.flux += (scopeInput.flux - scopeState.flux) * 0.18;
  scopeState.beat += (scopeInput.beat - scopeState.beat) * 0.2;
  scopeState.low += (scopeInput.low - scopeState.low) * 0.2;
  scopeState.mid += (scopeInput.mid - scopeState.mid) * 0.2;
  scopeState.high += (scopeInput.high - scopeState.high) * 0.2;

  const drop = scopeInput.drop;
  const drive = clamp01(
    scopeState.rms * 0.44 +
    scopeState.energy * 0.36 +
    scopeState.transient * 0.12 +
    scopeState.beat * 0.08
  );
  const motion = clamp01(
    scopeState.transient * 0.46 +
    scopeState.flux * 0.34 +
    scopeState.beat * 0.2
  );
  const gain = ui.visualMaster * (drop ? ui.dropIntensity : 1);

  mainScopeCtx.clearRect(0, 0, w, h);
  if (!mainGridCache || mainGridCache.width !== w || mainGridCache.height !== h) {
    rebuildMainGridCache();
  }
  if (mainGridCache) {
    mainScopeCtx.drawImage(mainGridCache, 0, 0);
  } else {
    mainScopeCtx.fillStyle = "#030711";
    mainScopeCtx.fillRect(0, 0, w, h);
  }

  const centerY = h * 0.5;
  const maxAmp = h * 0.34;
  const amp = Math.max(1.5, maxAmp * (0.04 + drive * 0.38 + motion * 0.52) * gain);

  // Keep points bounded for GPU/CPU friendliness.
  const points = Math.max(72, Math.min(160, Math.floor(w / 4)));
  const step = w / Math.max(1, points - 1);

  const drawTrace = (color, width, fn) => {
    mainScopeCtx.strokeStyle = color;
    mainScopeCtx.lineWidth = width;
    mainScopeCtx.beginPath();
    for (let i = 0; i < points; i++) {
      const x = i * step;
      const t = i / Math.max(1, points - 1);
      const y = fn(x, t);
      if (i === 0) mainScopeCtx.moveTo(x, y);
      else mainScopeCtx.lineTo(x, y);
    }
    mainScopeCtx.stroke();
  };

  const lowWeight = clamp01(0.35 + scopeState.low * 0.85);
  const midWeight = clamp01(0.35 + scopeState.mid * 0.85);
  const highWeight = clamp01(0.3 + scopeState.high * 0.92);
  const baseFreq = 0.012 + scopeState.beat * 0.02 + scopeState.transient * 0.012;
  const modFreq = 0.034 + scopeState.flux * 0.042;

  drawTrace("rgba(26,220,255,0.88)", 1.2, (x, t) => {
    const y =
      centerY +
      Math.sin(x * baseFreq + ph * 0.09) * amp * 0.58 * lowWeight +
      Math.sin(x * 0.006 + ph * 0.05) * amp * 0.22 * scopeState.low;
    return y;
  });

  drawTrace("rgba(255,74,122,0.92)", drop ? 1.8 : 1.5, (x, t) => {
    const y =
      centerY +
      Math.sin(x * (baseFreq * 1.45) + ph * 0.15 + 0.7) * amp * 0.64 * midWeight +
      Math.sin(x * modFreq + ph * 0.22) * amp * 0.18 * scopeState.transient;
    return y;
  });

  drawTrace("rgba(255,210,72,0.82)", 1.1, (x, t) => {
    const y =
      centerY +
      Math.sin(x * (baseFreq * 2.4) + ph * 0.24 + 1.7) * amp * 0.46 * highWeight +
      Math.sin(x * (modFreq * 1.6) + ph * 0.3) * amp * 0.15 * scopeState.high;
    return y;
  });

  drawTrace(drop ? "rgba(255,245,245,0.9)" : "rgba(198,226,255,0.72)", drop ? 2.2 : 1.6, (x, t) => {
    const low = Math.sin(x * baseFreq + ph * 0.09) * 0.42 * lowWeight;
    const mid = Math.sin(x * (baseFreq * 1.45) + ph * 0.15 + 0.7) * 0.34 * midWeight;
    const high = Math.sin(x * (baseFreq * 2.4) + ph * 0.24 + 1.7) * 0.24 * highWeight;
    const transientLift = Math.sin(x * modFreq + ph * 0.26) * 0.2 * scopeState.transient;
    return centerY + (low + mid + high + transientLift) * amp;
  });

  if (drop || motion > 0.58) {
    const pulseSpacing = Math.max(16, Math.round(w / 18));
    mainScopeCtx.strokeStyle = drop ? "rgba(255,255,255,0.26)" : "rgba(80,205,255,0.18)";
    mainScopeCtx.lineWidth = 1;
    for (let x = pulseSpacing; x < w; x += pulseSpacing) {
      if (((x / pulseSpacing) | 0) % 2 === 0 && !drop) continue;
      mainScopeCtx.beginPath();
      mainScopeCtx.moveTo(x, centerY - amp * (0.24 + motion * 0.24));
      mainScopeCtx.lineTo(x, centerY + amp * (0.24 + motion * 0.24));
      mainScopeCtx.stroke();
    }
  }

  ph += 0.8 + scopeState.transient * 1.45 + scopeState.flux * 1.05 + scopeState.beat * 1.1 + (drop ? 0.6 : 0);
}

function renderMainScope(now = performance.now()) {
  if (!monitorsActive()) {
    mainScopeAnim = null;
    mainScopeLastFrameAt = 0;
    return;
  }

  if (!mainScopeLastFrameAt || (now - mainScopeLastFrameAt) >= MAIN_SCOPE_FRAME_MS) {
    drawWave();
    mainScopeLastFrameAt = now;
  }

  mainScopeAnim = requestAnimationFrame(renderMainScope);
}

function updateMonitorRenderingState() {
  if (monitorsActive()) {
    if (!mainScopeAnim) {
      mainScopeAnim = requestAnimationFrame(renderMainScope);
    }
    drawTelemetryScope();
    return;
  }

  if (mainScopeAnim) {
    cancelAnimationFrame(mainScopeAnim);
    mainScopeAnim = null;
  }
  mainScopeLastFrameAt = 0;
}

function pushScopeSample(t, h, w, a) {
  const energy = Math.min(1, Math.max(0, Number(t?.energy || 0) / 1.2));
  const rms = Math.min(1, Math.max(0, Number(t?.rms || 0)));
  const flux = Math.min(1, Math.max(0, Number(a?.spectralFlux || 0)));
  const hueLat = Math.min(1, Math.max(0, Number(h?.lastDurationMs || 0) / 180));
  const wizLat = Math.min(1, Math.max(0, Number(w?.lastDurationMs || 0) / 120));
  const drop = Boolean(t?.drop);

  telemetrySeries.energy.push(energy);
  telemetrySeries.rms.push(rms);
  telemetrySeries.flux.push(flux);
  telemetrySeries.hueLat.push(hueLat);
  telemetrySeries.wizLat.push(wizLat);
  telemetrySeries.drop.push(drop ? 1 : 0);

  for (const key of Object.keys(telemetrySeries)) {
    if (telemetrySeries[key].length > telemetrySeriesMax) {
      telemetrySeries[key].shift();
    }
  }
}

function drawScopeLine(values, color, width = 1.4) {
  const w = el.telemetryCanvas.width;
  const h = el.telemetryCanvas.height;
  const len = values.length;
  if (!len) return;

  telemetryScopeCtx.strokeStyle = color;
  telemetryScopeCtx.lineWidth = width;
  telemetryScopeCtx.beginPath();
  for (let i = 0; i < len; i++) {
    const x = (i / Math.max(1, telemetrySeriesMax - 1)) * w;
    const y = h - values[i] * h;
    if (i === 0) telemetryScopeCtx.moveTo(x, y);
    else telemetryScopeCtx.lineTo(x, y);
  }
  telemetryScopeCtx.stroke();
}

function drawTelemetryScope() {
  const w = el.telemetryCanvas.width;
  const h = el.telemetryCanvas.height;
  if (!w || !h) return;

  telemetryScopeCtx.clearRect(0, 0, w, h);
  if (!telemetryGridCache || telemetryGridCache.width !== w || telemetryGridCache.height !== h) {
    rebuildTelemetryGridCache();
  }
  if (telemetryGridCache) {
    telemetryScopeCtx.drawImage(telemetryGridCache, 0, 0);
  } else {
    telemetryScopeCtx.fillStyle = "#030711";
    telemetryScopeCtx.fillRect(0, 0, w, h);
  }

  drawScopeLine(telemetrySeries.energy, "#ff334f", 1.8);
  drawScopeLine(telemetrySeries.rms, "#22d7ff", 1.5);
  drawScopeLine(telemetrySeries.flux, "#ffd34e", 1.4);
  drawScopeLine(telemetrySeries.hueLat, "#ff8c3a", 1.3);
  drawScopeLine(telemetrySeries.wizLat, "#38ff9f", 1.3);

  telemetryScopeCtx.strokeStyle = "rgba(255,255,255,0.4)";
  telemetryScopeCtx.lineWidth = 1;
  const drops = telemetrySeries.drop;
  for (let i = 0; i < drops.length; i++) {
    if (!drops[i]) continue;
    const x = (i / Math.max(1, telemetrySeriesMax - 1)) * w;
    telemetryScopeCtx.beginPath();
    telemetryScopeCtx.moveTo(x, 0);
    telemetryScopeCtx.lineTo(x, h);
    telemetryScopeCtx.stroke();
  }
}

function sync() {
  el.onBtn.classList.toggle("active", ui.raveOn);
  el.offBtn.classList.toggle("active", !ui.raveOn);

  el.modeAutoBtn.classList.toggle("active", ui.modeLock === "auto");
  el.gameBtn.classList.toggle("active", ui.modeLock === "clamp");
  el.bpmBtn.classList.toggle("active", ui.modeLock === "interpret");
  el.metaAutoOnBtn.classList.toggle("active", ui.metaAutoEnabled);
  el.metaAutoOffBtn.classList.toggle("active", !ui.metaAutoEnabled);
  const metaGenreLabel = String(ui.metaAutoGenre || "auto").toUpperCase();
  const metaReasonLabel = String(ui.metaAutoReason || "").toUpperCase();
  const metaHzNum = Number(ui.metaAutoHz);
  const metaHzLabel = Number.isFinite(metaHzNum)
    ? `${metaHzNum.toFixed(1).replace(/\.0$/, "")}HZ`
    : "";
  el.metaAutoStat.textContent = ui.metaAutoEnabled
    ? `ON ${metaGenreLabel}${metaReasonLabel ? ` ${metaReasonLabel}` : ""}${metaHzLabel ? ` ${metaHzLabel}` : ""}`.trim()
    : "OFF";
  el.flowStat.textContent = `${Number(ui.flowIntensity || 1).toFixed(2)}x`;
  if (el.dropBtn) {
    const dropEnabled = Boolean(ui.audioReactivityMap?.dropEnabled);
    el.dropBtn.disabled = !dropEnabled;
    el.dropBtn.title = dropEnabled
      ? "Trigger one manual drop hit event for testing visuals."
      : "Drop trigger disabled. Enable DROP REACTIVE in audio reactivity map.";
  }

  autoProfileButtons.forEach(btn => {
    btn.classList.toggle("active", btn.dataset.autoProfile === ui.autoProfile);
  });

  audioReactivityButtons.forEach(btn => {
    btn.classList.toggle("active", btn.dataset.audioReactivity === ui.audioReactivityPreset);
  });

  audioQuickPresetButtons.forEach(btn => {
    btn.classList.toggle("active", btn.dataset.audioQuick === ui.audioQuickProfile);
  });

  limiterPresetButtons.forEach(btn => {
    btn.classList.toggle("active", btn.dataset.limiterPreset === ui.limiterPreset);
  });

  el.ocLudicrousBtn.classList.toggle("active", ui.overclockLevel === 7);
  if (el.ocDevCluster) {
    el.ocDevCluster.classList.toggle("hidden", !ui.devDebugMode);
  }
  if (el.devToolsPanel) {
    el.devToolsPanel.classList.toggle("hidden", !ui.devDebugMode);
  }
  if (el.devDebugToggleBtn) {
    el.devDebugToggleBtn.classList.toggle("active", ui.devDebugMode);
  }
  if (el.ocDev20Btn) el.ocDev20Btn.classList.toggle("active", ui.overclockLevel === 8);
  if (el.ocDev30Btn) el.ocDev30Btn.classList.toggle("active", ui.overclockLevel === 9);
  if (el.ocDev40Btn) el.ocDev40Btn.classList.toggle("active", ui.overclockLevel === 10);
  if (el.ocDev50Btn) el.ocDev50Btn.classList.toggle("active", ui.overclockLevel === 11);
  if (el.ocDev60Btn) el.ocDev60Btn.classList.toggle("active", ui.overclockLevel === 12);
  el.ocHyperBtn.classList.toggle("active", ui.overclockLevel === 6);
  el.ocInsaneBtn.classList.toggle("active", ui.overclockLevel === 5);
  el.ocExtremeBtn.classList.toggle("active", ui.overclockLevel === 4);
  el.ocUltraBtn.classList.toggle("active", ui.overclockLevel === 3);
  el.ocTurboBtn.classList.toggle("active", ui.overclockLevel === 2);
  el.ocOnBtn.classList.toggle("active", ui.overclockLevel === 1);
  el.ocOffBtn.classList.toggle("active", ui.overclockLevel === 0);

  sceneButtons.forEach(btn => {
    const scene = btn.dataset.scene;
    btn.classList.toggle("active", scene === ui.sceneLock);
  });
  const sceneSyncLabels = getSceneSyncLabelContext();
  if (el.sceneSyncOnBtn) {
    el.sceneSyncOnBtn.classList.toggle("active", Boolean(ui.wizSceneSync));
    el.sceneSyncOnBtn.textContent = sceneSyncLabels.syncButton;
  }
  if (el.sceneSyncOffBtn) {
    el.sceneSyncOffBtn.classList.toggle("active", !Boolean(ui.wizSceneSync));
    el.sceneSyncOffBtn.textContent = sceneSyncLabels.desyncButton;
  }
  if (el.sceneSyncStat) {
    el.sceneSyncStat.textContent = Boolean(ui.wizSceneSync)
      ? sceneSyncLabels.statusSynced
      : sceneSyncLabels.statusDesynced;
  }

  getGenreButtons().forEach(btn => {
    btn.classList.toggle("active", btn.dataset.genre === ui.genre);
  });
  decadeButtons.forEach(btn => {
    btn.classList.toggle("active", btn.dataset.decadeMode === ui.genreDecadeMode);
  });

  const resolvedDecade = String(ui.genreDecadeResolved || "10s").toUpperCase();
  el.decadeStat.textContent = ui.genreDecadeMode === "auto"
    ? `AUTO ${resolvedDecade}`
    : String(ui.genreDecadeMode || "auto").toUpperCase();

  el.sceneLockStat.textContent = ui.sceneLock === "auto"
    ? "AUTO"
    : ui.sceneLock.toUpperCase();
  updateAudioReactivityPolicyUi();
  updateReactorRiskNotice();
}

function updateFixtures(f) {
  const summary = f && f.summary ? f.summary : {};
  const routes = f?.routes || summary.routes || {};
  const snapshotHasFixturesArray = Array.isArray(f?.fixtures);
  const fixtures = Array.isArray(f?.fixtures)
    ? f.fixtures
    : (Array.isArray(ui.fixturesCatalog) ? ui.fixturesCatalog.slice() : []);
  const standalone = Array.isArray(f?.standalone)
    ? f.standalone
    : (Array.isArray(ui.standaloneFixtures) ? ui.standaloneFixtures.slice() : []);
  ui.fixtureModBrands = collectFixtureModBrandsFromSnapshot(summary, fixtures);
  ui.sceneSyncActiveBrands = collectActiveSceneSyncBrands(fixtures);
  syncFixtureBrandOptions();
  updateConnectivityCache(f?.connectivity || []);
  ui.connectivitySummary = f?.connectivitySummary || null;

  el.fixHue.textContent = String(summary.hue ?? 0);
  el.fixWiz.textContent = String(summary.wiz ?? 0);
  el.fixHueReady.textContent = String(summary.hueReady ?? 0);
  el.fixWizReady.textContent = String(summary.wizReady ?? 0);
  ui.engineReadyTargets = Number(summary.hueEngineReady ?? summary.hueReady ?? 0) +
    Number(summary.wizEngineReady ?? summary.wizReady ?? 0);
  ui.engineModeTargets = Number(summary.hueEngine ?? 0) + Number(summary.wizEngine ?? 0);
  el.routeHue.textContent = routes.HUE_STATE || "-";
  el.routeWiz.textContent = routes.WIZ_PULSE || "-";
  el.routeTwitchHue.textContent = routes.TWITCH_HUE || "-";
  el.routeTwitchWiz.textContent = routes.TWITCH_WIZ || "-";
  el.routeHueInput.value = routes.HUE_STATE || "hue";
  el.routeWizInput.value = routes.WIZ_PULSE || "wiz";
  el.routeTwitchHueInput.value = routes.TWITCH_HUE || "hue";
  el.routeTwitchWizInput.value = routes.TWITCH_WIZ || "wiz";
  el.cfgVer.textContent = String(summary.version ?? 0);
  el.cfgAt.textContent = summary.loadedAt
    ? new Date(summary.loadedAt).toLocaleTimeString()
    : "-";

  applyFixtureCatalogToUi(fixtures);
  renderStandaloneFixtures(standalone, { preserveDraft: true });
  ui.fixturesSnapshotLoaded = snapshotHasFixturesArray || fixtures.length > 0;
}

function detectAudioQuickProfile(config = {}) {
  const sampleRate = Number(config.sampleRate);
  const framesPerBuffer = Number(config.framesPerBuffer ?? config.frames);
  const profileName = Object.keys(AUDIO_QUICK_PROFILES).find(name => {
    const profile = AUDIO_QUICK_PROFILES[name];
    return (
      Number(profile.sampleRate) === sampleRate &&
      Number(profile.framesPerBuffer) === framesPerBuffer
    );
  });
  return profileName || "";
}

function syncAudioQuickPresetButtons() {
  const profileName = detectAudioQuickProfile({
    sampleRate: Number(el.aSampleRate?.value),
    framesPerBuffer: Number(el.aFrames?.value)
  });
  ui.audioQuickProfile = profileName || "";
  audioQuickPresetButtons.forEach(btn => {
    btn.classList.toggle("active", btn.dataset.audioQuick === profileName);
  });
}

function applyAudioQuickProfile(name) {
  const profile = AUDIO_QUICK_PROFILES[String(name || "").trim().toLowerCase()];
  if (!profile) return false;
  el.aSampleRate.value = String(profile.sampleRate);
  el.aFrames.value = String(profile.framesPerBuffer);
  syncAudioQuickPresetButtons();
  return true;
}

function applyAudioConfigToInputs(config = {}) {
  el.aDeviceMatch.value = config.deviceMatch || "";
  el.aDeviceId.value = config.deviceId === null || config.deviceId === undefined
    ? ""
    : String(config.deviceId);
  el.aSampleRate.value = String(config.sampleRate ?? "96000");
  el.aFrames.value = String(config.framesPerBuffer ?? "256");
  el.aChannels.value = String(config.channels ?? "2");
  el.aGain.value = String(config.outputGain ?? "1");
  el.aNoise.value = String(config.noiseFloorMin ?? "0.00045");
  el.aPeakDecay.value = String(config.peakDecay ?? "0.93");
  el.aBandLowHz.value = String(config.bandLowHz ?? "180");
  el.aBandMidHz.value = String(config.bandMidHz ?? "2200");
  el.aLimiterThreshold.value = String(config.limiterThreshold ?? "0.82");
  el.aLimiterKnee.value = String(config.limiterKnee ?? "0.16");
  el.aRestartMs.value = String(config.restartMs ?? "1500");
  el.aLogTicks.value = String(config.logEveryTicks ?? "60");
  ui.limiterPreset = detectLimiterPreset(config);
  ui.audioQuickProfile = detectAudioQuickProfile(config);
  syncAudioQuickPresetButtons();
}

function collectAudioConfigFromInputs() {
  const parsedId = el.aDeviceId.value.trim();
  return {
    deviceMatch: el.aDeviceMatch.value.trim().toLowerCase(),
    deviceId: parsedId === "" ? null : Number(parsedId),
    sampleRate: Number(el.aSampleRate.value),
    framesPerBuffer: Number(el.aFrames.value),
    channels: Number(el.aChannels.value),
    outputGain: Number(el.aGain.value),
    noiseFloorMin: Number(el.aNoise.value),
    peakDecay: Number(el.aPeakDecay.value),
    bandLowHz: Number(el.aBandLowHz.value),
    bandMidHz: Number(el.aBandMidHz.value),
    limiterThreshold: Number(el.aLimiterThreshold.value),
    limiterKnee: Number(el.aLimiterKnee.value),
    restartMs: Number(el.aRestartMs.value),
    logEveryTicks: Number(el.aLogTicks.value)
  };
}

function normalizeAudioReactivitySourceKeyUi(value) {
  const key = String(value || "").trim().toLowerCase();
  return Object.prototype.hasOwnProperty.call(audioReactivitySourceCatalogRuntime, key)
    ? key
    : "";
}

function normalizeAudioReactivitySourcesUi(value, fallback = ["smart"]) {
  const sourceList = Array.isArray(value)
    ? value
    : typeof value === "string"
      ? value.split(/[,\s]+/)
      : [];
  const out = [];
  for (const source of sourceList) {
    const key = normalizeAudioReactivitySourceKeyUi(source);
    if (!key) continue;
    if (!out.includes(key)) out.push(key);
    if (out.length >= 6) break;
  }
  if (out.length) return out;

  const fallbackList = Array.isArray(fallback) ? fallback : [fallback];
  const normalizedFallback = fallbackList
    .map(normalizeAudioReactivitySourceKeyUi)
    .filter(Boolean);
  return normalizedFallback.length ? [...new Set(normalizedFallback)] : ["smart"];
}

function normalizeAudioReactivityMapUi(input = {}) {
  const raw = input && typeof input === "object" ? input : {};
  const rawTargets = raw.targets && typeof raw.targets === "object" ? raw.targets : {};
  const fallbackTargets = AUDIO_REACTIVITY_MAP_DEFAULT.targets || {};
  const targets = {};
  for (const target of AUDIO_REACTIVITY_TARGET_KEYS) {
    const targetRaw = rawTargets[target] && typeof rawTargets[target] === "object"
      ? rawTargets[target]
      : {};
    const fallback = fallbackTargets[target] || {};
    targets[target] = {
      enabled: parseLooseBoolean(targetRaw.enabled, parseLooseBoolean(fallback.enabled, true)),
      amount: clampNumber(targetRaw.amount, 0, 1.8, clampNumber(fallback.amount, 0, 1.8, 1)),
      sources: normalizeAudioReactivitySourcesUi(targetRaw.sources, fallback.sources || ["smart"])
    };
  }
  return {
    version: 1,
    dropEnabled: parseLooseBoolean(raw.dropEnabled, false),
    hardwareRateLimitsEnabled: parseLooseBoolean(
      raw.hardwareRateLimitsEnabled,
      parseLooseBoolean(AUDIO_REACTIVITY_MAP_DEFAULT.hardwareRateLimitsEnabled, true)
    ),
    targets
  };
}

function getLiveOverclockBand(level = ui.overclockLevel) {
  const hzLevel = Number(level);
  if (!Number.isFinite(hzLevel) || hzLevel <= 1) return "low";
  if (hzLevel >= 4) return "high";
  return "medium";
}

function pushSourcesIntoScoreMap(scoreMap, sources = [], weight = 1) {
  const w = Number(weight);
  if (!Number.isFinite(w) || w <= 0) return;
  for (let i = 0; i < sources.length; i++) {
    const key = normalizeAudioReactivitySourceKeyUi(sources[i]);
    if (!key) continue;
    scoreMap[key] = Number(scoreMap[key] || 0) + (w * (1 - (i * 0.1)));
  }
}

function createLiveSourceScoreMap(target = "other") {
  const targetKey = AUDIO_REACTIVITY_TARGET_KEYS.includes(String(target || "").toLowerCase())
    ? String(target || "").toLowerCase()
    : "other";
  const scoreMap = {};
  for (const source of AUDIO_REACTIVITY_SOURCE_ORDER) {
    scoreMap[source] = 0;
  }
  scoreMap.smart += 1.4;
  scoreMap.groove += 0.45;
  scoreMap.beat += 0.75;

  const modeKey = String(ui.modeLock || "auto").toLowerCase();
  const profileKey = String(ui.autoProfile || "balanced").toLowerCase();
  const reactKey = String(ui.audioReactivityPreset || "balanced").toLowerCase();
  const sceneRaw = String(ui.sceneLock || "auto").toLowerCase();
  const sceneKey = sceneRaw === "flow" ? "flow" : (sceneRaw || "auto");
  const genreKey = String(ui.genre || "auto").toLowerCase();
  const decadeKey = String(ui.genreDecadeMode || "auto").toLowerCase();
  const overclockBand = getLiveOverclockBand(ui.overclockLevel);
  const rave = ui.lastRaveTelemetry && typeof ui.lastRaveTelemetry === "object"
    ? ui.lastRaveTelemetry
    : {};
  const audio = ui.lastAudioTelemetry && typeof ui.lastAudioTelemetry === "object"
    ? ui.lastAudioTelemetry
    : {};
  const rms = clampNumber(Number(rave.rms ?? audio.level), 0, 1, 0);
  const drive = clampNumber(Number(rave.energy), 0, 1, rms);
  const transient = clampNumber(Number(rave.audioTransient ?? audio.transient), 0, 1.2, 0) / 1.2;
  const peak = clampNumber(Number(rave.audioPeak ?? audio.peak), 0, 1.5, 0) / 1.5;
  const flux = clampNumber(Number(rave.audioFlux ?? audio.spectralFlux), 0, 1, 0);
  const low = clampNumber(Number(rave.audioBandLow ?? audio.bandLow), 0, 1, 0);
  const mid = clampNumber(Number(rave.audioBandMid ?? audio.bandMid), 0, 1, 0);
  const high = clampNumber(Number(rave.audioBandHigh ?? audio.bandHigh), 0, 1, 0);
  const beat = clampNumber(Number(rave.beatConfidence), 0, 1, rave.beat ? 0.62 : 0);
  const motion = Math.max(transient, flux, peak, beat);

  pushSourcesIntoScoreMap(
    scoreMap,
    LIVE_REACTIVITY_SOURCE_BY_STATE.modeLock[modeKey] || LIVE_REACTIVITY_SOURCE_BY_STATE.modeLock.auto,
    LIVE_REACTIVITY_STATE_WEIGHT.modeLock
  );
  pushSourcesIntoScoreMap(
    scoreMap,
    LIVE_REACTIVITY_SOURCE_BY_STATE.autoProfile[profileKey] || LIVE_REACTIVITY_SOURCE_BY_STATE.autoProfile.balanced,
    LIVE_REACTIVITY_STATE_WEIGHT.autoProfile
  );
  pushSourcesIntoScoreMap(
    scoreMap,
    LIVE_REACTIVITY_SOURCE_BY_STATE.audioReactivityPreset[reactKey] || LIVE_REACTIVITY_SOURCE_BY_STATE.audioReactivityPreset.balanced,
    LIVE_REACTIVITY_STATE_WEIGHT.audioReactivityPreset
  );
  pushSourcesIntoScoreMap(
    scoreMap,
    LIVE_REACTIVITY_SOURCE_BY_STATE.sceneLock[sceneKey] || LIVE_REACTIVITY_SOURCE_BY_STATE.sceneLock.auto,
    LIVE_REACTIVITY_STATE_WEIGHT.sceneLock
  );
  pushSourcesIntoScoreMap(
    scoreMap,
    LIVE_REACTIVITY_SOURCE_BY_STATE.genre[genreKey] || LIVE_REACTIVITY_SOURCE_BY_STATE.genre.auto,
    LIVE_REACTIVITY_STATE_WEIGHT.genre
  );
  pushSourcesIntoScoreMap(
    scoreMap,
    LIVE_REACTIVITY_SOURCE_BY_STATE.genreDecadeMode[decadeKey] || LIVE_REACTIVITY_SOURCE_BY_STATE.genreDecadeMode.auto,
    LIVE_REACTIVITY_STATE_WEIGHT.genreDecadeMode
  );
  pushSourcesIntoScoreMap(
    scoreMap,
    LIVE_REACTIVITY_SOURCE_BY_STATE.overclockBand[overclockBand] || LIVE_REACTIVITY_SOURCE_BY_STATE.overclockBand.medium,
    LIVE_REACTIVITY_STATE_WEIGHT.overclockBand
  );

  if (drive > 0.24) {
    pushSourcesIntoScoreMap(scoreMap, ["drums", "transients", "beat"], 0.62);
  }
  if (drive > 0.4 || motion > 0.5) {
    pushSourcesIntoScoreMap(scoreMap, ["peaks", "transients", "drums"], 0.84);
  }
  if (transient > 0.24) {
    pushSourcesIntoScoreMap(scoreMap, ["transients", "drums", "peaks"], 0.72);
  }
  if (flux > 0.2) {
    pushSourcesIntoScoreMap(scoreMap, ["flux", "transients", "peaks"], 0.62);
  }
  if (beat > 0.32) {
    pushSourcesIntoScoreMap(scoreMap, ["beat", "drums", "peaks"], 0.68);
  }
  if (low > 0.3) {
    pushSourcesIntoScoreMap(scoreMap, ["bass", "drums", "groove"], 0.58);
  }
  if (mid > 0.32) {
    pushSourcesIntoScoreMap(scoreMap, ["mids", "vocals", "groove"], 0.42);
  }
  if (high > 0.28) {
    pushSourcesIntoScoreMap(scoreMap, ["highs", "transients", "flux"], 0.5);
  }
  if (drive < 0.13 && motion < 0.2) {
    pushSourcesIntoScoreMap(scoreMap, ["baseline", "smart"], 0.45);
  }

  const targetBias = LIVE_REACTIVITY_TARGET_BIAS[targetKey] || LIVE_REACTIVITY_TARGET_BIAS.other;
  for (const source of AUDIO_REACTIVITY_SOURCE_ORDER) {
    scoreMap[source] = Number(scoreMap[source] || 0) + Number(targetBias[source] || 0);
  }
  return scoreMap;
}

function deriveLiveCompatibleSourcesByTarget() {
  const result = {
    hue: ["smart"],
    wiz: ["smart"],
    other: ["smart"]
  };
  for (const target of AUDIO_REACTIVITY_TARGET_KEYS) {
    const scoreMap = createLiveSourceScoreMap(target);
    const sorted = AUDIO_REACTIVITY_SOURCE_ORDER.slice()
      .filter(source => normalizeAudioReactivitySourceKeyUi(source))
      .sort((a, b) => {
        const diff = Number(scoreMap[b] || 0) - Number(scoreMap[a] || 0);
        if (Math.abs(diff) > 0.0001) return diff;
        return a.localeCompare(b);
      });
    const chosen = [];
    for (const source of sorted) {
      if (chosen.length >= 4) break;
      if (!chosen.includes(source)) chosen.push(source);
    }
    if (!chosen.includes("smart")) chosen.unshift("smart");
    result[target] = normalizeAudioReactivitySourcesUi(chosen, ["smart"]);
  }
  return result;
}

function getAllowedCompatibilitySetForTarget(target = "other") {
  const compatByTarget = deriveLiveCompatibleSourcesByTarget();
  const key = AUDIO_REACTIVITY_TARGET_KEYS.includes(String(target || "").toLowerCase())
    ? String(target || "").toLowerCase()
    : "other";
  const allowed = compatByTarget[key] || ["smart"];
  return new Set(normalizeAudioReactivitySourcesUi(allowed, ["smart"]));
}

function updateAudioReactivityPolicyUi() {
  if (el.reactSmartMatchEnabled) el.reactSmartMatchEnabled.checked = ui.reactSmartMatchEnabled === true;
  if (el.reactForceLockEnabled) el.reactForceLockEnabled.checked = ui.reactForceLockEnabled === true;
  if (el.reactForceMatchOverride) el.reactForceMatchOverride.checked = ui.reactForceMatchOverride === true;
  const cfg = normalizeAudioReactivityMapUi(ui.audioReactivityMap || AUDIO_REACTIVITY_MAP_DEFAULT);
  if (el.reactHardwareRateLimitsEnabled) {
    el.reactHardwareRateLimitsEnabled.checked = cfg.hardwareRateLimitsEnabled !== false;
  }

  if (el.reactCompatSummary) {
    const compat = deriveLiveCompatibleSourcesByTarget();
    const hardwareWord = cfg.hardwareRateLimitsEnabled ? "HW CAPS ON" : "HW CAPS OFF";
    const modeWord = ui.reactSmartMatchEnabled ? "SMART MATCH ON" : "SMART MATCH OFF";
    const forceWord = ui.reactForceLockEnabled ? "FORCE SINGLE ON" : "FORCE SINGLE OFF";
    const overrideWord = ui.reactForceMatchOverride ? "OVERRIDE ON" : "OVERRIDE OFF";
    el.reactCompatSummary.textContent = [
      hardwareWord,
      modeWord,
      forceWord,
      overrideWord,
      `HUE:${compat.hue.join("/")}`,
      `WIZ:${compat.wiz.join("/")}`,
      `CUSTOM:${compat.other.join("/")}`
    ].join(" | ");
  }
}

function applyAudioReactivityPolicyConstraints(options = {}) {
  const autoMatch = options.autoMatch === true;
  const config = normalizeAudioReactivityMapUi(ui.audioReactivityMap || AUDIO_REACTIVITY_MAP_DEFAULT);
  const compatByTarget = deriveLiveCompatibleSourcesByTarget();
  let changed = false;

  for (const target of AUDIO_REACTIVITY_TARGET_KEYS) {
    const row = config.targets[target] || { enabled: true, amount: 1, sources: ["smart"] };
    const compat = normalizeAudioReactivitySourcesUi(compatByTarget[target], ["smart"]);
    let nextSources = normalizeAudioReactivitySourcesUi(row.sources, ["smart"]);

    if (autoMatch) {
      nextSources = compat.slice(0, 3);
    }

    if (ui.reactForceLockEnabled) {
      if (!ui.reactForceMatchOverride) {
        nextSources = nextSources.filter(source => compat.includes(source));
      }
      const forcedSource = normalizeAudioReactivitySourcesUi(nextSources, compat)[0] || compat[0] || "smart";
      nextSources = [forcedSource];
    }

    if (!ui.reactForceLockEnabled && !nextSources.includes("smart")) {
      nextSources.unshift("smart");
      nextSources = normalizeAudioReactivitySourcesUi(nextSources, ["smart"]);
    }

    const before = normalizeAudioReactivitySourcesUi(row.sources, ["smart"]).join(",");
    const after = nextSources.join(",");
    if (before !== after) changed = true;
    config.targets[target].sources = nextSources;
  }

  if (changed) {
    applyAudioReactivityMapToUi(config, { markDirty: true });
  } else {
    updateAudioReactivityPolicyUi();
  }
  return changed;
}

async function persistAudioReactivityMapDraft(options = {}) {
  const reason = String(options.reason || "LIVE MATCH").trim().toUpperCase();
  const payload = collectAudioReactivityMapFromUi();
  const r = await postJson("/audio/reactivity-map", payload);
  if (!r.ok || !r.data?.config) {
    setBadge(el.health, "warn", `${reason} PENDING APPLY`);
    return false;
  }
  if (r.data.config.sourceCatalog && typeof r.data.config.sourceCatalog === "object") {
    audioReactivitySourceCatalogRuntime = {
      ...AUDIO_REACTIVITY_SOURCE_CATALOG_DEFAULT,
      ...r.data.config.sourceCatalog
    };
  }
  applyAudioReactivityMapToUi(r.data.config, { markDirty: false });
  ui.audioReactivityMapLoaded = true;
  setBadge(el.health, "ok", reason);
  return true;
}

function queueSmartMatchPersist(reason = "LIVE MATCH") {
  const normalizedReason = String(reason || "LIVE MATCH").trim().toUpperCase();
  if (liveSmartMatchSaveTimer) {
    clearTimeout(liveSmartMatchSaveTimer);
    liveSmartMatchSaveTimer = null;
  }
  liveSmartMatchSaveTimer = setTimeout(async () => {
    liveSmartMatchSaveTimer = null;
    if (liveSmartMatchSaveInFlight) {
      liveSmartMatchSaveQueued = true;
      return;
    }
    liveSmartMatchSaveInFlight = true;
    try {
      await persistAudioReactivityMapDraft({ reason: normalizedReason });
    } finally {
      liveSmartMatchSaveInFlight = false;
      if (liveSmartMatchSaveQueued) {
        liveSmartMatchSaveQueued = false;
        queueSmartMatchPersist("LIVE MATCH");
      }
    }
  }, 140);
}

function maybeApplySmartLiveReactivityPolicy(reason = "LIVE MATCH") {
  const changed = applyAudioReactivityPolicyConstraints({ autoMatch: ui.reactSmartMatchEnabled === true });
  if (ui.reactSmartMatchEnabled && changed) {
    queueSmartMatchPersist(reason);
  }
  return changed;
}

function computeSmartMatchTelemetryFingerprint() {
  const rave = ui.lastRaveTelemetry && typeof ui.lastRaveTelemetry === "object"
    ? ui.lastRaveTelemetry
    : {};
  const audio = ui.lastAudioTelemetry && typeof ui.lastAudioTelemetry === "object"
    ? ui.lastAudioTelemetry
    : {};
  const bucket = (value, low = 0.16, mid = 0.36, high = 0.62) => {
    const n = clampNumber(Number(value), 0, 1, 0);
    if (n >= high) return "x";
    if (n >= mid) return "h";
    if (n >= low) return "m";
    return "l";
  };

  const drive = clampNumber(Number(rave.energy), 0, 1, clampNumber(Number(rave.rms ?? audio.level), 0, 1, 0));
  const transient = clampNumber(Number(rave.audioTransient ?? audio.transient), 0, 1.2, 0) / 1.2;
  const flux = clampNumber(Number(rave.audioFlux ?? audio.spectralFlux), 0, 1, 0);
  const lowBand = clampNumber(Number(rave.audioBandLow ?? audio.bandLow), 0, 1, 0);
  const midBand = clampNumber(Number(rave.audioBandMid ?? audio.bandMid), 0, 1, 0);
  const highBand = clampNumber(Number(rave.audioBandHigh ?? audio.bandHigh), 0, 1, 0);
  const beat = clampNumber(Number(rave.beatConfidence), 0, 1, rave.beat ? 0.62 : 0);
  const motion = Math.max(transient, flux, beat);

  return [
    String(ui.modeLock || "auto"),
    String(ui.autoProfile || "balanced"),
    String(ui.audioReactivityPreset || "balanced"),
    String(ui.sceneLock || "auto"),
    String(ui.genre || "auto"),
    String(ui.genreDecadeMode || "auto"),
    getLiveOverclockBand(ui.overclockLevel),
    bucket(drive),
    bucket(motion, 0.2, 0.42, 0.66),
    bucket(lowBand, 0.2, 0.4, 0.62),
    bucket(midBand, 0.2, 0.38, 0.6),
    bucket(highBand, 0.2, 0.36, 0.58)
  ].join("|");
}

function maybeRetuneSmartMatchFromTelemetry() {
  if (!ui.reactSmartMatchEnabled) return;
  if (ui.audioReactivityMapDirty) return;
  const now = Date.now();
  if (now < Number(ui.smartMatchNextRetuneAt || 0)) return;
  ui.smartMatchNextRetuneAt = now + 1800;
  const fingerprint = computeSmartMatchTelemetryFingerprint();
  if (!fingerprint || fingerprint === ui.smartMatchFingerprint) return;
  ui.smartMatchFingerprint = fingerprint;
  maybeApplySmartLiveReactivityPolicy("SMART RETUNE");
}

function getAudioReactivityTargetUiRefs(target) {
  const key = String(target || "").trim().toLowerCase();
  if (key === "hue") {
    return {
      enabled: el.reactHueEnabled,
      amount: el.reactHueAmount,
      amountVal: el.reactHueAmountVal,
      sources: el.reactHueSources
    };
  }
  if (key === "wiz") {
    return {
      enabled: el.reactWizEnabled,
      amount: el.reactWizAmount,
      amountVal: el.reactWizAmountVal,
      sources: el.reactWizSources
    };
  }
  return {
    enabled: el.reactOtherEnabled,
    amount: el.reactOtherAmount,
    amountVal: el.reactOtherAmountVal,
    sources: el.reactOtherSources
  };
}

function setAudioReactivityMapStatus(text) {
  if (!el.reactMapStatus) return;
  el.reactMapStatus.value = String(text || "").trim();
}

function refreshAudioReactivityMapStatus() {
  const cfg = normalizeAudioReactivityMapUi(ui.audioReactivityMap || AUDIO_REACTIVITY_MAP_DEFAULT);
  const dropWord = cfg.dropEnabled ? "DROP ON" : "DROP OFF";
  const hardwareWord = cfg.hardwareRateLimitsEnabled ? "HW CAPS ON" : "HW CAPS OFF";
  const smartWord = ui.reactSmartMatchEnabled ? "SMART LIVE ON" : "SMART LIVE OFF";
  const forceWord = ui.reactForceLockEnabled ? "FORCE SINGLE ON" : "FORCE SINGLE OFF";
  const overrideWord = ui.reactForceMatchOverride ? "OVERRIDE ON" : "OVERRIDE OFF";
  const parts = [dropWord, hardwareWord, smartWord, forceWord, overrideWord];
  for (const target of AUDIO_REACTIVITY_TARGET_KEYS) {
    const row = cfg.targets[target] || {};
    const label = target === "other" ? "CUSTOM" : target.toUpperCase();
    const sources = Array.isArray(row.sources) && row.sources.length ? row.sources.join("+") : "smart";
    const amountWord = `${clampNumber(row.amount, 0, 1.8, 1).toFixed(2)}x`;
    parts.push(`${label}:${row.enabled ? sources : "off"}@${amountWord}`);
  }
  if (ui.audioReactivityMapDirty) {
    parts.push("UNSAVED");
  }
  setAudioReactivityMapStatus(parts.join(" | "));
  updateAudioReactivityPolicyUi();
}

function syncAudioReactivityAmountLabels() {
  const rows = [
    { slider: el.reactHueAmount, label: el.reactHueAmountVal },
    { slider: el.reactWizAmount, label: el.reactWizAmountVal },
    { slider: el.reactOtherAmount, label: el.reactOtherAmountVal }
  ];
  for (const row of rows) {
    if (!row.slider || !row.label) continue;
    const amount = clampNumber(Number(row.slider.value) / 100, 0, 1.8, 1);
    row.label.textContent = `${amount.toFixed(2)}x`;
  }
}

function markAudioReactivityMapDirty() {
  ui.audioReactivityMap = collectAudioReactivityMapFromUi();
  ui.audioReactivityMapDirty = true;
  refreshAudioReactivityMapStatus();
}

function renderAudioReactivitySourceButtons() {
  const sourceEntries = Object.entries(audioReactivitySourceCatalogRuntime || {});
  for (const target of AUDIO_REACTIVITY_TARGET_KEYS) {
    const refs = getAudioReactivityTargetUiRefs(target);
    if (!refs.sources) continue;
    const rowCfg = ui.audioReactivityMap?.targets?.[target] || AUDIO_REACTIVITY_MAP_DEFAULT.targets[target];
    const selected = normalizeAudioReactivitySourcesUi(rowCfg.sources, ["smart"]);
    const compatibleSet = getAllowedCompatibilitySetForTarget(target);
    refs.sources.replaceChildren();
    for (const [sourceKey, sourceInfo] of sourceEntries) {
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "audioReactSourceBtn";
      btn.dataset.reactSource = sourceKey;
      btn.textContent = String(sourceInfo?.label || sourceKey).toUpperCase();
      btn.title = String(sourceInfo?.description || sourceKey);
      const compatible = compatibleSet.has(sourceKey);
      btn.classList.toggle("active", selected.includes(sourceKey));
      btn.classList.toggle("incompatible", !compatible);
      btn.onclick = () => {
        if (ui.reactForceLockEnabled && !ui.reactForceMatchOverride && !compatible) return;
        const cfg = normalizeAudioReactivityMapUi(ui.audioReactivityMap || AUDIO_REACTIVITY_MAP_DEFAULT);
        let list = cfg.targets[target].sources.slice();
        if (ui.reactForceLockEnabled) {
          list = [sourceKey];
        } else {
          const idx = list.indexOf(sourceKey);
          if (idx >= 0) {
            list.splice(idx, 1);
          } else {
            list.push(sourceKey);
          }
        }
        cfg.targets[target].sources = normalizeAudioReactivitySourcesUi(list, ["smart"]);
        applyAudioReactivityMapToUi(cfg, { markDirty: true });
      };
      refs.sources.appendChild(btn);
    }
    const rowEnabled = parseLooseBoolean(rowCfg.enabled, true);
    const buttons = refs.sources.querySelectorAll(".audioReactSourceBtn");
    buttons.forEach(btn => {
      const sourceKey = String(btn.dataset.reactSource || "").trim().toLowerCase();
      const compatible = compatibleSet.has(sourceKey);
      const forceLockedOut = ui.reactForceLockEnabled && !ui.reactForceMatchOverride && !compatible;
      btn.disabled = !rowEnabled || forceLockedOut;
    });
  }
}

function applyAudioReactivityMapToUi(config = {}, options = {}) {
  const normalized = normalizeAudioReactivityMapUi(config);
  ui.audioReactivityMap = normalized;
  ui.audioReactivityMapDirty = options.markDirty === true;
  if (el.reactDropEnabled) {
    el.reactDropEnabled.checked = normalized.dropEnabled === true;
  }
  if (el.reactHardwareRateLimitsEnabled) {
    el.reactHardwareRateLimitsEnabled.checked = normalized.hardwareRateLimitsEnabled !== false;
  }
  for (const target of AUDIO_REACTIVITY_TARGET_KEYS) {
    const refs = getAudioReactivityTargetUiRefs(target);
    const row = normalized.targets[target] || AUDIO_REACTIVITY_MAP_DEFAULT.targets[target];
    if (refs.enabled) refs.enabled.checked = parseLooseBoolean(row.enabled, true);
    if (refs.amount) refs.amount.value = String(Math.round(clampNumber(row.amount, 0, 1.8, 1) * 100));
    if (refs.amount) refs.amount.disabled = refs.enabled ? !refs.enabled.checked : false;
  }
  syncAudioReactivityAmountLabels();
  renderAudioReactivitySourceButtons();
  refreshAudioReactivityMapStatus();
  updateAudioReactivityPolicyUi();
}

function collectAudioReactivityMapFromUi() {
  const base = normalizeAudioReactivityMapUi(ui.audioReactivityMap || AUDIO_REACTIVITY_MAP_DEFAULT);
  base.dropEnabled = Boolean(el.reactDropEnabled?.checked);
  base.hardwareRateLimitsEnabled = el.reactHardwareRateLimitsEnabled
    ? el.reactHardwareRateLimitsEnabled.checked !== false
    : true;
  for (const target of AUDIO_REACTIVITY_TARGET_KEYS) {
    const refs = getAudioReactivityTargetUiRefs(target);
    const enabled = refs.enabled ? refs.enabled.checked === true : true;
    const amount = refs.amount
      ? clampNumber(Number(refs.amount.value) / 100, 0, 1.8, 1)
      : 1;
    let sources = base.targets[target].sources;
    if (refs.sources) {
      const selected = Array.from(refs.sources.querySelectorAll(".audioReactSourceBtn.active"))
        .map(node => String(node.dataset.reactSource || "").trim().toLowerCase());
      sources = normalizeAudioReactivitySourcesUi(selected, sources);
    }
    base.targets[target] = {
      enabled,
      amount,
      sources
    };
  }
  return normalizeAudioReactivityMapUi(base);
}

async function loadAudioReactivityMap() {
  const r = await getJson("/audio/reactivity-map");
  if (!r || !r.ok || !r.config) return false;
  if (r.config.sourceCatalog && typeof r.config.sourceCatalog === "object") {
    audioReactivitySourceCatalogRuntime = { ...AUDIO_REACTIVITY_SOURCE_CATALOG_DEFAULT, ...r.config.sourceCatalog };
  }
  applyAudioReactivityMapToUi(r.config, { markDirty: false });
  maybeApplySmartLiveReactivityPolicy("SMART MATCH");
  ui.audioReactivityMapLoaded = true;
  return true;
}

async function saveAudioReactivityMap(options = {}) {
  const reset = options.reset === true;
  const payload = reset
    ? { reset: true }
    : collectAudioReactivityMapFromUi();
  const r = await postJson("/audio/reactivity-map", payload);
  if (!r.ok || !r.data?.config) return { ok: false, error: r.data?.error || "save failed" };
  if (r.data.config.sourceCatalog && typeof r.data.config.sourceCatalog === "object") {
    audioReactivitySourceCatalogRuntime = { ...AUDIO_REACTIVITY_SOURCE_CATALOG_DEFAULT, ...r.data.config.sourceCatalog };
  }
  applyAudioReactivityMapToUi(r.data.config, { markDirty: false });
  ui.audioReactivityMapLoaded = true;
  return { ok: true };
}

function bindAudioReactivityMapUi() {
  const rows = [
    { enabled: el.reactHueEnabled, amount: el.reactHueAmount },
    { enabled: el.reactWizEnabled, amount: el.reactWizAmount },
    { enabled: el.reactOtherEnabled, amount: el.reactOtherAmount }
  ];
  for (const row of rows) {
    if (row.enabled && row.amount) {
      row.enabled.onchange = () => {
        row.amount.disabled = !row.enabled.checked;
        renderAudioReactivitySourceButtons();
        markAudioReactivityMapDirty();
      };
    }
    if (row.amount) {
      row.amount.oninput = () => {
        syncAudioReactivityAmountLabels();
        markAudioReactivityMapDirty();
      };
      row.amount.onchange = () => {
        syncAudioReactivityAmountLabels();
        markAudioReactivityMapDirty();
      };
    }
  }

  if (el.reactDropEnabled) {
    el.reactDropEnabled.onchange = () => {
      markAudioReactivityMapDirty();
    };
  }

  if (el.reactHardwareRateLimitsEnabled) {
    el.reactHardwareRateLimitsEnabled.onchange = () => {
      markAudioReactivityMapDirty();
    };
  }

  if (el.reactSmartMatchEnabled) {
    el.reactSmartMatchEnabled.onchange = () => {
      ui.reactSmartMatchEnabled = el.reactSmartMatchEnabled.checked === true;
      localStorage.setItem(AUDIO_REACT_SMART_MATCH_KEY, ui.reactSmartMatchEnabled ? "1" : "0");
      maybeApplySmartLiveReactivityPolicy("SMART MATCH");
      refreshAudioReactivityMapStatus();
    };
  }

  if (el.reactForceLockEnabled) {
    el.reactForceLockEnabled.onchange = () => {
      ui.reactForceLockEnabled = el.reactForceLockEnabled.checked === true;
      localStorage.setItem(AUDIO_REACT_FORCE_LOCK_KEY, ui.reactForceLockEnabled ? "1" : "0");
      const changed = applyAudioReactivityPolicyConstraints({ autoMatch: ui.reactSmartMatchEnabled === true });
      if (ui.reactSmartMatchEnabled && changed) {
        queueSmartMatchPersist("FORCE LOCK");
      }
      renderAudioReactivitySourceButtons();
      refreshAudioReactivityMapStatus();
    };
  }

  if (el.reactForceMatchOverride) {
    el.reactForceMatchOverride.onchange = () => {
      ui.reactForceMatchOverride = el.reactForceMatchOverride.checked === true;
      localStorage.setItem(AUDIO_REACT_FORCE_OVERRIDE_KEY, ui.reactForceMatchOverride ? "1" : "0");
      const changed = applyAudioReactivityPolicyConstraints({ autoMatch: ui.reactSmartMatchEnabled === true });
      if (ui.reactSmartMatchEnabled && changed) {
        queueSmartMatchPersist("FORCE OVERRIDE");
      }
      renderAudioReactivitySourceButtons();
      refreshAudioReactivityMapStatus();
    };
  }

  updateAudioReactivityPolicyUi();
}

function updateAudioTelemetry(a) {
  if (!a) return;
  el.aLevel.textContent = toFixedSafe(a.level, 2, "0.00");
  el.aRaw.textContent = toFixedSafe(a.levelRaw ?? a.level, 2, "0.00");
  el.aPeak.textContent = toFixedSafe(a.peak, 2, "0.00");
  el.aTransient.textContent = toFixedSafe(a.transient, 2, "0.00");
  el.aZcr.textContent = toFixedSafe(a.zcr, 2, "0.00");
  el.aBandLow.textContent = toFixedSafe(a.bandLow, 2, "0.00");
  el.aBandMid.textContent = toFixedSafe(a.bandMid, 2, "0.00");
  el.aBandHigh.textContent = toFixedSafe(a.bandHigh, 2, "0.00");
  el.aFlux.textContent = toFixedSafe(a.spectralFlux, 2, "0.00");
  el.aDevice.textContent = a.device || "-";
  el.aRunning.textContent = a.running ? "YES" : "NO";
  el.aRestart.textContent = a.lastRestartReason || "-";
  el.aError.textContent = a.lastError || "-";
}

async function loadAudioConfig() {
  const r = await getJson("/audio/config");
  if (!r || !r.ok) return false;
  applyAudioConfigToInputs(r.config || {});
  updateAudioTelemetry(r.telemetry || null);
  ui.audioConfigLoaded = true;
  return true;
}

async function loadAudioDevices() {
  const r = await getJson("/audio/devices");
  if (!r || !r.ok || !Array.isArray(r.devices)) return false;

  el.aDevices.innerHTML = "";
  const autoOpt = document.createElement("option");
  autoOpt.value = "";
  autoOpt.textContent = "AUTO SELECT";
  el.aDevices.appendChild(autoOpt);

  r.devices.forEach(d => {
    const o = document.createElement("option");
    o.value = String(d.id);
    o.textContent = `${d.id} | ${d.name} | ${d.hostAPIName}`;
    el.aDevices.appendChild(o);
  });

  return true;
}

async function poll(options = {}) {
  const force = options.force === true;
  if (ui.pollPaused && !force) {
    pollTick += 1;
    if (el.netBadge && (pollTick % 16) === 0) {
      setBadge(el.netBadge, "warn", "POLL PAUSED");
    }
    return;
  }

  const [t, h, w, a] = await Promise.all([
    getJson("/rave/telemetry"),
    getJson("/hue/telemetry"),
    getJson("/wiz/telemetry"),
    getJson("/audio/telemetry")
  ]);

  const tick = pollTick++;
  const shouldPollFixtures = (tick % 8) === 0 || !ui.fixturesSnapshotLoaded;
  const shouldPollAutomation = (tick % 20) === 0 || !ui.automationConfigLoaded;
  const shouldPollMods = (ui.activeTab === "mods") &&
    ((tick % 10) === 0 || ui.modsLoadedAt === 0);
  const shouldPollColorPrefixes = (tick % 30) === 0 || !ui.colorPrefixConfigLoaded;
  const shouldPollMidi = (ui.activeTab === "midi") || (tick % 20) === 0 || !ui.midiConfigLoaded;
  const shouldPollReactMap = (tick % 40) === 0 || !ui.audioReactivityMapLoaded;
  const [f, automationSnapshot, modsSnapshot, colorPrefixSnapshot, midiSnapshot, reactMapSnapshot] = await Promise.all([
    shouldPollFixtures ? getJson("/fixtures") : Promise.resolve(null),
    shouldPollAutomation ? getJson("/automation/config") : Promise.resolve(null),
    shouldPollMods ? getJson("/mods") : Promise.resolve(null),
    shouldPollColorPrefixes ? getJson("/color/prefixes") : Promise.resolve(null),
    shouldPollMidi ? getJson("/midi/status") : Promise.resolve(null),
    shouldPollReactMap ? getJson("/audio/reactivity-map") : Promise.resolve(null)
  ]);

  if (!t || !h) {
    if (f) updateFixtures(f);
    if (automationSnapshot?.ok && automationSnapshot.config) {
      if (!ui.automationConfigLoaded) {
        applyAutomationConfigToInputs(automationSnapshot.config, automationSnapshot.meta || {});
        ui.automationConfigLoaded = true;
      } else {
        renderAutomationSummary(automationSnapshot.config, automationSnapshot.meta || {});
      }
    }
    if (modsSnapshot?.ok) {
      renderMods(modsSnapshot);
    }
    if (colorPrefixSnapshot?.ok) {
      applyColorPrefixSnapshot(colorPrefixSnapshot);
      ui.colorPrefixConfigLoaded = true;
    }
    if (midiSnapshot?.ok !== false && midiSnapshot) {
      applyMidiSnapshot(midiSnapshot);
    }
    if (reactMapSnapshot?.ok && reactMapSnapshot?.config) {
      if (reactMapSnapshot.config.sourceCatalog && typeof reactMapSnapshot.config.sourceCatalog === "object") {
        audioReactivitySourceCatalogRuntime = {
          ...AUDIO_REACTIVITY_SOURCE_CATALOG_DEFAULT,
          ...reactMapSnapshot.config.sourceCatalog
        };
      }
      if (!ui.audioReactivityMapDirty) {
        applyAudioReactivityMapToUi(reactMapSnapshot.config, { markDirty: false });
      }
      ui.audioReactivityMapLoaded = true;
    }

    ui.pollErrors += 1;
    setBadge(el.netBadge, "bad", "NET DOWN");
    if (ui.pollErrors > 2) {
      setBadge(el.health, "bad", "ENGINE UNREACHABLE");
    }
    const fallbackT = { energy: 0.05, rms: 0.03, drop: false, scene: "-", behavior: "-" };
    const fallbackA = { level: 0.03, transient: 0, spectralFlux: 0, bandLow: 0, bandMid: 0, bandHigh: 0 };
    ui.lastRaveTelemetry = fallbackT;
    ui.lastAudioTelemetry = a && typeof a === "object" ? a : fallbackA;
    updateMainScopeInput(fallbackT, fallbackA);
    updateScopeHud(fallbackT, fallbackA);
    pushScopeSample(null, null, null, null);
    drawTelemetryScope();
    return;
  }

  ui.pollErrors = 0;
  setBadge(el.netBadge, "ok", "NET OK");
  ui.lastRaveTelemetry = t && typeof t === "object" ? t : null;
  if (a && typeof a === "object") {
    ui.lastAudioTelemetry = a;
  }

  el.rms.textContent = toFixedSafe(t.rms, 2, "0.00");
  el.eng.textContent = toFixedSafe(t.energy, 2, "0.00");
  el.mode.textContent = t.mode || "-";
  el.autoProfile.textContent = t.autoProfile || ui.autoProfile;
  el.audioReact.textContent = t.audioReactivityPreset || ui.audioReactivityPreset;
  el.scene.textContent = t.scene || "-";
  el.behavior.textContent = t.behavior || "-";
  el.phrase.textContent = t.phrase || "-";
  el.dropStat.textContent = t.drop ? "YES" : "NO";
  el.genreStat.textContent = t.genre || ui.genre;
  if (Number.isFinite(Number(t.bpm)) && Number(t.bpm) > 0) {
    ui.lastBpm = Number(t.bpm);
  }
  if (!el.standCustomCluster.classList.contains("hidden") && normalizeStandaloneMode(el.standMode.value) === "auto") {
    syncStandaloneModeUi({ enabled: !el.standMode.disabled });
  }
  if (Number.isFinite(Number(t.flowIntensity))) {
    const nextFlowIntensity = clampFlowIntensity(Number(t.flowIntensity));
    if (Date.now() > Number(ui.flowIntensityInputUntil || 0)) {
      ui.flowIntensity = nextFlowIntensity;
      applyFlowIntensityUi();
    }
  }

  if (t.mode === "clamp" || t.mode === "interpret") ui.mode = t.mode;
  if (t.modeLock === "auto" || t.modeLock === "clamp" || t.modeLock === "interpret") {
    ui.modeLock = t.modeLock;
  }
  if (Number.isFinite(Number(t.overclockLevel))) {
    ui.overclockLevel = Number(t.overclockLevel);
    ui.overclock = ui.overclockLevel > 0;
  }
  if (t.autoProfile) ui.autoProfile = t.autoProfile;
  if (t.audioReactivityPreset) ui.audioReactivityPreset = t.audioReactivityPreset;
  if (t.genre) ui.genre = t.genre;
  if (typeof t.genreRefMode === "string" && t.genreRefMode) {
    ui.genreDecadeMode = String(t.genreRefMode).toLowerCase();
  }
  if (typeof t.genreRefDecade === "string" && t.genreRefDecade) {
    ui.genreDecadeResolved = String(t.genreRefDecade).toLowerCase();
  }
  if (typeof t.metaAutoEnabled === "boolean") ui.metaAutoEnabled = t.metaAutoEnabled;
  if (typeof t.metaAutoReason === "string" && t.metaAutoReason) ui.metaAutoReason = t.metaAutoReason;
  if (typeof t.metaAutoGenre === "string" && t.metaAutoGenre) ui.metaAutoGenre = t.metaAutoGenre;
  if (Number.isFinite(Number(t.metaAutoHz))) ui.metaAutoHz = Number(t.metaAutoHz);
  if (typeof t.wizSceneSync === "boolean") {
    ui.wizSceneSync = t.wizSceneSync;
  } else if (typeof t.sceneSync === "boolean") {
    ui.wizSceneSync = t.sceneSync;
  }

  el.hSent.textContent = String(h.sent ?? 0);
  el.hSkip.textContent = String(h.skipped ?? 0);
  el.hLat.textContent = String(h.lastDurationMs ?? 0);
  const desiredEnt = h.transportDesired === "entertainment";
  const activeEnt = h.transportActive === "entertainment" || h?.entertainment?.active === true;
  let hueStateText = "REST";
  if (activeEnt) {
    hueStateText = h.inflight ? "ENT ON BUSY" : "ENT ON";
  } else if (desiredEnt) {
    hueStateText = h.transportFallbackReason ? "ENT RETRY" : "ENT WAIT";
  } else if (h.transportFallbackReason) {
    hueStateText = "REST FB";
  }
  el.hState.textContent = hueStateText;

  el.wSent.textContent = String(w?.sent ?? 0);
  el.wSkip.textContent = String(w?.skipped ?? 0);
  el.wLat.textContent = String(w?.lastDurationMs ?? 0);
  el.wState.textContent = (w && (w.sendErrors || 0) > 0) ? "WARN" : "OK";

  if (h.transportDesired === "entertainment" && h.transportActive !== "entertainment") {
    setBadge(el.health, "warn", "HUE ENT FALLBACK");
  } else if (h.inflight) {
    setBadge(el.health, "warn", "ENGINE BUSY");
  } else {
    setBadge(el.health, "ok", "ENGINE OK");
  }

  if (a) {
    updateAudioTelemetry(a);
    if (a.config) {
      ui.limiterPreset = detectLimiterPreset(a.config);
    }
    if (!ui.audioConfigLoaded && a.config) {
      applyAudioConfigToInputs(a.config);
      ui.audioConfigLoaded = true;
    }
  }

  if (f) updateFixtures(f);
  if (automationSnapshot?.ok && automationSnapshot.config) {
    if (!ui.automationConfigLoaded) {
      applyAutomationConfigToInputs(automationSnapshot.config, automationSnapshot.meta || {});
      ui.automationConfigLoaded = true;
    } else {
      renderAutomationSummary(automationSnapshot.config, automationSnapshot.meta || {});
    }
  }
  if (modsSnapshot?.ok) {
    renderMods(modsSnapshot);
  }
  if (colorPrefixSnapshot?.ok) {
    applyColorPrefixSnapshot(colorPrefixSnapshot);
    ui.colorPrefixConfigLoaded = true;
  }
  if (midiSnapshot?.ok !== false && midiSnapshot) {
    applyMidiSnapshot(midiSnapshot);
  }
  if (reactMapSnapshot?.ok && reactMapSnapshot?.config) {
    if (reactMapSnapshot.config.sourceCatalog && typeof reactMapSnapshot.config.sourceCatalog === "object") {
      audioReactivitySourceCatalogRuntime = {
        ...AUDIO_REACTIVITY_SOURCE_CATALOG_DEFAULT,
        ...reactMapSnapshot.config.sourceCatalog
      };
    }
    if (!ui.audioReactivityMapDirty) {
      applyAudioReactivityMapToUi(reactMapSnapshot.config, { markDirty: false });
    }
    ui.audioReactivityMapLoaded = true;
  }
  maybeRetuneSmartMatchFromTelemetry();

  if (ui.engineModeTargets > 0) {
    if (ui.engineReadyTargets <= 0) {
      setBadge(el.health, "warn", "NO CONFIGURED ENGINE TARGETS");
    } else if (Number(ui.connectivitySummary?.unreachable || 0) > 0) {
      setBadge(el.health, "warn", "ENGINE TARGET UNREACHABLE");
    }
  }

  el.dropOverlay.style.display = t.drop ? "flex" : "none";
  updateMainScopeInput(t, a);
  updateScopeHud(t, a);
  pushScopeSample(t, h, w, a);
  if (monitorsActive()) drawTelemetryScope();

  sync();
}

let pollInFlight = false;
let pollTimer = null;
async function pollLoop() {
  if (pollInFlight) {
    pollTimer = setTimeout(pollLoop, pollIntervalMs);
    return;
  }

  pollInFlight = true;
  try {
    await poll();
  } finally {
    pollInFlight = false;
    pollTimer = setTimeout(pollLoop, pollIntervalMs);
  }
}

window.addEventListener("beforeunload", () => {
  if (pollTimer) clearTimeout(pollTimer);
  if (flowIntensityCommitTimer) clearTimeout(flowIntensityCommitTimer);
  if (guidedTourAutoStartTimer) clearTimeout(guidedTourAutoStartTimer);
  clearGuidedTourFocus();
  if (mainScopeAnim) cancelAnimationFrame(mainScopeAnim);
});
document.addEventListener("visibilitychange", updateMonitorRenderingState);

ui.startTabPreference = normalizeStartTabPreference(ui.startTabPreference);
ui.activeTab = normalizeStartTabPreference(ui.startTabPreference);
applySystemSettingsUi();
loadSystemServerConfig();
applyApiBaseUi();
applyFlowIntensityUi();
applyReactorSliderUi();
applyAudioReactivityMapToUi(AUDIO_REACTIVITY_MAP_DEFAULT, { markDirty: false });
initThemeSettings();
initObsDockMode();
initCollapsiblePanels();
applyUiTooltips();
el.modActionModId.value = "hello-mod";
el.modActionName.value = "status";
resetFixtureForm();
setCustomClusterVisible(false);
initCustomControlTabMount();
applyStandaloneEntryToControls(null);
syncStandaloneValueLabels();
showTab(ui.activeTab);
initOnboardingGate();
initHueEntGuideGate();
initGuidedOnboarding();
loadGenreCatalog().then(() => {
  applyUiTooltips();
  sync();
});
syncAudioQuickPresetButtons();
loadAudioConfig();
loadAudioReactivityMap();
loadAudioDevices();
loadMidiStatus();
refreshStandaloneFixtures();
refreshFixturesFromServer({ attempts: 3 });
loadMods();
loadColorPrefixConfig();
setLegacyAutomationUnlocked(ui.legacyAutomationUnlocked, { persist: false });
syncAutomationPercentLabels();
loadAutomationConfig();
updateMainScopeInput(
  { energy: 0.05, rms: 0.03, drop: false },
  { level: 0.03, transient: 0, spectralFlux: 0, bandLow: 0, bandMid: 0, bandHigh: 0 }
);
updateScopeHud(
  { energy: 0.05, rms: 0.03, drop: false, scene: "-", behavior: "-" },
  { level: 0.03, transient: 0, spectralFlux: 0, bandLow: 0, bandMid: 0, bandHigh: 0 }
);
updateMonitorRenderingState();
pollLoop();
sync();
</script>
</body>
</html>
