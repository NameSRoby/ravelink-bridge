<!DOCTYPE html>

<!-- [TITLE] Page: public/index.html -->
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>RaveLink Bridge | Hue + WiZ Music Sync Lighting Engine</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta
  name="description"
  content="RaveLink Bridge is a local music-sync lighting engine for Philips Hue and WiZ with Twitch reward hooks, real-time audio reactivity, and a browser control surface."
/>
<meta name="robots" content="index,follow,max-image-preview:large" />
<meta name="theme-color" content="#050507" />
<meta property="og:type" content="website" />
<meta property="og:title" content="RaveLink Bridge | Hue + WiZ Music Sync Lighting Engine" />
<meta
  property="og:description"
  content="Local reactive lighting bridge for Philips Hue and WiZ. Audio-driven effects, scheduler-safe output, and optional Twitch integrations."
/>
<meta property="og:site_name" content="RaveLink Bridge" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="RaveLink Bridge | Hue + WiZ Music Sync Lighting Engine" />
<meta
  name="twitter:description"
  content="Audio-reactive local lighting bridge for Hue + WiZ with optional Twitch reward hooks."
/>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "SoftwareApplication",
  "name": "RaveLink Bridge",
  "applicationCategory": "MultimediaApplication",
  "operatingSystem": "Windows",
  "softwareVersion": "1.3.0",
  "description": "Local music-sync lighting engine for Philips Hue and WiZ with real-time audio reactivity and optional Twitch command hooks."
}
</script>

<style>
:root{
  --bg:#050507;
  --panel:#0b0e18;
  --panel2:#121a2f;
  --accent:#8b001f;
  --accentGlow:#8b001faa;
  --edge:#233055;
  --btn-bg:#14182c;
  --warn:#ffb000;
  --ok:#19ff6a;
  --bad:#ff4444;
  --text:#eaeaea;
}

*{box-sizing:border-box}

body{
  margin:0;
  font-family:"Rajdhani","Trebuchet MS",sans-serif;
  background:
    radial-gradient(1200px 400px at 10% -10%, #1a243f55 0%, transparent 50%),
    radial-gradient(900px 300px at 100% 0%, #2e0b1655 0%, transparent 55%),
    var(--bg);
  color:var(--text);
}

header{
  padding:14px 18px;
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:12px;
}

h1{
  margin:0;
  letter-spacing:6px;
  color:var(--accent);
}

.sub{
  opacity:.85;
  font-size:12px;
  letter-spacing:1px;
}

.quickLinks{
  margin-top:8px;
  display:flex;
  flex-wrap:wrap;
  gap:8px;
}

.quickLinks a{
  color:#c9d8ff;
  text-decoration:none;
  font-size:11px;
  letter-spacing:.8px;
  border:1px solid #2a395f;
  border-radius:999px;
  padding:4px 9px;
  background:#0a1124;
}

.quickLinks a:hover{
  border-color:#45639f;
  color:#ffffff;
}

.headerRight{
  display:flex;
  gap:8px;
  align-items:center;
  position:relative;
}

.headerRight .badge{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
}

#health.badge{
  width:248px;
}

#netBadge.badge{
  width:92px;
}

.iconBtn{
  width:34px;
  min-width:34px;
  min-height:34px;
  padding:0;
  border:1px solid #315089;
  border-radius:999px;
  background:#0f1830;
  color:#b9ccf7;
  font-size:18px;
  line-height:1;
}

.iconBtn:hover{
  border-color:#4f78bf;
  color:#ffffff;
}

.themeWrap{
  position:relative;
}

.themePanel{
  position:absolute;
  top:42px;
  right:0;
  width:min(560px,calc(100vw - 24px));
  border:1px solid #2b406d;
  border-radius:12px;
  background:linear-gradient(180deg,#0d1730,#0a1225);
  padding:10px;
  z-index:1900;
  box-shadow:0 8px 24px #00000070;
}

.themePanel h4{
  margin:0 0 8px;
  font-size:11px;
  letter-spacing:1.4px;
  color:#c8d8ff;
}

.themePresetGrid{
  display:grid;
  grid-template-columns:repeat(2,minmax(0,1fr));
  gap:6px;
}

.themePresetBtn{
  border:1px solid #233055;
  background:#101a33;
  min-height:34px;
  font-size:11px;
  letter-spacing:.8px;
}

.themePresetBtn.active{
  border-color:#4f78bf;
  box-shadow:0 0 10px #315ca355;
}

.themeCustomRow{
  margin-top:8px;
  display:grid;
  grid-template-columns:repeat(2,minmax(0,1fr));
  gap:8px;
}

.themePanel label{
  display:block;
  margin-bottom:4px;
  font-size:10px;
  letter-spacing:.8px;
  color:#c8d8ff;
}

.themeColorPicker{
  width:100%;
  min-height:34px;
  border:1px solid #2b406d;
  border-radius:8px;
  background:#0c152c;
  padding:4px;
}

.themeStatusField{
  width:100%;
  margin-top:8px;
}

.themeDebugDump{
  margin-top:8px;
  width:100%;
  min-height:98px;
  resize:vertical;
  font-size:11px;
  line-height:1.3;
}

.devAckGate{
  position:fixed;
  inset:0;
  background:#02050dcc;
  z-index:6200;
  display:flex;
  align-items:center;
  justify-content:center;
  padding:16px;
}

.devAckCard{
  width:min(560px,96vw);
  border:1px solid #4b2b3a;
  border-radius:12px;
  background:linear-gradient(180deg,#180b13,#100914);
  box-shadow:0 16px 40px #0000008a;
  padding:14px;
}

.devAckTitle{
  margin:0 0 8px;
  font-size:14px;
  letter-spacing:1px;
}

.devAckInput{
  width:100%;
  margin-top:6px;
}

.devAckInput::placeholder{
  color:#f0c7d3;
  opacity:.34;
}

.devAckPhrase{
  margin-top:8px;
  width:100%;
  font-size:11px;
  letter-spacing:.6px;
}

body.obsDockMode .supportPanel{
  display:none !important;
}

body.obsDockMode .quickLinks{
  display:none;
}

body.obsDockMode .sub{
  font-size:11px;
  letter-spacing:.7px;
}

body.obsDockMode .tabs{
  margin:8px 8px 0;
}

body.obsDockMode .panel{
  margin:8px;
  padding:12px;
}

body.obsDockMode .onboardGate{
  display:none !important;
}

.supportPanel{
  margin:0 12px 8px;
  padding:8px 10px;
  border:1px solid #2a3f6b;
  background:linear-gradient(180deg,#0d1730,#091224);
}

.supportPanel .clusterHeaderRow h3{
  margin:0;
  font-size:11px;
  letter-spacing:1.6px;
  color:#b8cdf7;
  opacity:.92;
}

.supportPanel .clusterBody{
  margin-top:6px;
  display:flex;
  align-items:center;
  gap:8px;
  flex-wrap:wrap;
}

.supportMeta{
  font-size:11px;
  color:#c8d5ef;
  opacity:.86;
}

.supportLink{
  display:inline-flex;
  align-items:center;
  border:1px solid #33518c;
  border-radius:999px;
  padding:3px 9px;
  font-size:11px;
  color:#dbe8ff;
  text-decoration:none;
  background:#0b1530;
}

.supportLink:hover{
  border-color:#4c79c5;
  color:#fff;
}

.supportPanel.collapsed{
  margin:0 12px 4px auto;
  width:30px;
  min-height:0;
  padding:2px;
  border-color:transparent;
  background:transparent;
  box-shadow:none;
}

.supportPanel.collapsed .clusterHeaderRow{
  justify-content:flex-end;
  gap:0;
}

.supportPanel.collapsed .clusterHeaderRow h3{
  display:none;
}

.supportPanel.collapsed .collapseBtn{
  min-width:26px;
  width:26px;
  min-height:26px;
  padding:0;
  border-radius:999px;
  border:1px solid #2f4a7b88;
  background:#0f1630a8;
  opacity:.16;
  font-size:0;
  letter-spacing:0;
}

.supportPanel.collapsed .collapseBtn::before{
  content:"+";
  font-size:13px;
  line-height:1;
  color:#99b8f7;
}

.supportPanel.collapsed:hover .collapseBtn{
  opacity:.72;
}

.panel{
  margin:12px;
  padding:16px;
  background:linear-gradient(180deg,#0f1226,#070710);
  border-radius:18px;
  border:1px solid #1b2542;
}

h3{
  margin:18px 0 8px;
  font-size:13px;
  letter-spacing:2px;
  opacity:.85;
}

button{
  background:var(--btn-bg);
  border:none;
  border-radius:clamp(10px,1.1vw,14px);
  color:var(--text);
  padding:clamp(9px,1.2vw,12px) clamp(10px,1.5vw,14px);
  min-height:clamp(40px,5.2vh,48px);
  font-size:clamp(11px,1.05vw,14px);
  line-height:1.14;
  white-space:normal;
  cursor:pointer;
  font-weight:600;
  letter-spacing:.5px;
}

button.active{
  background:var(--accent);
  box-shadow:0 0 18px var(--accentGlow);
}

button.warn{
  background:#2a1d00;
  color:var(--warn);
}

button.bad{
  background:#2d0b0b;
  color:var(--bad);
}
button:disabled{
  opacity:.45;
  filter:saturate(.6);
  cursor:not-allowed;
}

.grid2{display:grid;grid-template-columns:1fr 1fr;gap:10px}
.grid3{display:grid;grid-template-columns:repeat(3,1fr);gap:10px}
.grid4{display:grid;grid-template-columns:repeat(4,1fr);gap:10px}
.grid5{display:grid;grid-template-columns:repeat(5,1fr);gap:10px}
.grid6{display:grid;grid-template-columns:repeat(6,1fr);gap:10px}
.liveProfileRow{
  display:grid;
  grid-template-columns:minmax(140px,1.2fr) minmax(140px,1fr) repeat(4,minmax(92px,auto));
  gap:8px;
  align-items:center;
  margin:8px 0 4px;
}
.liveProfileRow input{
  min-height:34px;
  border:1px solid #2a3f6b;
  border-radius:9px;
  background:#0b1226;
  color:var(--text);
  padding:0 10px;
  font-size:12px;
  letter-spacing:.4px;
}
.liveProfileRow select{
  min-height:34px;
  border:1px solid #2a3f6b;
  border-radius:9px;
  background:#0b1226;
  color:var(--text);
  padding:0 10px;
  font-size:12px;
  letter-spacing:.4px;
}
.liveProfileRow button{
  min-height:34px;
  padding:7px 10px;
  font-size:11px;
  letter-spacing:.6px;
}
.liveProfileStat{
  margin-top:2px;
}
.profileAppliedPulse{
  animation:profileAppliedPulseAnim 900ms ease-out 1;
}
@keyframes profileAppliedPulseAnim{
  0%{box-shadow:0 0 0 rgba(0,0,0,0)}
  30%{box-shadow:0 0 18px var(--accentGlow)}
  100%{box-shadow:0 0 0 rgba(0,0,0,0)}
}

.sceneLockRows{
  display:grid;
  gap:10px;
}

.sceneLockRows > .grid2,
.sceneLockRows > .grid3,
.sceneLockRows > .grid4{
  margin-top:0;
}

.sceneSyncGrid{
  margin-top:2px;
}

.grid2 + .grid2,
.grid3 + .grid3,
.grid4 + .grid4,
.grid5 + .grid5,
.grid6 + .grid6{
  margin-top:8px;
}

.advancedSubTitle{
  margin:8px 0 6px;
  font-size:10px;
  letter-spacing:1.2px;
  color:#9cb0de;
}

.metaAutoPrimaryRow{
  display:grid;
  grid-template-columns:repeat(2,minmax(0,1fr));
  gap:8px;
}

.metaAutoModeRow{
  display:grid;
  grid-template-columns:repeat(2,minmax(0,1fr));
  gap:8px;
  margin-top:8px;
}

.metaAutoFactorGrid{
  margin-top:6px;
  display:grid;
  grid-template-columns:repeat(2,minmax(0,1fr));
  gap:8px;
}

.metaAutoBiasRow{
  margin-top:10px;
  display:grid;
  grid-template-columns:repeat(2,minmax(0,1fr));
  gap:8px;
}

.metaAutoBiasRow > button{
  width:100%;
}

.metaAutoBiasStat{
  margin-top:6px;
}

@media (max-width:680px){
  .metaAutoPrimaryRow,
  .metaAutoModeRow,
  .metaAutoFactorGrid,
  .metaAutoBiasRow{
    grid-template-columns:minmax(0,1fr);
  }
}

.tabs{
  margin:12px 12px 0;
  display:flex;
  flex-wrap:wrap;
  gap:8px;
}

.tabBtn{
  flex:1 1 140px;
  padding:10px 12px;
  border:1px solid var(--edge);
  background:linear-gradient(180deg,var(--panel2),var(--btn-bg));
  color:var(--text);
}

.tabBtn:hover{
  border-color:var(--accent);
  box-shadow:inset 0 0 0 1px var(--accentGlow);
}

.tabBtn.active{
  background:linear-gradient(180deg,var(--accent),var(--panel2));
  border-color:var(--accent);
  color:#ffffff;
  box-shadow:0 0 14px var(--accentGlow);
}

.modUiDynamicTab{
  flex:1 1 170px;
  border-style:dashed;
}

.tabPage{
  display:none;
}

.tabPage.active{
  display:block;
}

.cluster{
  margin-top:14px;
  padding:12px;
  border-radius:14px;
  border:1px solid #1c2746;
  background:linear-gradient(180deg,#0f1527,#0b0e18);
}

.clusterHeaderRow{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
}

.clusterHeaderRow h3{
  margin:0;
}

.clusterHeaderActions{
  display:flex;
  align-items:center;
  gap:8px;
}

.clusterBody{
  margin-top:10px;
}

.cluster.collapsed .clusterBody{
  display:none;
}

.subcluster.collapsed .clusterBody{
  display:none;
}

.collapseBtn{
  min-width:94px;
  padding:8px 10px;
  border-radius:10px;
  border:1px solid #2d426f;
  background:linear-gradient(180deg,#17274a,#0f1a33);
  font-size:11px;
  letter-spacing:1.1px;
}

.collapseBtn:hover{
  border-color:#4f78bf;
}

.modReadmeBtn{
  min-width:138px;
  border:1px solid #2d426f;
  background:linear-gradient(180deg,#1d1f34,#141b2d);
  font-size:11px;
  letter-spacing:1px;
}

.modReadmeBtn:hover{
  border-color:#b34f70;
}

body.onboardLock::before{
  content:"";
  position:fixed;
  inset:0;
  z-index:1200;
  background:rgba(3,6,14,0.74);
  backdrop-filter:blur(2px);
}

body.onboardLock .liveMainCluster{
  position:relative;
  z-index:1250;
  border-color:#3b5c9e;
  box-shadow:0 0 0 1px #4f78bf inset, 0 0 32px #18305f99;
}

.onboardGate{
  position:fixed;
  left:50%;
  transform:translateX(-50%);
  bottom:16px;
  width:min(760px, calc(100vw - 24px));
  z-index:1300;
}

.onboardGateCard{
  border:1px solid #2f4a7c;
  border-radius:14px;
  padding:12px;
  background:linear-gradient(180deg,#111d39,#0a1224);
  box-shadow:0 0 28px #203f7a80;
}

.onboardGateTitle{
  font-size:12px;
  letter-spacing:1.3px;
  color:#d7e5ff;
}

.onboardGateText{
  margin-top:6px;
  font-size:12px;
  color:#c9d5f0;
  line-height:1.4;
}

.onboardGateActions{
  margin-top:10px;
  display:grid;
  grid-template-columns:1fr auto;
  gap:8px;
  align-items:center;
}

.onboardGateActions .hint{
  margin:0;
}

.onboardAckBtn{
  border:1px solid #7c2742;
  background:linear-gradient(180deg,#8b001f,#5c0015);
}

body.hueEntGuideLock::before{
  content:"";
  position:fixed;
  inset:0;
  z-index:1400;
  background:rgba(4,8,18,0.78);
  backdrop-filter:blur(2px);
}

body.hueEntGuideLock #fxHueBridgeBlock{
  position:relative;
  z-index:1450;
  border-color:#4f78bf;
  box-shadow:0 0 0 1px #4f78bf inset, 0 0 30px #315ca370;
}

.hueEntGuideGate{
  position:fixed;
  left:50%;
  top:50%;
  transform:translate(-50%,-50%);
  width:min(760px,calc(100vw - 24px));
  z-index:1500;
}

.hueEntGuideCard{
  border:1px solid #3a5692;
  border-radius:14px;
  padding:14px;
  background:linear-gradient(180deg,#0f1b36,#0a1224);
  box-shadow:0 0 34px #2348819a;
}

.hueEntGuideTitle{
  font-size:12px;
  letter-spacing:1.3px;
  color:#d7e5ff;
}

.hueEntGuideText{
  margin-top:8px;
  font-size:12px;
  color:#c9d5f0;
  line-height:1.45;
}

.hueEntGuideSteps{
  margin:10px 0 0;
  padding-left:18px;
  color:#d8e6ff;
  font-size:12px;
  line-height:1.4;
}

.hueEntGuideSteps li + li{
  margin-top:4px;
}

.hueEntGuideActions{
  margin-top:12px;
  display:flex;
  justify-content:flex-end;
}

.hueEntGuideAckBtn{
  min-width:180px;
  border:1px solid #7c2742;
  background:linear-gradient(180deg,#8b001f,#5c0015);
}

body.guidedTourLock::before{
  content:"";
  position:fixed;
  inset:0;
  z-index:1560;
  background:rgba(4,7,16,0.76);
  backdrop-filter:blur(2px);
}

.guidedTourFocus{
  position:relative;
  z-index:1600;
  border-radius:12px;
  box-shadow:0 0 0 1px #4f78bf inset, 0 0 28px #29519b8a;
}

.guidedTourGate{
  position:fixed;
  left:50%;
  bottom:16px;
  transform:translateX(-50%);
  width:min(860px,calc(100vw - 24px));
  z-index:1660;
}

.guidedTourCard{
  border:1px solid #35528d;
  border-radius:14px;
  padding:12px;
  background:linear-gradient(180deg,#0f1a34,#0a1224);
  box-shadow:0 0 34px #24467b8c;
}

.guidedTourHead{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
}

.guidedTourLabel{
  font-size:11px;
  letter-spacing:1.4px;
  color:#d7e5ff;
}

.guidedTourStep{
  font-size:11px;
  letter-spacing:1px;
  color:#b7caef;
}

.guidedTourTitle{
  margin-top:7px;
  font-size:14px;
  letter-spacing:1px;
  color:#e6f0ff;
}

.guidedTourText{
  margin-top:6px;
  font-size:12px;
  color:#cad7f1;
  line-height:1.45;
}

.guidedTourActions{
  margin-top:10px;
  display:grid;
  grid-template-columns:auto 1fr auto auto;
  gap:8px;
  align-items:center;
}

.guidedTourHint{
  margin:0;
  font-size:11px;
  color:#b5c7eb;
  opacity:.88;
}

.guidedTourPrevBtn,
.guidedTourNextBtn,
.guidedTourSkipBtn{
  min-width:104px;
}

.guidedTourSkipBtn{
  border:1px solid #6d7fa8;
  background:linear-gradient(180deg,#1d2a4b,#111a31);
}

.apiBaseRow{
  margin-top:10px;
  display:grid;
  grid-template-columns:minmax(0,1fr) auto auto;
  gap:8px;
  align-items:end;
}

.apiBaseInputWrap label{
  display:block;
  margin-bottom:4px;
  font-size:11px;
}

textarea{
  width:100%;
  min-height:96px;
  background:#101428;
  border:1px solid #1e2744;
  color:var(--text);
  border-radius:10px;
  padding:10px;
  font-family:ui-monospace,Consolas,monospace;
  font-size:12px;
  resize:vertical;
}

.statusPill{
  display:inline-block;
  padding:3px 8px;
  border-radius:999px;
  font-size:11px;
  font-weight:700;
  letter-spacing:.3px;
}

.statusPill.ok{
  background:#0b2f18;
  border:1px solid #1f8249;
  color:#89ffbb;
}

.statusPill.bad{
  background:#321016;
  border:1px solid #8f2433;
  color:#ff9da9;
}

.statusPill.warn{
  background:#332407;
  border:1px solid #a06d1b;
  color:#ffd68a;
}

.cluster:first-child{
  margin-top:0;
}

.subcluster{
  margin-top:12px;
  padding:10px;
  border-radius:12px;
  border:1px solid #1c2746;
  background:linear-gradient(180deg,#0d1323,#090d17);
}

.livePriorityPanel{
  border-color:#2a4f8e;
  background:linear-gradient(180deg,#101a34,#0a1223);
  box-shadow:inset 0 0 0 1px #213e70;
}

.liveMainCluster .subcluster{
  margin-top:14px;
}

.slider{margin:12px 0}
.slider label{
  display:flex;
  justify-content:space-between;
  font-size:12px;
  align-items:center;
  gap:10px;
}

.sliderInlineControls{
  display:inline-flex;
  align-items:center;
  gap:8px;
}

.sliderInlineResetBtn{
  min-height:26px;
  padding:4px 9px;
  border-radius:8px;
  font-size:10px;
  letter-spacing:.8px;
}

.sliderValue{
  min-width:40px;
  text-align:right;
  font-variant-numeric:tabular-nums;
}

.sliderResetRow{
  margin-top:8px;
  display:grid;
  grid-template-columns:repeat(3,minmax(0,1fr));
  gap:8px;
}

.reactorRiskNotice{
  margin-top:8px;
  border:1px solid #2a3f6b;
  border-radius:10px;
  background:#091126;
  padding:8px;
  font-size:11px;
  line-height:1.35;
  color:#c3cee7;
}

.reactorRiskNotice.warn{
  border-color:#7c5b20;
  background:#241b09;
  color:#ffd98a;
}

.reactorRiskNotice.bad{
  border-color:#8f2433;
  background:#341018;
  color:#ffb3be;
}

input[type="text"],
input[type="password"],
input[type="number"],
select{
  width:100%;
  background:#101428;
  border:1px solid #1e2744;
  color:var(--text);
  border-radius:10px;
  padding:10px;
}

input[type="range"]{
  width:100%;
  display:block;
}

.controlRow{
  margin-top:10px;
  display:grid;
  grid-template-columns:repeat(4,1fr);
  gap:8px;
}

.controlRow label{
  font-size:11px;
  opacity:.9;
  display:block;
  margin-bottom:4px;
}

.secretFieldRow{
  display:grid;
  grid-template-columns:minmax(0,1fr) auto;
  gap:8px;
  align-items:center;
}

.secretToggleBtn{
  min-width:70px;
  padding:8px 10px;
}

#scope{
  margin-top:18px;
  background:radial-gradient(circle at 50% 50%, #111 0%, #000 65%, #000 100%);
  border-radius:14px;
  padding:10px;
  position:relative;
  border:1px solid #2b1c22;
  overflow:hidden;
}

canvas{width:100%;height:160px}

#canvas{height:160px}

.scopeHud{
  position:absolute;
  left:12px;
  right:12px;
  top:12px;
  display:grid;
  grid-template-columns:repeat(4,minmax(0,1fr));
  gap:6px;
  z-index:2;
  pointer-events:none;
}

.scopeChip{
  background:rgba(7,13,28,0.58);
  border:1px solid rgba(43,66,114,0.55);
  border-radius:8px;
  padding:4px 6px;
  text-align:center;
  line-height:1.1;
}

.scopeChip strong{
  display:block;
  font-size:9px;
  letter-spacing:1px;
  color:#8fa6dd;
  opacity:0.9;
}

.scopeChip span{
  display:block;
  margin-top:2px;
  font-size:11px;
  font-family:ui-monospace,Consolas,monospace;
  color:#e8f0ff;
}

#telemetryScope{
  margin-top:10px;
  background:linear-gradient(180deg,#060b19,#05070f);
  border:1px solid #1e2a4a;
  border-radius:14px;
  padding:10px;
  position:relative;
}

#telemetryCanvas{
  width:100%;
  height:140px;
}

.scopeLegend{
  margin-top:8px;
  display:grid;
  grid-template-columns:repeat(6,1fr);
  gap:6px;
  font-size:10px;
  letter-spacing:.7px;
}

.legendChip{
  background:#070d1f;
  border:1px solid #1c2948;
  border-radius:8px;
  padding:6px 8px;
  text-align:center;
}

.liveStats{
  margin-top:12px;
  display:grid;
  grid-template-columns:repeat(3,minmax(0,1fr));
  gap:10px;
  align-items:start;
}

.statGroup{
  background:#060c1b;
  border:1px solid #1a2441;
  border-radius:12px;
  padding:8px;
}

.statGroupTitle{
  margin:0 0 8px;
  font-size:10px;
  letter-spacing:1.2px;
  color:#8fa6dd;
  opacity:.92;
}

.statGrid{
  display:grid;
  grid-template-columns:repeat(2,minmax(0,1fr));
  gap:6px;
}

.liveStat{
  background:#081022;
  border:1px solid #1a2441;
  border-radius:10px;
  padding:7px 6px;
  text-align:center;
  font-family:ui-monospace,Consolas,monospace;
  min-height:48px;
  display:flex;
  flex-direction:column;
  justify-content:center;
}

.liveStat strong{
  display:block;
  font-size:10px;
  color:#9fb0db;
  letter-spacing:1px;
}

.liveStat span{
  display:block;
  margin-top:3px;
  font-size:12px;
  color:#f3f7ff;
}

.paletteFamilyGrid button{
  font-size:12px;
}

.paletteBrandMenus{
  margin-top:8px;
  display:grid;
  grid-template-columns:repeat(auto-fit,minmax(320px,1fr));
  gap:10px;
}

.paletteBrandCard{
  border:1px solid #1b2746;
  border-radius:12px;
  background:#071022;
  padding:10px;
}

.paletteBrandCard h4{
  margin:0 0 8px;
  font-size:12px;
  letter-spacing:1.3px;
  color:#dfe7ff;
}

.paletteBrandSections{
  display:grid;
  gap:8px;
}

.paletteBrandSection{
  border:1px solid #182544;
  border-radius:10px;
  background:#050d1d;
  overflow:hidden;
}

.paletteBrandSection > summary{
  list-style:none;
  cursor:pointer;
  padding:7px 10px;
  font-size:11px;
  letter-spacing:1px;
  color:#c7d6ff;
  background:#081325;
  display:flex;
  align-items:center;
  justify-content:space-between;
}

.paletteBrandSection > summary::-webkit-details-marker{
  display:none;
}

.paletteBrandSection > summary::after{
  content:"+";
  color:#94a9da;
  font-weight:700;
  font-size:12px;
}

.paletteBrandSection[open] > summary{
  border-bottom:1px solid #182544;
}

.paletteBrandSection[open] > summary::after{
  content:"-";
}

.paletteBrandSectionBody{
  padding:8px;
}

.paletteBrandFixtureRow{
  display:grid;
  grid-template-columns:minmax(0,1fr) auto;
  gap:8px;
  align-items:end;
  margin-bottom:8px;
}

.paletteBrandFixtureRow select{
  width:100%;
}

.paletteBrandSubLabel{
  margin:0 0 4px;
  font-size:10px;
  letter-spacing:1px;
  color:#9eb0db;
}

.paletteScopeHint{
  margin:6px 0 0;
}

.paletteScopeHintWarn{
  color:#ffc485;
}

.paletteBrandMiniGrid{
  display:grid;
  grid-template-columns:repeat(3,minmax(0,1fr));
  gap:6px;
}

.paletteBrandFamilyGrid{
  margin-top:6px;
  display:grid;
  grid-template-columns:repeat(5,minmax(0,1fr));
  gap:6px;
}

.paletteBrandOrderGrid{
  margin-top:6px;
  display:grid;
  grid-template-columns:repeat(2,minmax(0,1fr));
  gap:6px;
}

.paletteBrandMetricGrid{
  margin-top:6px;
  display:grid;
  grid-template-columns:repeat(4,minmax(0,1fr));
  gap:6px;
}

.paletteBrandSlider{
  margin-top:8px;
}

.paletteBrandSlider label{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:8px;
  margin-bottom:4px;
}

.paletteBrandSlider input[type="range"]{
  width:100%;
}

.paletteBrandValue{
  color:#f4f7ff;
  font-size:11px;
  letter-spacing:.8px;
}

.paletteScopeRow{
  display:grid;
  grid-template-columns:repeat(2,minmax(0,1fr));
  gap:8px;
  margin:8px 0 10px;
}

.paletteGlobalPanel.isDisabled{
  opacity:.46;
  filter:saturate(.58);
  pointer-events:none;
}

.paletteCustomPanel.hidden{
  display:none;
}

.paletteCustomBrandTabs{
  display:grid;
  grid-template-columns:repeat(2,minmax(0,1fr));
  gap:8px;
  margin:8px 0 10px;
}

.paletteModeNotice{
  margin:6px 0 0;
  min-height:14px;
  color:#9fb0db;
}

.paletteCycleGrid{
  margin-top:6px;
  display:grid;
  grid-template-columns:repeat(auto-fit,minmax(120px,1fr));
  gap:6px;
}

.paletteControlWrap{
  margin-top:8px;
}

.paletteControlWrap.hidden{
  display:none;
}

.paletteSpectrumGrid{
  margin-top:6px;
  display:grid;
  grid-template-columns:repeat(5,minmax(0,1fr));
  gap:6px;
}

.paletteSpectrumGrid select{
  width:100%;
}

@media (max-width:980px){
  .paletteSpectrumGrid{
    grid-template-columns:repeat(2,minmax(0,1fr));
  }
}

#dropOverlay{
  position:absolute;
  inset:0;
  display:none;
  align-items:center;
  justify-content:center;
  font-size:32px;
  font-weight:900;
  letter-spacing:6px;
  color:white;
  pointer-events:none;
  z-index:3;
}

.badge{
  padding:6px 10px;
  border-radius:10px;
  font-size:11px;
  font-weight:700;
  text-align:center;
}

.ok{background:#072;color:var(--ok)}
.warn{background:#221;color:var(--warn)}
.bad{background:#200;color:var(--bad)}

.telemetry{
  margin-top:10px;
  display:grid;
  grid-template-columns:repeat(4,1fr);
  gap:6px;
  font-family:monospace;
  font-size:11px;
}

.telemetry div{
  background:#060812;
  padding:6px;
  border-radius:8px;
  text-align:center;
}

.fixtureToolbar{
  display:grid;
  grid-template-columns:repeat(5,minmax(0,1fr));
  gap:8px;
}

.routeModesWrap{
  grid-column:span 2;
}

.routeChipGroup{
  display:grid;
  grid-template-columns:repeat(3,minmax(0,1fr));
  gap:8px;
}

.routeChipToggle{
  border:1px solid #233055;
  background:linear-gradient(180deg,#141c34,#0f1528);
  border-radius:10px;
  padding:10px 12px;
  font-size:12px;
  letter-spacing:1px;
}

.routeChipToggle.active{
  background:linear-gradient(180deg,#1f3b6f,#13274a);
  border-color:#4f78bf;
  box-shadow:0 0 12px #315ca366;
}

.routeGuide{
  margin-top:10px;
  border:1px solid #22345a;
  border-radius:12px;
  background:linear-gradient(180deg,#0d1730,#0a1225);
  padding:10px;
}

.routeGuideGrid{
  display:grid;
  grid-template-columns:repeat(3,minmax(0,1fr));
  gap:8px;
}

.routeGuideCard{
  background:#091125;
  border:1px solid #20355f;
  border-radius:10px;
  padding:8px;
}

.routeGuideCard strong{
  display:block;
  font-size:11px;
  letter-spacing:.8px;
  color:#c8d8ff;
}

.routeGuideCard span{
  display:block;
  margin-top:5px;
  font-size:11px;
  line-height:1.35;
  color:#c3cee7;
}

.twitchPrefixPanel{
  margin-top:10px;
  border:1px solid #22345a;
  border-radius:12px;
  background:linear-gradient(180deg,#0d1730,#0a1225);
  padding:10px;
}

.twitchPrefixGrid{
  margin-top:8px;
  display:flex;
  flex-direction:column;
  gap:10px;
}

.prefixQuickGrid{
  display:grid;
  grid-template-columns:repeat(3,minmax(0,1fr));
  gap:8px;
  align-items:end;
}

.prefixActions{
  display:grid;
  grid-template-columns:repeat(2,minmax(0,1fr));
  gap:8px;
}

.prefixSection{
  border:1px solid #20355f;
  border-radius:10px;
  background:#091125;
  overflow:hidden;
}

.prefixSection > summary{
  list-style:none;
  cursor:pointer;
  padding:8px 10px;
  font-size:11px;
  letter-spacing:1px;
  color:#d7e2ff;
  text-transform:uppercase;
  display:flex;
  align-items:center;
  justify-content:space-between;
}

.prefixSection > summary::-webkit-details-marker{
  display:none;
}

.prefixSection > summary::after{
  content:"+";
  color:#9cb3e5;
  font-weight:700;
}

.prefixSection[open] > summary{
  border-bottom:1px solid #20355f;
}

.prefixSection[open] > summary::after{
  content:"-";
}

.prefixSectionBody{
  padding:10px;
  display:grid;
  gap:10px;
}

.prefixAdvancedGrid{
  display:grid;
  grid-template-columns:repeat(2,minmax(0,1fr));
  gap:8px;
  align-items:end;
}

.prefixFullRow{
  grid-column:1 / -1;
}

.prefixSyntax{
  margin:0;
  font-size:11px;
  color:#afbedf;
}

.prefixSyntax code{
  color:#d5e3ff;
}

.prefixDisabled{
  opacity:.45;
  filter:grayscale(.35);
}

@media (max-width:1180px){
  .prefixQuickGrid{
    grid-template-columns:repeat(2,minmax(0,1fr));
  }
}

@media (max-width:980px){
  .prefixQuickGrid,
  .prefixAdvancedGrid,
  .prefixActions{
    grid-template-columns:1fr;
  }
}

.fixtureModBrandStatus{
  margin-top:6px;
  font-size:11px;
}

.audioGuide{
  margin-top:8px;
  border:1px solid #22345a;
  border-radius:12px;
  background:linear-gradient(180deg,#0d1730,#0a1225);
  padding:10px;
}

.audioGuideGrid{
  display:grid;
  grid-template-columns:repeat(3,minmax(0,1fr));
  gap:8px;
}

.audioQuickPresetGrid{
  margin-top:8px;
}

.audioQuickPresetGrid button{
  min-height:34px;
  font-size:11px;
}

.audioQuickPresetHint{
  margin-top:6px;
}

.audioQuickSecondaryRow{
  margin-top:10px;
  display:grid;
  grid-template-columns:repeat(2,minmax(0,1fr));
  gap:8px;
}

.audioQuickActionRow{
  margin-top:10px;
}

.audioRouteModeRow{
  margin-top:8px;
  display:grid;
  grid-template-columns:repeat(2,minmax(0,1fr));
  gap:8px;
}

.audioRouteModeRow label{
  margin:0;
  display:flex;
  align-items:center;
  gap:7px;
  font-size:11px;
}

.audioAppsFilterHint{
  margin-top:6px;
}

.audioIsoAdvanced{
  display:grid;
  gap:6px;
}

.audioIsoAdvanced label{
  margin-bottom:0;
}

.audioOptionalToolsBanner{
  margin-top:10px;
  border:1px solid #264377;
  border-radius:10px;
  background:linear-gradient(180deg,#0f1a34,#091226);
  padding:10px;
}

.audioOptionalToolsBanner.warn{
  border-color:#7a5f27;
  background:linear-gradient(180deg,#2a200c,#171105);
}

.audioOptionalToolsBanner.ok{
  border-color:#2b6a44;
  background:linear-gradient(180deg,#11281d,#0b1a12);
}

.audioOptionalToolsHead{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:8px;
}

.audioOptionalToolsBody{
  margin-top:6px;
}

.audioOptionalToolsActions{
  margin-top:8px;
  display:grid;
  grid-template-columns:repeat(2,minmax(0,1fr));
  gap:8px;
}

.audioOptionalToolsActions button{
  min-height:34px;
}

.audioQuickActionRow button{
  min-height:42px;
}

.audioQuickTuneGrid{
  margin-top:10px;
  display:grid;
  grid-template-columns:repeat(2,minmax(0,1fr));
  gap:8px;
}

.audioQuickTuneCard{
  border:1px solid #22345a;
  border-radius:10px;
  background:linear-gradient(180deg,#0d1730,#0a1225);
  padding:8px;
}

.audioQuickTuneCard .slider{
  margin:0;
}

.audioQuickTuneMeta{
  margin-top:8px;
  display:grid;
  grid-template-columns:repeat(3,minmax(0,1fr));
  gap:8px;
  align-items:center;
}

.audioQuickTuneMeta label{
  display:flex;
  align-items:center;
  gap:6px;
  margin:0;
}

.audioQuickTuneMeta button{
  min-height:34px;
}

.audioQuickTuneStage{
  margin-top:6px;
  font-size:10px;
  letter-spacing:.6px;
  opacity:.85;
}

.audioQuickTuneAffects{
  margin-top:4px;
  font-size:10px;
  opacity:.75;
}

.audioQuickTuneApplyRow{
  margin-top:10px;
}

.audioAppSearchStatus{
  width:100%;
  min-height:42px;
}

.audioReactMap{
  margin-top:10px;
  padding:10px;
  border:1px solid #27457a;
  border-radius:12px;
  background:linear-gradient(180deg,#0f1a34,#0a1429);
}

.audioReactMapHeader{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:8px;
}

.audioReactMapDropToggle{
  display:flex;
  align-items:center;
  gap:6px;
  font-size:11px;
  letter-spacing:.8px;
}

.audioReactPolicyBar{
  margin-top:8px;
  display:grid;
  grid-template-columns:repeat(3,minmax(0,1fr));
  gap:8px;
}

.audioReactPolicyBar label{
  display:flex;
  align-items:center;
  gap:6px;
  font-size:11px;
  letter-spacing:.7px;
}

.audioReactCompatSummary{
  grid-column:1 / span 3;
  border:1px solid #2c456f;
  border-radius:8px;
  background:#0b1730;
  padding:6px 8px;
  font-size:10px;
  letter-spacing:.55px;
  color:#c4d4ef;
}

.audioReactMapRows{
  margin-top:8px;
  display:grid;
  gap:8px;
}

.audioReactMapRow{
  border:1px solid #25406e;
  border-radius:10px;
  padding:8px;
  background:rgba(7,15,33,0.75);
}

.audioReactMapTop{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:8px;
}

.audioReactMapTop label{
  margin:0;
}

.audioReactAmountWrap{
  display:flex;
  align-items:center;
  gap:8px;
  min-width:170px;
}

.audioReactAmountWrap input[type="range"]{
  width:110px;
  margin:0;
}

.audioReactSources{
  margin-top:7px;
  display:flex;
  flex-wrap:wrap;
  gap:6px;
}

.audioReactSourceBtn{
  min-height:30px;
  padding:4px 8px;
  border:1px solid #2b4f84;
  border-radius:999px;
  background:#0d1a36;
  color:#c4d6ff;
  font-size:11px;
  letter-spacing:.7px;
}

.audioReactSourceBtn.active{
  border-color:#4dd7ff;
  background:#153d5d;
  color:#f5fbff;
}

.audioReactSourceBtn.incompatible{
  border-color:#5c3650;
  color:#c5a8ba;
}

.audioReactSourceBtn:disabled{
  opacity:.46;
  cursor:not-allowed;
}

.audioReactMapActions{
  margin-top:10px;
  display:grid;
  grid-template-columns:repeat(2,minmax(0,1fr));
  gap:8px;
}

.audioReactMapActions input{
  grid-column:1 / span 2;
  font-size:11px;
}

.audioGuideCard{
  background:#091125;
  border:1px solid #20355f;
  border-radius:10px;
  padding:8px;
}

.audioGuideCard strong{
  display:block;
  font-size:11px;
  letter-spacing:.8px;
  color:#c8d8ff;
}

.audioGuideCard span{
  display:block;
  margin-top:5px;
  font-size:11px;
  line-height:1.35;
  color:#c3cee7;
}

.pairActionRow{
  border:1px solid #2a3d66;
  border-radius:12px;
  background:linear-gradient(180deg,#101b34,#0b1326);
  padding:8px;
}

.pairActionRow .grid2{
  margin:0;
}

.pairDiscoverBtn{
  border:1px solid #4b5f8f;
  background:linear-gradient(180deg,#1a2b4f,#121f3b);
}

.pairLinkBtn{
  border:1px solid #8f2f4d;
  background:linear-gradient(180deg,#8b001f,#5d0016);
}

.pairBridgeSaveRow{
  margin-top:8px;
}

.pairBridgeSaveBtn{
  width:100%;
  border:1px solid #365987;
  background:linear-gradient(180deg,#173258,#112543);
}

.fixtureGrid{
  margin-top:10px;
  display:grid;
  grid-template-columns:repeat(4,1fr);
  gap:8px;
}

.hidden{
  display:none !important;
}

.modUiToolbar{
  display:grid;
  grid-template-columns:2fr 1fr 1fr;
  gap:8px;
  align-items:end;
}

.modUiFrameWrap{
  margin-top:10px;
  border:1px solid #1f2c4f;
  border-radius:10px;
  overflow:hidden;
  background:#060a14;
}

#modUiFrame{
  width:100%;
  min-height:68vh;
  border:0;
  background:#ffffff;
}

.modUiEmpty{
  margin-top:10px;
  border:1px dashed #2a395f;
  border-radius:10px;
  padding:14px;
  color:#b9c7e6;
  font-size:12px;
}

.modDropZone{
  margin-top:10px;
  border:1px dashed #2f4b84;
  border-radius:10px;
  padding:12px;
  background:rgba(9,15,30,0.55);
  transition:border-color .14s ease, background .14s ease;
}

.modDropZone.dragOver{
  border-color:#6da3ff;
  background:rgba(18,31,59,0.78);
}

.tableWrap{
  margin-top:10px;
  border:1px solid #1f2c4f;
  border-radius:10px;
  overflow:auto;
}

table{
  width:100%;
  border-collapse:collapse;
  font-size:12px;
}

th, td{
  text-align:left;
  padding:8px;
  border-bottom:1px solid #1a2441;
  white-space:nowrap;
}

th{
  color:#b5c1e6;
  font-weight:700;
}

tr:last-child td{
  border-bottom:none;
}

.mono{
  font-family:ui-monospace,Consolas,monospace;
}

.hint{
  font-size:11px;
  opacity:.8;
}

.infoTip{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  width:15px;
  height:15px;
  margin-left:6px;
  border-radius:999px;
  border:1px solid #315089;
  background:#0f1830;
  color:#9fc2ff;
  font-size:10px;
  line-height:1;
  cursor:help;
}

@media (max-width:1100px){
  .liveStats{grid-template-columns:1fr 1fr}
}

@media (max-width:980px), (max-height:760px){
  .panel{margin:8px;padding:12px}
  .tabs{
    position:sticky;
    top:0;
    z-index:1100;
    background:linear-gradient(180deg,rgba(7,10,18,.95),rgba(7,10,18,.75));
    backdrop-filter:blur(3px);
    padding-top:6px;
    padding-bottom:4px;
  }
  .tabBtn{
    min-height:40px;
    padding:8px 10px;
    font-size:12px;
  }
  .liveMainCluster .grid3,
  .liveMainCluster .grid4,
  .liveMainCluster .grid5,
  .liveMainCluster .grid6{
    grid-template-columns:repeat(2,minmax(0,1fr));
  }
}

@media (max-width:700px){
  #health.badge{width:180px}
  #netBadge.badge{width:80px}
  .grid4{grid-template-columns:1fr 1fr}
  .grid5{grid-template-columns:1fr 1fr}
  .grid6{grid-template-columns:1fr 1fr}
  .liveProfileRow{grid-template-columns:1fr 1fr}
  .liveProfileRow input,
  .liveProfileRow select{grid-column:1 / -1}
  .telemetry{grid-template-columns:1fr 1fr}
  .controlRow{grid-template-columns:1fr 1fr}
  .fixtureGrid{grid-template-columns:1fr 1fr}
  .fixtureToolbar{grid-template-columns:1fr}
  .twitchPrefixGrid{grid-template-columns:1fr}
  .routeModesWrap{grid-column:span 1}
  .routeChipGroup{grid-template-columns:1fr}
  .scopeLegend{grid-template-columns:1fr 1fr 1fr}
  .liveStats{grid-template-columns:1fr}
  .scopeHud{grid-template-columns:1fr 1fr}
  .apiBaseRow{grid-template-columns:1fr}
  .routeGuideGrid{grid-template-columns:1fr}
  .audioGuideGrid{grid-template-columns:1fr}
  .audioRouteModeRow{grid-template-columns:1fr}
  .audioOptionalToolsActions{grid-template-columns:1fr}
  .audioQuickSecondaryRow{grid-template-columns:1fr}
  .audioQuickTuneGrid{grid-template-columns:1fr}
  .audioQuickTuneMeta{grid-template-columns:1fr}
  .audioReactMapHeader{flex-direction:column;align-items:flex-start}
  .audioReactAmountWrap{min-width:0}
  .audioReactMapActions{grid-template-columns:1fr}
  .audioReactMapActions input{grid-column:1}
  .modUiToolbar{grid-template-columns:1fr}
  .onboardGateActions{grid-template-columns:1fr}
  .guidedTourActions{grid-template-columns:1fr}
  .guidedTourHint{order:4}
  .sliderResetRow{grid-template-columns:1fr}
}

@media (max-width:620px), (max-height:620px){
  .controlRow{grid-template-columns:1fr}
  .telemetry{grid-template-columns:1fr}
  .liveMainCluster .grid3,
  .liveMainCluster .grid4,
  .liveMainCluster .grid5,
  .liveMainCluster .grid6{
    grid-template-columns:1fr;
  }
  .scopeLegend{grid-template-columns:1fr 1fr}
}
</style>
</head>

<body>
<header>
  <div>
    <h1>RAVELINK</h1>
    <div class="sub">reactive lighting bridge // ready for creators, streamers, and live setups</div>
    <div class="quickLinks">
      <a href="#deviceRouting" id="jumpRoutingLink">Device Routing</a>
      <a href="#modCenter" id="jumpModsLink">Mod Center</a>
    </div>
  </div>
  <div class="headerRight">
    <div class="themeWrap">
      <button id="themeCogBtn" type="button" class="iconBtn" title="Theme settings" aria-label="Theme settings">&#9881;</button>
      <div id="themePanel" class="themePanel hidden">
        <h4>THEME PRESETS</h4>
        <div class="themePresetGrid">
          <button type="button" class="themePresetBtn" data-theme-preset="midnight">MIDNIGHT</button>
          <button type="button" class="themePresetBtn" data-theme-preset="ember">EMBER</button>
          <button type="button" class="themePresetBtn" data-theme-preset="ocean">OCEAN</button>
          <button type="button" class="themePresetBtn" data-theme-preset="matrix">MATRIX</button>
        </div>
        <h4 style="margin-top:10px;">CUSTOM COLORS</h4>
        <div class="themeCustomRow">
          <div>
            <label for="themeLogoColor">LOGO / ACTIVE</label>
            <input id="themeLogoColor" class="themeColorPicker" type="color" value="#8b001f" />
          </div>
          <div>
            <label for="themeButtonColor">BUTTON BASE</label>
            <input id="themeButtonColor" class="themeColorPicker" type="color" value="#14182c" />
          </div>
        </div>
        <div class="themeCustomRow">
          <button id="themeResetBtn" type="button" class="themePresetBtn">RESET THEME</button>
          <button id="themeCloseBtn" type="button" class="themePresetBtn">CLOSE</button>
        </div>
        <h4 style="margin-top:10px;">ONBOARDING</h4>
        <div class="themeCustomRow">
          <button id="onboardStartBtn" type="button" class="themePresetBtn">START ONBOARDING</button>
          <button id="onboardResetBtn" type="button" class="themePresetBtn">RESET ONBOARDING</button>
        </div>
        <h4 style="margin-top:10px;">DEV / DEBUG</h4>
        <div class="themeCustomRow">
          <button id="devDebugToggleBtn" type="button" class="themePresetBtn bad">DEV DEBUG OFF</button>
        </div>
        <p id="devDebugStatus" class="hint" style="margin:8px 2px 0;">
          Unlocks destructive 20-60Hz overclock controls. Use only for controlled testing.
        </p>
        <div id="devToolsPanel" class="hidden">
          <h4 style="margin-top:10px;">DEV TOOLS</h4>
          <div class="themeCustomRow">
            <button id="devToolRuntimeBtn" type="button" class="themePresetBtn">RUNTIME</button>
            <button id="devToolConnectivityBtn" type="button" class="themePresetBtn">CONNECTIVITY</button>
          </div>
          <div class="themeCustomRow">
            <button id="devToolHooksBtn" type="button" class="themePresetBtn">MOD HOOKS</button>
            <button id="devToolTiersBtn" type="button" class="themePresetBtn">OC TIERS</button>
          </div>
          <input id="devToolsStatus" class="themeStatusField" type="text" value="DEV tools idle." readonly>
          <textarea id="devToolsDump" class="themeDebugDump" readonly>Run a DEV tool to inspect live JSON snapshots.</textarea>
        </div>
        <h4 style="margin-top:10px;">MIDI TAB</h4>
        <div class="themeCustomRow">
          <button id="midiTabToggleBtn" type="button" class="themePresetBtn">MIDI TAB OFF (NO DEVICE)</button>
        </div>
        <input id="midiCogStatus" class="themeStatusField" type="text" value="MIDI not detected yet." readonly>
        <p class="hint" style="margin:8px 2px 0;">
          If you skip onboarding, you can relaunch it here anytime.
        </p>
      </div>
    </div>
    <button id="obsDockCompactBtn" type="button" class="iconBtn hidden" title="Toggle compact OBS dock layout">DK</button>
    <div id="health" class="badge ok">ENGINE OK</div>
    <div id="netBadge" class="badge ok">NET OK</div>
  </div>
</header>

<div id="devOcAckGate" class="devAckGate hidden" aria-hidden="true">
  <div class="devAckCard">
    <h3 class="devAckTitle">UNSAFE DEV OVERCLOCK CHECK</h3>
    <p class="hint" style="margin:0 0 4px;">
      Last gate before arming destructive 20-60Hz overclock. This is intentionally absurd.
    </p>
    <label for="devOcAckInput">TYPE THE EXACT PHRASE TO ARM</label>
    <input
      id="devOcAckInput"
      class="devAckInput"
      type="text"
      autocomplete="off"
      spellcheck="false"
      placeholder="pressing enter closes menu lol"
    />
    <input id="devOcAckPhrase" class="devAckPhrase" type="text" readonly value="" />
    <div class="themeCustomRow">
      <button id="devOcAckCancelBtn" type="button" class="themePresetBtn">CANCEL</button>
      <button id="devOcAckConfirmBtn" type="button" class="themePresetBtn bad">ARM DEV HZ</button>
    </div>
  </div>
</div>

<div
  class="subcluster collapsible supportPanel"
  id="supportPanel"
  data-collapsible-key="supportPanel"
  data-collapsed-default-mobile="1"
>
  <div class="clusterHeaderRow">
    <h3>OPTIONAL SUPPORT</h3>
    <button
      type="button"
      class="collapseBtn"
      data-collapse-btn
      aria-expanded="true"
      title="Show or hide optional support link."
    >
      COLLAPSE
    </button>
  </div>
  <div class="clusterBody">
    <span class="supportMeta">If this engine helps, optional support:</span>
    <a class="supportLink" href="https://ko-fi.com/namesroby" target="_blank" rel="noopener noreferrer">
      ko-fi.com/namesroby
    </a>
  </div>
</div>

<div id="onboardGate" class="onboardGate hidden" aria-live="polite">
  <div class="onboardGateCard">
    <div class="onboardGateTitle">FIRST-TIME SETUP CHECKLIST</div>
    <div class="onboardGateText">
      Run <b>ONBOARDING</b> first to verify fixture routing, audio/app isolation, and palette target menus.
      The rest of the UI is dimmed until you confirm to prevent first-run misconfiguration.
    </div>
    <div class="onboardGateActions">
      <p class="hint">You can replay onboarding any time from the settings cog.</p>
      <button id="onboardAckBtn" type="button" class="onboardAckBtn">I UNDERSTAND</button>
    </div>
  </div>
</div>

<div id="hueEntGuideGate" class="hueEntGuideGate hidden" aria-live="polite">
  <div class="hueEntGuideCard">
    <div class="hueEntGuideTitle">HUE ENTERTAINMENT IS REQUIRED FOR RELIABLE ENGINE SYNC</div>
    <div class="hueEntGuideText">
      Before discovery/pairing, make sure a Hue Entertainment area exists. Without it, Hue falls back to slower REST behavior and can fail to stream at engine rate.
    </div>
    <ol class="hueEntGuideSteps">
      <li>Open Hue app -> <b>Settings</b> -> <b>Entertainment areas</b>.</li>
      <li>Create an area and add the exact lights you want in RaveLink.</li>
      <li>Save it, then use that area name or id in <b>ENT AREA (NAME/ID)</b>.</li>
    </ol>
    <div class="hueEntGuideActions">
      <button id="hueEntGuideAckBtn" type="button" class="hueEntGuideAckBtn">I UNDERSTAND</button>
    </div>
  </div>
</div>

<div id="guidedTourGate" class="guidedTourGate hidden" aria-live="polite">
  <div class="guidedTourCard">
    <div class="guidedTourHead">
      <div class="guidedTourLabel">RAVELINK ONBOARDING</div>
      <div id="guidedTourStep" class="guidedTourStep">1 / 1</div>
    </div>
    <div id="guidedTourTitle" class="guidedTourTitle">Welcome</div>
    <div id="guidedTourText" class="guidedTourText">This guide explains the most important controls.</div>
    <div class="guidedTourActions">
      <button id="guidedTourSkipBtn" type="button" class="guidedTourSkipBtn">SKIP</button>
      <p class="guidedTourHint">You can reopen this guide anytime from the settings cog.</p>
      <button id="guidedTourPrevBtn" type="button" class="guidedTourPrevBtn">BACK</button>
      <button id="guidedTourNextBtn" type="button" class="guidedTourNextBtn">NEXT</button>
    </div>
  </div>
</div>

<div id="tabsBar" class="tabs">
  <button class="tabBtn active" type="button" data-tab-btn="live">LIVE</button>
  <button class="tabBtn" type="button" data-tab-btn="fixtures">FIXTURES</button>
  <button class="tabBtn" type="button" data-tab-btn="audio">AUDIO</button>
  <button id="midiTabBtn" class="tabBtn hidden" type="button" data-tab-btn="midi">MIDI</button>
  <button class="tabBtn" type="button" data-tab-btn="custom">CUSTOM</button>
  <button class="tabBtn" type="button" data-tab-btn="mods">MODS</button>
  <button class="tabBtn" type="button" data-tab-btn="system">SYSTEM</button>
</div>

<div class="panel tabPage active" data-tab="live">
  <div class="cluster liveMainCluster">
    <h3>POWER <span class="infoTip" title="RAVE ON starts live reactive output. RAVE OFF stops reactive output. PANIC forces immediate blackout intent.">?</span></h3>
    <div class="grid3">
      <button id="onBtn" type="button">RAVE ON</button>
      <button id="offBtn" type="button">RAVE OFF</button>
      <button id="panicBtn" type="button" class="bad">PANIC</button>
    </div>
    <div class="liveProfileRow">
      <input id="liveProfileName" type="text" placeholder="profile name (local)" maxlength="32" autocomplete="off" spellcheck="false">
      <select id="liveProfileSelect" title="Select a saved local LIVE profile.">
        <option value="__custom__">CUSTOM / TYPE NAME</option>
      </select>
      <button id="liveProfileSaveBtn" type="button">SAVE PROFILE</button>
      <button id="liveProfileLoadBtn" type="button">LOAD PROFILE</button>
      <button id="liveProfileDeleteBtn" type="button" class="warn">DELETE PROFILE</button>
      <button id="liveProfileResetBtn" type="button">RESET DEFAULT</button>
    </div>
    <p id="liveProfileStat" class="hint liveProfileStat">LIVE PROFILE: default (unsaved)</p>

    <h3>MODE <span class="infoTip" title="BPM (INTERPRET) is always active. Old mode switching was removed.">?</span></h3>
    <p class="hint">BPM (INTERPRET) is enforced globally.</p>

    <div class="subcluster collapsible livePriorityPanel" data-collapsible-key="livePriorityControls">
      <div class="clusterHeaderRow">
        <h3>PRIORITY // META + HZ + REACTIVITY</h3>
        <button type="button" class="collapseBtn" data-collapse-btn aria-expanded="true" title="Show or hide priority live controls.">COLLAPSE</button>
      </div>
      <div class="clusterBody">
        <h3>ADAPTIVE META <span class="infoTip" title="Meta Auto infers live audio style and controls profile/reactivity/Hz. Choosing manual PROFILE, AUDIO REACTIVITY, PALETTES, or OVERCLOCK automatically turns Meta Auto off.">?</span></h3>
        <p class="hint">Use this when you want automation to drive behavior. Keep it OFF if you are manually shaping scene, palette, and rate.</p>
        <p class="advancedSubTitle">META STATE</p>
        <div class="metaAutoPrimaryRow">
          <button id="metaAutoOnBtn" type="button">META AUTO ON</button>
          <button id="metaAutoOffBtn" type="button">META AUTO OFF</button>
        </div>
        <p class="advancedSubTitle">DOMINANT FACTOR MODE</p>
        <div class="metaAutoModeRow">
          <button id="metaAutoTrackerAutoBtn" type="button">DOMINANT MODE: AUTO OFF</button>
          <button id="metaAutoTrackerCandidatesBtn" type="button">BUILD CANDIDATES</button>
        </div>
        <p class="advancedSubTitle">ALLOWED FACTORS</p>
        <div class="metaAutoFactorGrid">
          <button id="metaAutoHueWizBaselineBlendBtn" type="button">BASE+DRUMS OFF</button>
          <button id="metaAutoTrackerPeaksBtn" type="button">PEAKS OFF</button>
          <button id="metaAutoTrackerTransientsBtn" type="button">TRANSIENTS OFF</button>
          <button id="metaAutoTrackerFluxBtn" type="button">FLUX OFF</button>
        </div>
        <p id="metaAutoHueWizBaselineBlendStat" class="hint metaAutoBiasStat">META H/W DOMINANT FACTORS: NONE (Meta Auto only; hard toggles control candidate factors).</p>

        <h3>OVERCLOCK <span class="infoTip" title="Higher Hz increases visual motion and network load. Use Entertainment mode for highest stable rates.">?</span></h3>
        <div class="grid4">
          <button id="ocOffBtn" type="button">SLOW 2HZ</button>
          <button id="ocOnBtn" type="button">SLOW 4HZ</button>
          <button id="ocTurboBtn" type="button" class="warn">DEFAULT 6HZ</button>
          <button id="ocAutoBtn" type="button">AUTO HZ (NO META)</button>
          <button id="ocUltraBtn" type="button" class="warn">ULTRA 8HZ</button>
          <button id="ocExtremeBtn" type="button" class="warn">EXTREME 10HZ</button>
          <button id="ocInsaneBtn" type="button" class="bad">INSANE 12HZ</button>
          <button id="ocHyperBtn" type="button" class="bad">HYPER 14HZ</button>
          <button id="ocLudicrousBtn" type="button" class="bad">LUDICROUS 16HZ</button>
        </div>
        <div id="ocDevCluster" class="hidden">
          <h3>UNSAFE DEV OVERCLOCK <span class="infoTip" title="Manual-only destructive rates. Never auto-mapped by profile/palette/scene and may break output stability.">?</span></h3>
          <div class="grid5">
            <button id="ocDev20Btn" type="button" class="bad">DEV 20HZ</button>
            <button id="ocDev30Btn" type="button" class="bad">DEV 30HZ</button>
            <button id="ocDev40Btn" type="button" class="bad">DEV 40HZ</button>
            <button id="ocDev50Btn" type="button" class="bad">DEV 50HZ</button>
            <button id="ocDev60Btn" type="button" class="bad">DEV 60HZ</button>
          </div>
          <p class="hint">Severe warning: these rates are intentionally destructive and unpredictable. Use only on isolated test rigs.</p>
        </div>
        <p class="hint">
          Practical rate guidance: Hue REST is usually best at 2-6Hz. Use Hue Entertainment for 8-16Hz.
          WiZ can often run faster, but weak Wi-Fi can still cause skips.
        </p>

        <h3>AUTO SWITCH PROFILE <span class="infoTip" title="REACTIVE changes behavior/scenes quickly, BALANCED is moderate, CINEMATIC holds longer and transitions slowly.">?</span></h3>
        <div class="grid3">
          <button type="button" data-auto-profile="reactive">REACTIVE</button>
          <button type="button" data-auto-profile="balanced">BALANCED</button>
          <button type="button" data-auto-profile="cinematic">CINEMATIC</button>
        </div>

        <h3>AUDIO REACTIVITY <span class="infoTip" title="BALANCED is neutral. AGGRESSIVE boosts sensitivity and pulse triggers. PRECISION is stricter and calmer.">?</span></h3>
        <div class="grid3">
          <button type="button" data-audio-reactivity="balanced">BALANCED</button>
          <button type="button" data-audio-reactivity="aggressive">AGGRESSIVE</button>
          <button type="button" data-audio-reactivity="precision">PRECISION</button>
        </div>
      </div>
    </div>

    <div class="subcluster collapsible" data-collapsible-key="liveSceneFlow" data-collapsed-default-mobile="1">
      <div class="clusterHeaderRow">
        <h3>SCENE + FLOW</h3>
        <button type="button" class="collapseBtn" data-collapse-btn aria-expanded="true" title="Show or hide scene and flow controls.">COLLAPSE</button>
      </div>
      <div class="clusterBody">
        <p class="hint">AUTO rotates scenes. IDLE/FLOW/PULSE lock a fixed scene until changed.</p>
        <div class="sceneLockRows">
          <div class="grid4">
            <button id="sceneAutoBtn" type="button" data-scene="auto">AUTO</button>
            <button type="button" data-scene="idle_soft">IDLE</button>
            <button type="button" data-scene="flow">FLOW</button>
            <button type="button" data-scene="pulse_strobe">PULSE</button>
          </div>
          <div class="grid2 sceneSyncGrid">
            <button id="sceneSyncOnBtn" type="button">SYNC HUE + WIZ</button>
            <button id="sceneSyncOffBtn" type="button">WIZ STANDALONE</button>
          </div>
        </div>
        <p id="sceneSyncStat" class="hint">SCENE LINK: HUE + WIZ SYNCED</p>
        <div class="slider">
          <label>
            <span>FLOW INTENSITY</span>
            <span class="sliderInlineControls">
              <span id="flowIntensityVal" class="sliderValue">1.00x</span>
              <button id="flowResetBtn" type="button" class="sliderInlineResetBtn">RESET</button>
            </span>
          </label>
          <input id="flowIntensity" type="range" min="35" max="250" step="1" value="100">
        </div>
        <p class="hint">Lower = smoother/calm flow, higher = faster/more animated flow.</p>
      </div>
    </div>

    <div class="subcluster collapsible" data-collapsible-key="livePaletteRouting" data-collapsed-default-mobile="1">
      <div class="clusterHeaderRow">
        <h3>PALETTE + FIXTURE ROUTING</h3>
        <button type="button" class="collapseBtn" data-collapse-btn aria-expanded="true" title="Show or hide palette and fixture-routing controls.">COLLAPSE</button>
      </div>
      <div class="clusterBody">
        <h3>COLOR PALETTE SEQUENCER <span class="infoTip" title="Manual color sequencing only. Pick 1/3/5/8/12 colors per spectrum family (RED/GREEN/BLUE). ORDER keeps family handoffs spectrally smooth; DISORDER adds chaos.">?</span></h3>
        <p class="advancedSubTitle">EDIT SCOPE</p>
        <div class="paletteScopeRow">
          <button id="paletteScopeGlobalBtn" type="button">GLOBAL SETTINGS</button>
          <button id="paletteScopeCustomBtn" type="button">CUSTOM PER FIXTURE</button>
        </div>
        <p class="hint">Custom mode enables Hue/WiZ fixture tabs and per-fixture overrides. While custom mode is active, global controls are grayed out.</p>
        <p id="paletteModeNotice" class="paletteModeNotice"></p>

        <div id="paletteGlobalPanel" class="paletteGlobalPanel">
        <div class="grid5">
          <button type="button" data-palette-count="1">1 COLOR/FAMILY</button>
          <button type="button" data-palette-count="3">3 COLORS/FAMILY</button>
          <button type="button" data-palette-count="5">5 COLORS/FAMILY</button>
          <button type="button" data-palette-count="8">8 COLORS/FAMILY</button>
          <button type="button" data-palette-count="12">12 COLORS/FAMILY</button>
        </div>
        <p class="advancedSubTitle">VIVIDNESS</p>
        <div class="grid5">
          <button type="button" data-palette-vividness="0">SOFT</button>
          <button type="button" data-palette-vividness="1">BALANCED</button>
          <button type="button" data-palette-vividness="2">HIGH</button>
          <button type="button" data-palette-vividness="3">ULTRA</button>
          <button type="button" data-palette-vividness="4">MAX</button>
        </div>
        <p class="hint">Higher vividness increases saturation/contrast while keeping family identity.</p>

        <p class="advancedSubTitle">QUICK PRESETS</p>
        <div class="grid4">
          <button type="button" data-palette-preset="all_1">ALL COLORS x1</button>
          <button type="button" data-palette-preset="all_3">ALL COLORS x3</button>
          <button type="button" data-palette-preset="duo_cool">DUO COOL</button>
          <button type="button" data-palette-preset="duo_warm">DUO WARM</button>
        </div>
        <p class="hint">Use ORDERED/DISORDER below to control how presets play out.</p>

        <p class="advancedSubTitle">FAMILIES</p>
        <div id="paletteFamilyGrid" class="grid3 paletteFamilyGrid">
          <button type="button" data-palette-family="red">RED</button>
          <button type="button" data-palette-family="green">GREEN</button>
          <button type="button" data-palette-family="blue">BLUE</button>
        </div>

        <p class="advancedSubTitle">SEQUENCE ORDER</p>
        <div class="grid2">
          <button type="button" data-palette-disorder="false">ORDERED</button>
          <button type="button" data-palette-disorder="true">DISORDER</button>
        </div>
        <div class="slider">
          <label>
            <span>DISORDER AGGRESSION</span>
            <span class="sliderInlineControls">
              <span id="paletteDisorderAggressionVal" class="sliderValue">35%</span>
              <button id="paletteDisorderAggressionResetBtn" type="button" class="sliderInlineResetBtn">RESET</button>
            </span>
          </label>
          <input id="paletteDisorderAggression" type="range" min="0" max="100" step="1" value="35">
        </div>
        <p class="hint">Higher aggression increases out-of-order jumps between both colors and families.</p>

        <p class="advancedSubTitle">COLOR ENGINE MODE</p>
        <div class="paletteCycleGrid">
          <button type="button" data-palette-cycle-mode="on_trigger" title="Advance to the next palette group on beat/drop triggers. Colors inside the active group continue to move.">ON TRIGGER</button>
          <button type="button" data-palette-cycle-mode="timed_cycle" title="Advance to the next palette group every interval. Colors inside the active group continue to move between advances.">TIMED CYCLE</button>
          <button type="button" data-palette-cycle-mode="reactive_shift" title="Advance to the next palette group when tempo/progression changes pass margin. Colors inside the active group continue to move.">REACTIVE SHIFT</button>
          <button type="button" data-palette-cycle-mode="spectrum_mapper" title="Choose active palette group from mapped audio features (lows/mids/highs/etc). Colors still move inside the selected group.">SPECTRUM MAPPER</button>
        </div>

        <div id="paletteTimedControls" class="paletteControlWrap hidden">
          <div class="slider">
            <label>
              <span>CYCLE INTERVAL</span>
              <span id="paletteTimedIntervalSecVal" class="sliderValue">5s</span>
            </label>
            <input id="paletteTimedIntervalSec" type="range" min="2" max="60" step="1" value="5">
          </div>
          <p class="advancedSubTitle">BEAT LOCK</p>
          <div class="grid2">
            <button type="button" data-palette-beat-lock="false">OFF</button>
            <button type="button" data-palette-beat-lock="true">ON</button>
          </div>
          <div class="slider">
            <label>
              <span>BEAT LOCK GRACE</span>
              <span id="paletteBeatLockGraceSecVal" class="sliderValue">+2s</span>
            </label>
            <input id="paletteBeatLockGraceSec" type="range" min="0" max="8" step="1" value="2">
          </div>
        </div>

        <div id="paletteReactiveControls" class="paletteControlWrap hidden">
          <div class="slider">
            <label>
              <span>CHANGE MARGIN</span>
              <span id="paletteReactiveMarginVal" class="sliderValue">28</span>
            </label>
            <input id="paletteReactiveMargin" type="range" min="5" max="100" step="1" value="28">
          </div>
        </div>

        <p class="advancedSubTitle">BRIGHTNESS ENGINE (RAVE TEST)</p>
        <div class="grid2">
          <button type="button" data-palette-brightness-mode="legacy">LEGACY</button>
          <button type="button" data-palette-brightness-mode="test">TEST FOLLOW</button>
        </div>
        <div id="paletteBrightnessFollowWrap" class="slider hidden">
          <label>
            <span>FOLLOW AMOUNT</span>
            <span id="paletteBrightnessFollowAmountVal" class="sliderValue">1.00x</span>
          </label>
          <input id="paletteBrightnessFollowAmount" type="range" min="0" max="200" step="1" value="100">
        </div>
        <p class="hint">LEGACY keeps current brightness behavior. TEST links brightness to palette color motion + audio dynamics.</p>

        <div id="paletteSpectrumControls" class="paletteControlWrap hidden">
          <p class="hint">Spectrum Mapper picks the active palette group from audio features. Color motion inside that group still follows ORDER/DISORDER.</p>
          <p class="advancedSubTitle">MAP MODE</p>
          <div class="grid2">
            <button type="button" data-palette-spectrum-mode="auto">AUTO ASSIGN</button>
            <button type="button" data-palette-spectrum-mode="manual">MANUAL ASSIGN</button>
          </div>
          <div class="paletteSpectrumGrid">
            <select data-palette-spectrum-feature-slot="0">
              <option value="lows">SLOT 1: LOWS</option>
              <option value="mids">SLOT 1: MIDS</option>
              <option value="highs">SLOT 1: HIGHS</option>
              <option value="rms">SLOT 1: RMS</option>
              <option value="energy">SLOT 1: ENERGY</option>
              <option value="flux">SLOT 1: FLUX</option>
              <option value="peaks">SLOT 1: PEAKS</option>
              <option value="transients">SLOT 1: TRANSIENTS</option>
              <option value="beat">SLOT 1: BEAT</option>
            </select>
            <select data-palette-spectrum-feature-slot="1">
              <option value="lows">SLOT 2: LOWS</option>
              <option value="mids">SLOT 2: MIDS</option>
              <option value="highs">SLOT 2: HIGHS</option>
              <option value="rms">SLOT 2: RMS</option>
              <option value="energy">SLOT 2: ENERGY</option>
              <option value="flux">SLOT 2: FLUX</option>
              <option value="peaks">SLOT 2: PEAKS</option>
              <option value="transients">SLOT 2: TRANSIENTS</option>
              <option value="beat">SLOT 2: BEAT</option>
            </select>
            <select data-palette-spectrum-feature-slot="2">
              <option value="lows">SLOT 3: LOWS</option>
              <option value="mids">SLOT 3: MIDS</option>
              <option value="highs">SLOT 3: HIGHS</option>
              <option value="rms">SLOT 3: RMS</option>
              <option value="energy">SLOT 3: ENERGY</option>
              <option value="flux">SLOT 3: FLUX</option>
              <option value="peaks">SLOT 3: PEAKS</option>
              <option value="transients">SLOT 3: TRANSIENTS</option>
              <option value="beat">SLOT 3: BEAT</option>
            </select>
            <select data-palette-spectrum-feature-slot="3">
              <option value="lows">SLOT 4: LOWS</option>
              <option value="mids">SLOT 4: MIDS</option>
              <option value="highs">SLOT 4: HIGHS</option>
              <option value="rms">SLOT 4: RMS</option>
              <option value="energy">SLOT 4: ENERGY</option>
              <option value="flux">SLOT 4: FLUX</option>
              <option value="peaks">SLOT 4: PEAKS</option>
              <option value="transients">SLOT 4: TRANSIENTS</option>
              <option value="beat">SLOT 4: BEAT</option>
            </select>
            <select data-palette-spectrum-feature-slot="4">
              <option value="lows">SLOT 5: LOWS</option>
              <option value="mids">SLOT 5: MIDS</option>
              <option value="highs">SLOT 5: HIGHS</option>
              <option value="rms">SLOT 5: RMS</option>
              <option value="energy">SLOT 5: ENERGY</option>
              <option value="flux">SLOT 5: FLUX</option>
              <option value="peaks">SLOT 5: PEAKS</option>
              <option value="transients">SLOT 5: TRANSIENTS</option>
              <option value="beat">SLOT 5: BEAT</option>
            </select>
          </div>
        </div>
        </div>

        <div id="paletteCustomPanel" class="paletteCustomPanel hidden">
        <p class="advancedSubTitle">FIXTURE TYPE</p>
        <div id="paletteCustomBrandTabs" class="paletteCustomBrandTabs">
          <button type="button" data-palette-custom-brand="hue">HUE</button>
          <button type="button" data-palette-custom-brand="wiz">WIZ</button>
        </div>
        <p class="advancedSubTitle">CUSTOM ROUTING + OVERRIDES</p>
        <div id="paletteBrandMenus" class="paletteBrandMenus"></div>
        <p class="hint">Per-brand/per-fixture menus control both palette sequence and song-metric routing (MANUAL vs META AUTO) without affecting other fixtures.</p>
        </div>
      </div>
    </div>

    <div class="subcluster collapsible" data-collapsible-key="liveAppIsolationQuick" data-collapsed-default="1" data-collapsed-default-mobile="1">
      <div class="clusterHeaderRow">
        <h3>AUDIO APP ISOLATION QUICK ACTION</h3>
        <button type="button" class="collapseBtn" data-collapse-btn aria-expanded="true" title="Show or hide quick app isolation actions.">COLLAPSE</button>
      </div>
      <div class="clusterBody">
        <p class="hint">Force a rescan for FFmpeg app-isolation priority/fallback now (without waiting for the 5-minute auto check).</p>
        <div class="grid2 audioQuickActionRow">
          <button id="liveAudioAppSearchBtn" type="button">FORCE APP SEARCH</button>
          <input id="liveAudioAppSearchStat" class="audioAppSearchStatus" type="text" value="App source scan idle." readonly>
        </div>
        <p class="hint">Use this after opening your priority app to force immediate capture-source handoff.</p>
      </div>
    </div>
  </div>

  <div class="cluster collapsible" data-collapsible-key="liveAnalyzer" data-collapsed-default-mobile="1">
    <div class="clusterHeaderRow">
      <h3>REACTOR // LIVE ANALYZER</h3>
      <button type="button" class="collapseBtn" data-collapse-btn aria-expanded="true" title="Show or hide analyzer visuals and deep telemetry.">COLLAPSE</button>
    </div>
    <div class="clusterBody">
    <div class="slider">
      <label>
        <span>MASTER</span>
        <span class="sliderInlineControls">
          <span id="masterVal" class="sliderValue">1.00</span>
          <button id="masterInlineResetBtn" type="button" class="sliderInlineResetBtn">RESET</button>
        </span>
      </label>
      <input id="master" type="range" min="0" max="100" value="50">
    </div>

    <div class="slider">
      <label>
        <span>DROP IMPACT</span>
        <span class="sliderInlineControls">
          <span id="dropVal" class="sliderValue">1.0</span>
          <button id="dropInlineResetBtn" type="button" class="sliderInlineResetBtn">RESET</button>
        </span>
      </label>
      <input id="dropIntensity" type="range" min="50" max="200" value="100">
    </div>
    <div class="sliderResetRow">
      <button id="reactorResetBtn" type="button">RESET BOTH</button>
    </div>
    <div id="reactorRiskNotice" class="reactorRiskNotice warn">
      Caution: raising MASTER and DROP IMPACT often hurts output quality more than it helps.
      This is especially risky with high OVERCLOCK levels.
    </div>

    <div id="scope">
      <div class="scopeHud">
        <div class="scopeChip"><strong>DRIVE</strong><span id="scopeDrive">0.00</span></div>
        <div class="scopeChip"><strong>MOTION</strong><span id="scopeMotion">0.00</span></div>
        <div class="scopeChip"><strong>SCENE</strong><span id="scopeScene">-</span></div>
        <div class="scopeChip"><strong>BEHAV</strong><span id="scopeBehav">-</span></div>
      </div>
      <canvas id="canvas"></canvas>
      <div id="dropOverlay">DROP</div>
    </div>

    <div id="telemetryScope">
      <canvas id="telemetryCanvas"></canvas>
      <div class="scopeLegend">
        <div class="legendChip">RED = ENERGY</div>
        <div class="legendChip">CYAN = RMS</div>
        <div class="legendChip">YELLOW = FLUX</div>
        <div class="legendChip">ORANGE = HUE LAT</div>
        <div class="legendChip">GREEN = WIZ LAT</div>
        <div class="legendChip">WHITE BARS = DROP</div>
      </div>
    </div>

    <div class="liveStats">
      <div class="statGroup">
        <div class="statGroupTitle">CORE SIGNAL</div>
        <div class="statGrid">
          <div class="liveStat"><strong>RMS</strong><span id="rms">0.00</span></div>
          <div class="liveStat"><strong>ENG</strong><span id="eng">0.00</span></div>
          <div class="liveStat"><strong>MODE</strong><span id="mode">-</span></div>
          <div class="liveStat"><strong>PALETTES</strong><span id="paletteStat">BLUE+PURPLE</span></div>
          <div class="liveStat"><strong>ORDER</strong><span id="paletteOrderStat">ORDERED</span></div>
          <div class="liveStat"><strong>SCENE</strong><span id="scene">-</span></div>
        </div>
      </div>

      <div class="statGroup">
        <div class="statGroupTitle">ADAPTIVE STATE</div>
        <div class="statGrid">
          <div class="liveStat"><strong>BEHAV</strong><span id="behavior">-</span></div>
          <div class="liveStat"><strong>PHRASE</strong><span id="phrase">-</span></div>
          <div class="liveStat"><strong>DROP</strong><span id="dropStat">NO</span></div>
          <div class="liveStat"><strong>AUTO</strong><span id="autoProfile">-</span></div>
          <div class="liveStat"><strong>A-REACT</strong><span id="audioReact">-</span></div>
          <div class="liveStat"><strong>META</strong><span id="metaAutoStat">OFF</span></div>
          <div class="liveStat"><strong>FLOW X</strong><span id="flowStat">1.00x</span></div>
        </div>
      </div>

      <div class="statGroup">
        <div class="statGroupTitle">TRANSPORT</div>
        <div class="statGrid">
          <div class="liveStat"><strong>HUE STATE</strong><span id="hState">OK</span></div>
          <div class="liveStat"><strong>WIZ STATE</strong><span id="wState">OK</span></div>
          <div class="liveStat"><strong>HUE LAT</strong><span id="hLat">0</span></div>
          <div class="liveStat"><strong>WIZ LAT</strong><span id="wLat">0</span></div>
          <div class="liveStat"><strong>HUE SENT</strong><span id="hSent">0</span></div>
          <div class="liveStat"><strong>WIZ SENT</strong><span id="wSent">0</span></div>
          <div class="liveStat"><strong>HUE SKIP</strong><span id="hSkip">0</span></div>
          <div class="liveStat"><strong>WIZ SKIP</strong><span id="wSkip">0</span></div>
        </div>
      </div>
    </div>
    </div>
  </div>
</div>

<div class="panel tabPage" data-tab="fixtures">
  <div class="cluster">
    <h3>FIXTURE PAIRING / DEVICE SETUP</h3>
    <div class="fixtureGrid">
      <div>
        <label for="fxBrand">BRAND</label>
        <select id="fxBrand">
          <option value="hue">Hue</option>
          <option value="wiz">WiZ</option>
          <optgroup id="fxModBrandGroup" label="Mod Brands (locked)" disabled>
            <option value="" disabled>No mod brands detected</option>
          </optgroup>
        </select>
        <div id="fxModBrandStatus" class="hint fixtureModBrandStatus prefixDisabled">
          Mod fixture brands unlock when mods are discovered.
        </div>
      </div>
      <div id="fxModBrandWrap" class="hidden">
        <label for="fxModBrandId">MOD BRAND ID <span class="infoTip" title="Lowercase adapter brand id provided by your mod (example: http-rgb).">?</span></label>
        <input id="fxModBrandId" class="mono" type="text" placeholder="example: http-rgb" autocomplete="off" spellcheck="false" maxlength="32">
      </div>
      <div>
        <label for="fxId">ID</label>
        <input id="fxId" type="text" placeholder="auto if blank">
      </div>
      <div>
        <label for="fxZone">ZONE</label>
        <input id="fxZone" type="text" placeholder="custom path (e.g. desk-left)">
      </div>
      <div>
        <label for="fxEnabled">ENABLED</label>
        <select id="fxEnabled">
          <option value="true">true</option>
          <option value="false">false</option>
        </select>
      </div>
      <div id="fxHueLightWrap">
        <label for="fxLightId">HUE LIGHT ID <span class="infoTip" title="The numeric Hue light id for REST commands. Use the same id shown by the Hue API/bridge app.">?</span></label>
        <input id="fxLightId" type="number" min="1" value="1">
      </div>
      <div id="fxWizIpWrap" class="hidden">
        <label id="fxWizIpLabel" for="fxWizIp">WIZ IP <span class="infoTip" title="LAN IP of the WiZ fixture. One fixture per entry in this form.">?</span></label>
        <div class="secretFieldRow">
          <input id="fxWizIp" type="password" placeholder="192.168.x.x" autocomplete="off">
          <button id="fxWizIpShowBtn" type="button" class="warn secretToggleBtn" title="Reveal or hide this sensitive field.">SHOW</button>
        </div>
      </div>
      <div class="grid2">
        <button id="fxSaveBtn" type="button" title="Save this fixture entry to fixtures.config.json.">SAVE FIXTURE</button>
        <button id="fxResetBtn" type="button" title="Clear all fixture form fields.">CLEAR FORM</button>
      </div>
      <input id="fxEngineEnabled" type="hidden" value="true">
      <input id="fxCustomEnabled" type="hidden" value="false">
      <input id="fxTwitchEnabled" type="hidden" value="true">
      <input id="fxControlMode" type="hidden" value="engine">
      <input id="fxEngineBinding" type="hidden" value="hue">
      <input id="fxOriginalId" type="hidden" value="">
      <div id="fxCompatHint" class="hidden"></div>
    </div>

    <div id="fxHueBridgeBlock" class="subcluster">
      <h3>HUE BRIDGE / PAIRING</h3>
      <div class="fixtureGrid">
      <div id="fxHueBridgeWrap">
        <label for="fxBridgeIp">HUE BRIDGE IP <span class="infoTip" title="Bridge LAN IP. Discover fills this automatically on the current network.">?</span></label>
        <div class="secretFieldRow">
          <input id="fxBridgeIp" type="password" placeholder="192.168.x.x" autocomplete="off">
          <button id="fxBridgeIpShowBtn" type="button" class="warn secretToggleBtn" title="Reveal or hide this sensitive field.">SHOW</button>
        </div>
      </div>
      <div id="fxHueUserWrap">
        <label for="fxUsername">HUE USERNAME <span class="infoTip" title="Hue application key used for REST and entertainment setup. Pairing generates this for you.">?</span></label>
        <div class="secretFieldRow">
          <input id="fxUsername" type="password" class="mono" placeholder="app key" autocomplete="off">
          <button id="fxUsernameShowBtn" type="button" class="warn secretToggleBtn" title="Reveal or hide this sensitive field.">SHOW</button>
        </div>
      </div>
      <div id="fxHueBridgeIdWrap">
        <label for="fxBridgeId">HUE BRIDGE ID <span class="infoTip" title="Unique bridge identifier required by Hue Entertainment transport.">?</span></label>
        <input id="fxBridgeId" type="text" class="mono" placeholder="ECB5...">
      </div>
      <div id="fxHueClientKeyWrap">
        <label for="fxClientKey">HUE CLIENT KEY <span class="infoTip" title="DTLS client key used by Hue Entertainment for low-latency streaming. Generated during pairing.">?</span></label>
        <div class="secretFieldRow">
          <input id="fxClientKey" type="password" class="mono" placeholder="for entertainment" autocomplete="off">
          <button id="fxClientKeyShowBtn" type="button" class="warn secretToggleBtn" title="Reveal or hide this sensitive field.">SHOW</button>
        </div>
      </div>
      <div id="fxHueEntWrap">
        <label for="fxEntertainmentAreaId">ENT AREA (NAME/ID) <span class="infoTip" title="Entertainment Area to stream to. Use name or id from the paired bridge areas list.">?</span></label>
        <input id="fxEntertainmentAreaId" type="text" placeholder="Living Room">
      </div>
      <div id="fxHuePairWrap" class="pairActionRow">
        <div class="grid2">
          <button id="fxHueDiscoverBtn" type="button" class="pairDiscoverBtn" title="Step 1: Discover bridge IP/ID from local network.">1) DISCOVER BRIDGE</button>
          <button id="fxHuePairBtn" type="button" class="pairLinkBtn" title="Step 2: Press physical Hue bridge link button, then run pairing.">2) PAIR (PRESS LINK)</button>
        </div>
        <div class="pairBridgeSaveRow">
          <button id="fxHueSaveBridgeBtn" type="button" class="pairBridgeSaveBtn" title="Save Hue bridge fields to the selected fixture without re-pairing.">SAVE BRIDGE EDITS (NO RE-PAIR)</button>
        </div>
      </div>
      <div class="hint"><b>Pairing order:</b> Discover Bridge -> press link button on bridge -> Pair.</div>
      <div class="hint"><b>Bridge edits:</b> after loading a fixture with EDIT, change Hue bridge fields and click <b>SAVE BRIDGE EDITS</b> to confirm without pairing again.</div>
      <div class="hint">
        <b>Entertainment area required:</b> create one in the Hue app, then use that name/id here.
        <span class="infoTip" title="Hue app -> Settings -> Entertainment areas -> Create area -> add lights -> Save. Then paste that area name or id into ENT AREA.">?</span>
      </div>
      <div class="hint">
        Discovery and pairing only apply to Hue fixtures. Press the bridge link button during pairing.
        Pairing fills username/client key/bridge id so Entertainment can run.
      </div>
      <div class="hint">
        Recommendation: configure Hue Entertainment for smooth high-rate scenes.
        Without it, Hue falls back to REST, which is safer but less responsive at very high Hz.
      </div>
    </div>
    </div>
  </div>

  <div class="cluster collapsible" data-collapsible-key="fixtureList" data-collapsed-default-mobile="1">
    <div class="clusterHeaderRow">
      <h3>FIXTURE LIST</h3>
      <button type="button" class="collapseBtn" data-collapse-btn aria-expanded="true" title="Show or hide fixture table.">COLLAPSE</button>
    </div>
    <div class="clusterBody">
    <p class="hint">
      <b>First-time setup:</b> entries like <code>hue-main-1</code> and <code>wiz-custom-1</code> are placeholder fixtures.
      Delete them and save your real devices before starting Rave mode.
    </p>
    <div class="tableWrap">
      <table>
        <thead>
          <tr>
            <th>ID</th>
            <th>BRAND</th>
            <th>ZONE</th>
            <th title="Current per-fixture enable state for ENGINE, TWITCH, and CUSTOM paths.">APPLIED MODES</th>
            <th title="Resolved route bindings this fixture listens to.">ROUTE PATH</th>
            <th>TARGET</th>
            <th>ENABLED</th>
            <th>ACTIONS</th>
          </tr>
        </thead>
        <tbody id="fixtureRows"></tbody>
      </table>
    </div>
    <p class="hint">APPLIED MODES shows per-fixture state: ENG (rave engine), TWITCH (/color), CUSTOM (manual/self-animate).</p>
    </div>
  </div>

  <div class="cluster collapsible" id="deviceRouting" data-collapsible-key="deviceRouting" data-collapsed-default-mobile="1">
    <div class="clusterHeaderRow">
      <h3>DEVICE ROUTING</h3>
      <button type="button" class="collapseBtn" data-collapse-btn aria-expanded="true" title="Collapse this section to reduce clutter.">COLLAPSE</button>
    </div>
    <div class="clusterBody">
      <div class="controlRow">
        <div>
          <label for="standFixtureSelect">SELECT FIXTURE <span class="infoTip" title="Pick one fixture to edit its routing mode toggles below.">?</span></label>
          <select id="standFixtureSelect">
            <option value="">select fixture</option>
          </select>
        </div>
        <div class="routeModesWrap">
          <label>ROUTE MODES <span class="infoTip" title="ENGINE = audio rave engine. TWITCH = /color reward events (can run with either mode). CUSTOM = standalone manual/animated device control. ENGINE and CUSTOM cannot run together; whichever you press last takes priority.">?</span></label>
          <div class="routeChipGroup">
            <button id="standRouteEngine" type="button" class="routeChipToggle" data-on="false" aria-pressed="false" title="Enable this fixture for live audio rave engine output.">ENGINE</button>
            <button id="standRouteTwitch" type="button" class="routeChipToggle" data-on="false" aria-pressed="false" title="Enable this fixture for Twitch/color route events.">TWITCH</button>
            <button id="standRouteCustom" type="button" class="routeChipToggle" data-on="false" aria-pressed="false" title="Enable standalone custom control for this fixture.">CUSTOM</button>
          </div>
        </div>
        <div class="grid2">
          <button id="standRouteApplyBtn" type="button" title="Save the ENGINE/TWITCH/CUSTOM mode toggles for the selected fixture.">APPLY ROUTING</button>
          <button id="standRefreshBtn" type="button" title="Reload fixture list from server before editing routes.">REFRESH FIXTURES</button>
          <button id="standConnectivityBtn" type="button" title="Run a live connectivity test for the selected fixture host/IP.">TEST CONNECTIVITY</button>
        </div>
        <div>
          <label for="standRouteStatus">STATUS <span class="infoTip" title="Shows selected fixture and its currently active route modes.">?</span></label>
          <input id="standRouteStatus" type="text" value="Select fixture and routing options." readonly>
          <label for="standConnectivityStatus">CONNECTIVITY</label>
          <input id="standConnectivityStatus" type="text" value="No connectivity test yet." readonly>
        </div>
      </div>
      <p class="hint"><code>ENGINE</code> and <code>TWITCH</code> can run together. New fixtures default to <code>ENGINE + TWITCH</code>. <code>CUSTOM</code> can run with <code>TWITCH</code>, but not with <code>ENGINE</code> (last toggle wins between ENGINE/CUSTOM).</p>

      <div class="fixtureToolbar">
        <div>
          <label for="routeHueInput">DERIVED HUE_STATE <span class="infoTip" title="Derived automatically from Hue fixtures that have ENGINE enabled.">?</span></label>
          <input id="routeHueInput" type="text" readonly>
        </div>
        <div>
          <label for="routeWizInput">DERIVED WIZ_PULSE <span class="infoTip" title="Derived automatically from WiZ fixtures that have ENGINE enabled.">?</span></label>
          <input id="routeWizInput" type="text" readonly>
        </div>
        <div>
          <label for="routeTwitchHueInput">DERIVED TWITCH_HUE <span class="infoTip" title="Derived automatically from Hue fixtures that have TWITCH enabled.">?</span></label>
          <input id="routeTwitchHueInput" type="text" readonly>
        </div>
        <div>
          <label for="routeTwitchWizInput">DERIVED TWITCH_WIZ <span class="infoTip" title="Derived automatically from WiZ fixtures that have TWITCH enabled.">?</span></label>
          <input id="routeTwitchWizInput" type="text" readonly>
        </div>
        <div>
          <label for="fixturesReloadBtn">ROUTING CONFIG</label>
          <button id="fixturesReloadBtn" type="button" title="Reload fixtures.config.json and route table from disk.">RELOAD CFG</button>
        </div>
      </div>
      <p class="hint">These route values are read-only and updated automatically from fixture toggles.</p>

      <div class="twitchPrefixPanel">
        <h3>TWITCH COLOR COMMAND ROUTING</h3>
        <div class="twitchPrefixGrid">
          <p class="prefixSyntax">
            Quick setup:
            use <code>/color hue red</code> and <code>/color wiz blue</code> style prefixes,
            or leave command unprefixed and route it below.
          </p>
          <div class="prefixQuickGrid">
            <div>
              <label for="colorPrefixHue">HUE COMMAND PREFIX (OPTIONAL)</label>
              <input id="colorPrefixHue" type="text" value="hue" placeholder="hue">
            </div>
            <div>
              <label for="colorPrefixWiz">WIZ COMMAND PREFIX (OPTIONAL)</label>
              <input id="colorPrefixWiz" type="text" value="wiz" placeholder="wiz">
            </div>
            <div>
              <label for="colorPrefixDefaultTarget">UNPREFIXED /color GOES TO</label>
              <select id="colorPrefixDefaultTarget">
                <option value="both">both (Hue + WiZ sync)</option>
                <option value="hue">hue only</option>
                <option value="wiz">wiz only</option>
              </select>
            </div>
          </div>
          <div class="prefixActions">
            <button id="colorPrefixSaveBtn" type="button">SAVE PREFIX CONFIG</button>
            <button id="colorPrefixResetBtn" type="button">RESET PREFIX DEFAULTS</button>
          </div>

          <details class="prefixSection">
            <summary>Advanced Prefix Rules (Optional)</summary>
            <div class="prefixSectionBody">
              <div class="prefixAdvancedGrid">
                <div id="colorPrefixOtherWrap" class="prefixDisabled">
                  <label for="colorPrefixOther">MOD-BRAND PREFIX (OPTIONAL)</label>
                  <input id="colorPrefixOther" type="text" placeholder="e.g. lifx">
                </div>
                <div class="prefixFullRow">
                  <label for="colorPrefixFixtureMap">PER-FIXTURE PREFIX RULES (OPTIONAL) <span class="infoTip" title="One line per fixture: fixtureId=prefix. These override brand prefixes.">?</span></label>
                  <textarea id="colorPrefixFixtureMap" placeholder="hue-main-1=desk&#10;wiz-background-1=back"></textarea>
                  <p class="prefixSyntax">Syntax: <code>fixtureId=prefix</code> (one rule per line).</p>
                </div>
              </div>
            </div>
          </details>

          <details class="prefixSection" open>
            <summary>RAVE OFF End Color Profile</summary>
            <div class="prefixSectionBody">
              <div class="prefixAdvancedGrid">
                <div>
                  <label for="colorRaveOffEnabled">RAVE OFF PROFILE</label>
                  <select id="colorRaveOffEnabled">
                    <option value="1">enabled</option>
                    <option value="0">disabled</option>
                  </select>
                </div>
                <div>
                  <label for="colorRaveOffDefault">DEFAULT RAVE OFF COMMAND</label>
                  <input id="colorRaveOffDefault" type="text" placeholder="e.g. random">
                </div>
                <div class="prefixFullRow">
                  <label for="colorRaveOffGroupMap">GROUP RULES (OPTIONAL) <span class="infoTip" title="One line per group: key=command. key can be hue, wiz, hue:zone, or wiz:zone.">?</span></label>
                  <textarea id="colorRaveOffGroupMap" placeholder="hue=random&#10;wiz=random&#10;hue:desk=purple"></textarea>
                  <p class="prefixSyntax">Syntax: <code>hue=command</code>, <code>wiz=command</code>, or <code>hue:zone=command</code>.</p>
                </div>
                <div class="prefixFullRow">
                  <label for="colorRaveOffFixtureMap">FIXTURE RULES (OPTIONAL) <span class="infoTip" title="One line per fixture: fixtureId=command. Fixture override wins over group/default.">?</span></label>
                  <textarea id="colorRaveOffFixtureMap" placeholder="hue-main-1=dim red&#10;wiz-background-1=blue"></textarea>
                  <p class="prefixSyntax">Syntax: <code>fixtureId=command</code> (one rule per line).</p>
                </div>
              </div>
            </div>
          </details>
        </div>
        <p id="colorPrefixStatus" class="hint">
          Set optional prefixes for Hue/WiZ, choose where unprefixed <code>/color</code> goes, then save.
        </p>
      </div>
    </div>
  </div>
</div>

<div class="panel tabPage" data-tab="audio">
  <div class="cluster">
    <h3>AUDIO CONTROL <span class="infoTip" title="Configure input source and sensitivity. Hover labels/buttons for what each control changes.">?</span></h3>
    <div class="audioGuide">
      <div class="audioGuideGrid">
        <div class="audioGuideCard">
          <strong>1) Quick setup first</strong>
          <span>Pick <b>INPUT DEVICES</b>, then set <b>SOURCE ROUTING + APP ISOLATION</b> right below. Most setups only need this section.</span>
        </div>
        <div class="audioGuideCard">
          <strong>2) Apply + verify</strong>
          <span>Click <b>APPLY AUDIO CFG</b>, then check <b>AUDIO PIPELINE</b> and <b>APP ISO STATUS</b> while your app is playing.</span>
        </div>
        <div class="audioGuideCard">
          <strong>3) Use advanced only if needed</strong>
          <span>Expand <b>ADVANCED AUDIO TUNING</b> only for thresholds, limiter behavior, and watchdog/debug controls.</span>
        </div>
      </div>
    </div>
    <div id="aOptionalToolsBanner" class="audioOptionalToolsBanner hidden">
      <div class="audioOptionalToolsHead">
        <strong>OPTIONAL AUDIO TOOLS</strong>
        <span id="aOptionalToolsBadge" class="statusPill warn">CHECKING</span>
      </div>
      <p id="aOptionalToolsText" class="hint audioOptionalToolsBody">
        Checking optional app-isolation tools...
      </p>
      <div class="audioOptionalToolsActions">
        <button id="aOptionalToolsInfoBtn" type="button">HOW TO INSTALL</button>
        <button id="aOptionalToolsDismissBtn" type="button">DISMISS</button>
      </div>
    </div>
    <div class="subcluster">
      <h3>QUICK SETUP</h3>
      <p class="hint">For most users: pick a device, choose sample rate + frames, then apply.</p>
      <div class="controlRow">
        <div>
          <label for="aDevices">INPUT DEVICES <span class="infoTip" title="Enumerated audio input devices discovered by the host audio backend.">?</span></label>
          <select id="aDevices"></select>
        </div>
        <div>
          <label for="aDeviceMatch">DEVICE MATCH <span class="infoTip" title="Optional partial device name match. Example: stereo mix, loopback, cable output.">?</span></label>
          <input id="aDeviceMatch" type="text" value="" placeholder="optional name match (e.g. stereo mix)" />
        </div>
        <div>
          <label for="aSampleRate">SAMPLE RATE <span class="infoTip" title="Higher rate can be cleaner but uses more CPU. 44100/48000 are common stable defaults.">?</span></label>
          <select id="aSampleRate">
            <option value="44100">44100</option>
            <option value="48000">48000</option>
            <option value="96000">96000</option>
          </select>
        </div>
        <div>
          <label for="aFrames">FRAMES/BUFFER <span class="infoTip" title="Lower = lower latency but can crackle/drop on weak systems. Higher = steadier but slower reaction.">?</span></label>
          <select id="aFrames">
            <option value="128">128</option>
            <option value="256">256</option>
            <option value="512">512</option>
            <option value="1024">1024</option>
          </select>
        </div>
      </div>
      <div class="audioQuickSecondaryRow">
        <div>
          <label for="aChannels">CHANNELS <span class="infoTip" title="Use 2 for stereo devices. Use 1 only for mono input capture.">?</span></label>
          <select id="aChannels">
            <option value="1">1</option>
            <option value="2" selected>2</option>
          </select>
        </div>
        <div>
          <label for="aGain">GAIN <span class="infoTip" title="Input amplification before feature extraction. Increase if levels stay low; reduce if clipping/overreaction.">?</span></label>
          <input id="aGain" type="number" step="0.01" min="0.2" max="3.0" value="1.00" />
        </div>
      </div>
      <div class="subcluster collapsible" data-collapsible-key="audioSourceIsolationQuick" data-collapsed-default="0" data-collapsed-default-mobile="0">
        <div class="clusterHeaderRow">
          <h3>SOURCE ROUTING + APP ISOLATION</h3>
          <button type="button" class="collapseBtn" data-collapse-btn aria-expanded="true" title="Show or hide source routing and app isolation setup.">COLLAPSE</button>
        </div>
        <div class="clusterBody">
          <p class="hint">Quick setup: choose main app + backup app, verify source devices, then apply audio config. Advanced controls remain available.</p>
          <div class="audioRouteModeRow">
            <label><input id="aIsoSimpleMode" type="checkbox" checked> SIMPLE MODE (RECOMMENDED)</label>
            <label><input id="aAppsShowAll" type="checkbox"> SHOW ALL PROCESSES (ADVANCED)</label>
          </div>
          <p id="aAppsFilterHint" class="hint audioAppsFilterHint">APP LIST MODE: likely audio apps.</p>
          <div class="controlRow">
            <div>
              <label for="aInputBackend">CAPTURE BACKEND <span class="infoTip" title="AUTO uses PortAudio unless an FFmpeg input device is configured. Use FFMPEG for app-isolated virtual-device capture.">?</span></label>
              <select id="aInputBackend">
                <option value="auto">auto</option>
                <option value="portaudio">portaudio</option>
                <option value="ffmpeg">ffmpeg</option>
              </select>
            </div>
            <div class="audioIsoAdvanced">
              <label for="aFfmpegFormat">FFMPEG INPUT FORMAT <span class="infoTip" title="Windows usually uses dshow for virtual cables.">?</span></label>
              <select id="aFfmpegFormat">
                <option value="dshow">dshow</option>
                <option value="wasapi">wasapi</option>
              </select>
            </div>
            <div>
              <label for="aFfmpegDevice">PRIMARY INPUT DEVICE (FFMPEG) <span class="infoTip" title="For dshow, use device display name (example: CABLE Output (VB-Audio Virtual Cable)).">?</span></label>
              <input id="aFfmpegDevice" type="text" value="" placeholder="CABLE Output (VB-Audio Virtual Cable)">
            </div>
            <div>
              <label for="aFfmpegSources">DEFAULT SOURCE DEVICE(S) <span class="infoTip" title="One source per line (or comma-separated). First source is used by default.">?</span></label>
              <textarea id="aFfmpegSources" rows="3" placeholder="CABLE Output (VB-Audio Virtual Cable)"></textarea>
            </div>
          </div>
          <div class="controlRow">
            <div>
              <label><input id="aAppIsolationEnabled" type="checkbox"> AUTO SWITCH TO MAIN/BACKUP APP (RECOMMENDED)</label>
              <div class="audioIsoAdvanced">
                <label><input id="aAppIsolationMultiSource" type="checkbox"> MIX MULTIPLE SOURCES (AMIX)</label>
                <label><input id="aAppIsolationStrict" type="checkbox"> STRICT APP ISOLATION (NO FALLBACK)</label>
                <label for="aAppIsolationCheckMs">APP ISO CHECK INTERVAL</label>
                <select id="aAppIsolationCheckMs">
                  <option value="60000">1 MIN</option>
                  <option value="120000">2 MIN</option>
                  <option value="300000" selected>5 MIN</option>
                  <option value="600000">10 MIN</option>
                  <option value="900000">15 MIN</option>
                </select>
                <p class="hint">When MIX is OFF, only the first source is used. When ON, all listed sources are mixed.</p>
              </div>
            </div>
            <div>
              <label for="aAppPrimary">MAIN APP (AUTO SWITCH)</label>
              <select id="aAppPrimary"></select>
            </div>
            <div>
              <label for="aAppFallback">BACKUP APP (IF MAIN IS CLOSED)</label>
              <select id="aAppFallback"></select>
            </div>
            <div class="audioIsoAdvanced">
              <label for="aAppPrimarySources">PRIORITY APP SOURCES <span class="infoTip" title="Optional override source list for the priority app. Leave blank to use DEFAULT ISOLATED SOURCES.">?</span></label>
              <textarea id="aAppPrimarySources" rows="3" placeholder="optional override"></textarea>
            </div>
            <div class="audioIsoAdvanced">
              <label for="aAppFallbackSources">FALLBACK APP SOURCES <span class="infoTip" title="Optional override source list for fallback app or fallback mode when priority app is missing.">?</span></label>
              <textarea id="aAppFallbackSources" rows="3" placeholder="optional fallback override"></textarea>
            </div>
          </div>
          <div class="grid2 audioQuickActionRow">
            <button id="aAppsRefreshBtn" type="button" title="Refresh running app list for app-isolation selectors.">REFRESH APP LIST</button>
            <input id="aAppIsolationStatus" class="audioAppSearchStatus" type="text" value="App source scan idle." readonly>
          </div>
          <p class="hint">Windows workflow: route each target app to a virtual cable in App Volume & Device Preferences, then map those cable device names here.</p>
        </div>
      </div>
      <div>
        <label>QUICK AUDIO TUNING <span class="infoTip" title="Simple sliders for common system-to-system tuning. Move sliders, then apply.">?</span></label>
        <div class="audioQuickTuneMeta">
          <label><input id="aQuickSnapStages" type="checkbox" checked> SNAP STAGES</label>
          <button id="aQuickTuneResetBtn" type="button" title="Reset quick audio sliders to default tuned values.">RESET QUICK SLIDERS</button>
        </div>
        <div class="audioQuickTuneGrid">
          <div class="audioQuickTuneCard">
            <div class="slider">
              <label for="aQuickProfileMix">
                <span>SYSTEM MATCH (MULTI)</span>
                <span id="aQuickProfileMixVal" class="sliderValue">50%</span>
              </label>
              <input id="aQuickProfileMix" type="range" min="0" max="100" step="1" value="50" />
            </div>
            <div id="aQuickProfileStage" class="audioQuickTuneStage">STAGE: BALANCED</div>
            <div class="audioQuickTuneAffects">AFFECTS: sensitivity, silence gate, low-volume boost, boost activity gate, high-volume control</div>
          </div>
          <div class="audioQuickTuneCard">
            <div class="slider">
              <label for="aQuickGain">
                <span>SENSITIVITY</span>
                <span id="aQuickGainVal" class="sliderValue">1.00x</span>
              </label>
              <input id="aQuickGain" type="range" min="0" max="100" step="1" value="35" />
            </div>
            <div id="aQuickGainStage" class="audioQuickTuneStage">STAGE: BALANCED</div>
            <div class="audioQuickTuneAffects">AFFECTS: output gain</div>
          </div>
          <div class="audioQuickTuneCard">
            <div class="slider">
              <label for="aQuickNoiseGate">
                <span>SILENCE GATE</span>
                <span id="aQuickNoiseGateVal" class="sliderValue">0.00045</span>
              </label>
              <input id="aQuickNoiseGate" type="range" min="0" max="100" step="1" value="28" />
            </div>
            <div id="aQuickNoiseGateStage" class="audioQuickTuneStage">STAGE: CLEAN ROOM</div>
            <div class="audioQuickTuneAffects">AFFECTS: noise floor minimum gate</div>
          </div>
          <div class="audioQuickTuneCard">
            <div class="slider">
              <label for="aQuickAutoTarget">
                <span>LOW-VOLUME BOOST</span>
                <span id="aQuickAutoTargetVal" class="sliderValue">0.028</span>
              </label>
              <input id="aQuickAutoTarget" type="range" min="0" max="100" step="1" value="31" />
            </div>
            <div id="aQuickAutoTargetStage" class="audioQuickTuneStage">STAGE: BALANCED</div>
            <div class="audioQuickTuneAffects">AFFECTS: auto target RMS</div>
          </div>
          <div class="audioQuickTuneCard">
            <div class="slider">
              <label for="aQuickAutoGate">
                <span>BOOST ACTIVITY GATE</span>
                <span id="aQuickAutoGateVal" class="sliderValue">0.007</span>
              </label>
              <input id="aQuickAutoGate" type="range" min="0" max="100" step="1" value="25" />
            </div>
            <div id="aQuickAutoGateStage" class="audioQuickTuneStage">STAGE: NORMAL</div>
            <div class="audioQuickTuneAffects">AFFECTS: auto-level activation gate</div>
          </div>
          <div class="audioQuickTuneCard">
            <div class="slider">
              <label for="aQuickLimiter">
                <span>HIGH-VOLUME CONTROL</span>
                <span id="aQuickLimiterVal" class="sliderValue">82%</span>
              </label>
              <input id="aQuickLimiter" type="range" min="0" max="100" step="1" value="70" />
            </div>
            <div id="aQuickLimiterStage" class="audioQuickTuneStage">STAGE: BALANCED</div>
            <div class="audioQuickTuneAffects">AFFECTS: limiter threshold</div>
          </div>
        </div>
        <div class="audioQuickTuneApplyRow grid2">
          <button id="aQuickTuneApplyBtn" type="button" title="Apply only quick audio tuning sliders now.">APPLY QUICK TUNING</button>
        </div>
        <p class="hint">These sliders mirror detailed fields below and are safe for everyday tuning when apps play too low or too loud.</p>
      </div>
      <div>
        <label>AUDIO QUALITY PROFILES <span class="infoTip" title="One-click presets for common sample-rate/buffer combos. Apply after selecting.">?</span></label>
        <div class="grid4 audioQuickPresetGrid">
          <button type="button" data-audio-quick="safe" title="Safer stability profile: 48000 / 512">SAFE</button>
          <button type="button" data-audio-quick="balanced" title="Balanced profile: 48000 / 256">BALANCED</button>
          <button type="button" data-audio-quick="fast" title="Lower latency profile: 48000 / 128">FAST</button>
          <button type="button" data-audio-quick="hires" title="High-rate profile: 96000 / 256">HI-RES</button>
        </div>
        <p class="hint audioQuickPresetHint">Profiles only change sample rate + frames/buffer.</p>
      </div>
      <div class="grid2 audioQuickActionRow">
        <button id="aRefreshBtn" type="button" title="Reload current audio config from server.">REFRESH CFG</button>
        <button id="aScanBtn" type="button" title="Rescan input devices from the audio backend.">SCAN DEVICES</button>
      </div>
      <div class="grid3 audioQuickActionRow">
        <button id="aApplyBtn" type="button" class="warn" title="Save these audio settings to server and apply immediately.">APPLY AUDIO CFG</button>
        <button id="aRestartBtn" type="button" title="Restart audio capture pipeline with current settings.">RESTART AUDIO</button>
        <button id="aResetDefaultsBtn" type="button" class="warn" title="Restore audio settings to defaults and apply immediately.">RESET AUDIO DEFAULTS</button>
      </div>
    </div>

    <div class="subcluster collapsible" data-collapsible-key="audioAdvancedTuning" data-collapsed-default="1" data-collapsed-default-mobile="1">
      <div class="clusterHeaderRow">
        <h3>ADVANCED AUDIO TUNING</h3>
        <button type="button" class="collapseBtn" data-collapse-btn aria-expanded="true" title="Show or hide advanced audio tuning controls.">COLLAPSE</button>
      </div>
      <div class="clusterBody">
        <p class="hint">Use these when troubleshooting edge cases, room noise behavior, limiter response, or backend restart behavior.</p>
        <div class="controlRow">
          <div>
            <label for="aDeviceId">DEVICE ID (blank = auto) <span class="infoTip" title="Numeric input device id. Leave blank to auto-select based on match/fallback.">?</span></label>
            <input id="aDeviceId" type="text" placeholder="auto" />
          </div>
          <div>
            <label for="aNoise">NOISE FLOOR MIN <span class="infoTip" title="Minimum signal floor to ignore background hum. Raise if room noise triggers effects.">?</span></label>
            <input id="aNoise" type="number" step="0.00001" min="0" max="0.02" value="0.00045" />
          </div>
          <div>
            <label for="aPeakDecay">PEAK DECAY <span class="infoTip" title="How quickly peaks fall back down. Higher holds peak longer; lower decays faster.">?</span></label>
            <input id="aPeakDecay" type="number" step="0.001" min="0.5" max="0.9995" value="0.93" />
          </div>
          <div>
            <label for="aRestartMs">RESTART MS <span class="infoTip" title="Watchdog restart delay when audio stream stalls.">?</span></label>
            <input id="aRestartMs" type="number" step="50" min="250" max="20000" value="1500" />
          </div>
        </div>
        <div class="controlRow">
          <div>
            <label><input id="aAutoLevelEnabled" type="checkbox" checked> AUTO LEVEL COMPENSATION <span class="infoTip" title="Tracks source loudness and gently boosts or attenuates when app volume changes.">?</span></label>
          </div>
          <div>
            <label for="aAutoLevelTarget">AUTO TARGET RMS <span class="infoTip" title="Target raw input RMS for auto compensation. Lower = calmer, higher = stronger drive.">?</span></label>
            <input id="aAutoLevelTarget" type="number" step="0.001" min="0.005" max="0.2" value="0.028" />
          </div>
          <div>
            <label for="aAutoLevelMinGain">AUTO MIN GAIN <span class="infoTip" title="Lower bound of auto compensation multiplier.">?</span></label>
            <input id="aAutoLevelMinGain" type="number" step="0.01" min="0.2" max="3.0" value="0.45" />
          </div>
          <div>
            <label for="aAutoLevelMaxGain">AUTO MAX GAIN <span class="infoTip" title="Upper bound of auto compensation multiplier.">?</span></label>
            <input id="aAutoLevelMaxGain" type="number" step="0.01" min="0.2" max="4.0" value="1.55" />
          </div>
          <div>
            <label for="aAutoLevelGate">AUTO LEVEL GATE <span class="infoTip" title="Minimum loudness before auto-level compensation engages. Lower catches quieter apps.">?</span></label>
            <input id="aAutoLevelGate" type="number" step="0.001" min="0" max="0.03" value="0.007" />
          </div>
        </div>
        <div class="controlRow">
          <div>
            <label for="aFfmpegPath">FFMPEG PATH <span class="infoTip" title="Executable path or command name for ffmpeg.">?</span></label>
            <input id="aFfmpegPath" type="text" value="ffmpeg" placeholder="ffmpeg">
          </div>
        </div>
        <div class="controlRow">
          <div>
            <label for="aBandLowHz">BAND LOW HZ <span class="infoTip" title="Upper edge of low-frequency band used by reactive analysis.">?</span></label>
            <input id="aBandLowHz" type="number" step="1" min="60" max="500" value="180" />
          </div>
          <div>
            <label for="aBandMidHz">BAND MID HZ <span class="infoTip" title="Upper edge of mid-frequency band. Higher values shift more content from highs into mids.">?</span></label>
            <input id="aBandMidHz" type="number" step="1" min="700" max="8000" value="2200" />
          </div>
          <div>
            <label for="aLimiterThreshold">LIMITER THRESHOLD <span class="infoTip" title="Peak limiter threshold. Lower means stronger limiting.">?</span></label>
            <input id="aLimiterThreshold" type="number" step="0.01" min="0.4" max="0.99" value="0.82" />
          </div>
          <div>
            <label for="aLimiterKnee">LIMITER KNEE <span class="infoTip" title="Limiter knee softness. Higher is smoother; lower is harder clamp.">?</span></label>
            <input id="aLimiterKnee" type="number" step="0.01" min="0.02" max="0.8" value="0.16" />
          </div>
        </div>
        <div class="grid2">
          <div>
            <label for="aLogTicks">LOG EVERY TICKS <span class="infoTip" title="Internal debug logging interval. Higher values = less log noise.">?</span></label>
            <input id="aLogTicks" type="number" step="1" min="10" max="2000" value="60" />
          </div>
        </div>
        <h3>LIMITER PRESETS</h3>
        <div class="grid3">
          <button type="button" data-limiter-preset="transparent">TRANSPARENT</button>
          <button type="button" data-limiter-preset="balanced">BALANCED</button>
          <button type="button" data-limiter-preset="hard">HARD</button>
        </div>
        <p class="hint">Preset buttons only change limiter threshold and knee.</p>
      </div>
    </div>

    <div class="subcluster collapsible" data-collapsible-key="audioPerBrandReactivity" data-collapsed-default-mobile="1">
      <div class="clusterHeaderRow">
        <h3>PER-BRAND AUDIO REACTIVITY</h3>
        <button type="button" class="collapseBtn" data-collapse-btn aria-expanded="true" title="Show or hide per-brand audio reactivity mapping.">COLLAPSE</button>
      </div>
      <div class="clusterBody">
        <div class="audioReactMap">
          <div class="audioReactMapHeader">
            <label>PER-BRAND AUDIO REACTIVITY <span class="infoTip" title="Pick which audio features each brand responds to. Multiple source toggles blend together.">?</span></label>
            <div class="audioReactMapDropToggle">
              <label for="reactDropEnabled">DROP REACTIVE</label>
              <input id="reactDropEnabled" type="checkbox">
            </div>
          </div>
          <p class="hint">Small + simple: toggle one or more sources per brand. This also includes a CUSTOM/FUTURE row for upcoming mod-brand fixtures.</p>
          <div class="audioReactPolicyBar">
            <label><input id="reactHardwareRateLimitsEnabled" type="checkbox" checked> HARDWARE SAFE RATE CAPS</label>
            <label><input id="reactSmartMatchEnabled" type="checkbox" checked> SMART MATCH LIVE (RECOMMENDED)</label>
            <label><input id="reactForceLockEnabled" type="checkbox"> FORCE SINGLE SOURCE</label>
            <label><input id="reactForceMatchOverride" type="checkbox"> FORCE MATCH OVERRIDE</label>
            <div id="reactCompatSummary" class="audioReactCompatSummary">Compatibility policy not loaded yet.</div>
          </div>
          <div class="audioReactMapRows">
            <div class="audioReactMapRow">
              <div class="audioReactMapTop">
                <label><input id="reactHueEnabled" type="checkbox" checked> HUE</label>
                <div class="audioReactAmountWrap">
                  <span>AMOUNT</span>
                  <input id="reactHueAmount" type="range" min="0" max="180" step="1" value="100">
                  <span id="reactHueAmountVal" class="sliderValue">1.00x</span>
                </div>
              </div>
              <div id="reactHueSources" class="audioReactSources"></div>
            </div>
            <div class="audioReactMapRow">
              <div class="audioReactMapTop">
                <label><input id="reactWizEnabled" type="checkbox" checked> WIZ</label>
                <div class="audioReactAmountWrap">
                  <span>AMOUNT</span>
                  <input id="reactWizAmount" type="range" min="0" max="180" step="1" value="100">
                  <span id="reactWizAmountVal" class="sliderValue">1.00x</span>
                </div>
              </div>
              <div id="reactWizSources" class="audioReactSources"></div>
            </div>
            <div class="audioReactMapRow">
              <div class="audioReactMapTop">
                <label><input id="reactOtherEnabled" type="checkbox" checked> CUSTOM/FUTURE</label>
                <div class="audioReactAmountWrap">
                  <span>AMOUNT</span>
                  <input id="reactOtherAmount" type="range" min="0" max="180" step="1" value="100">
                  <span id="reactOtherAmountVal" class="sliderValue">1.00x</span>
                </div>
              </div>
              <div id="reactOtherSources" class="audioReactSources"></div>
            </div>
          </div>
          <div class="audioReactMapActions">
            <button id="reactMapApplyBtn" type="button">APPLY REACT MAP</button>
            <button id="reactMapResetBtn" type="button">RESET REACT MAP</button>
            <input id="reactMapStatus" type="text" value="React map not loaded yet." readonly>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="cluster collapsible" data-collapsible-key="audioPipeline" data-collapsed-default-mobile="1">
    <div class="clusterHeaderRow">
      <h3>AUDIO PIPELINE</h3>
      <button type="button" class="collapseBtn" data-collapse-btn aria-expanded="true" title="Show or hide audio telemetry panels.">COLLAPSE</button>
    </div>
    <div class="clusterBody">
    <div class="telemetry">
      <div>LEVEL<br><span id="aLevel">0.00</span></div>
      <div>RAW<br><span id="aRaw">0.00</span></div>
      <div>PEAK<br><span id="aPeak">0.00</span></div>
  <div>TR<br><span id="aTransient">0.00</span></div>
  <div>ZCR<br><span id="aZcr">0.00</span></div>
  <div>B LOW<br><span id="aBandLow">0.00</span></div>
  <div>B MID<br><span id="aBandMid">0.00</span></div>
  <div>B HIGH<br><span id="aBandHigh">0.00</span></div>
  <div>FLUX<br><span id="aFlux">0.00</span></div>
  <div>AUTO GAIN<br><span id="aAutoGain">1.00</span></div>
  <div>EFF GAIN<br><span id="aEffectiveGain">1.00</span></div>
  <div>DEVICE<br><span id="aDevice">-</span></div>
  <div>RUNNING<br><span id="aRunning">NO</span></div>
  <div>RESTART<br><span id="aRestart">-</span></div>
  <div>ERROR<br><span id="aError">-</span></div>
    </div>
  </div>
</div>
</div>

<div id="midiTabPage" class="panel tabPage hidden" data-tab="midi">
  <div class="cluster">
    <h3>MIDI CONTROL <span class="infoTip" title="Map MIDI notes/CC controls to engine actions without editing code.">?</span></h3>
    <div class="audioGuide">
      <div class="audioGuideGrid">
        <div class="audioGuideCard">
          <strong>1) Detect device</strong>
          <span>Pick a <b>MIDI INPUT PORT</b>, then click <b>SAVE MIDI CFG</b>.</span>
        </div>
        <div class="audioGuideCard">
          <strong>2) Map controls</strong>
          <span>Use <b>ARM LEARN</b> and hit a key/knob, or fill manual binding fields.</span>
        </div>
        <div class="audioGuideCard">
          <strong>3) Test actions</strong>
          <span>Use <b>TRIGGER ACTION</b> to verify mapped engine behavior.</span>
        </div>
      </div>
    </div>

    <div class="subcluster">
      <h3>MIDI STATUS</h3>
      <div class="controlRow">
        <div>
          <label for="midiModuleStatus">MODULE</label>
          <input id="midiModuleStatus" type="text" value="checking..." readonly>
        </div>
        <div>
          <label for="midiRuntimeStatus">RUNTIME</label>
          <input id="midiRuntimeStatus" type="text" value="checking..." readonly>
        </div>
        <div>
          <label for="midiActivePort">ACTIVE PORT</label>
          <input id="midiActivePort" type="text" value="none" readonly>
        </div>
        <div>
          <label for="midiLearnStatus">LEARN MODE</label>
          <input id="midiLearnStatus" type="text" value="idle" readonly>
        </div>
      </div>
      <div class="controlRow">
        <div>
          <label for="midiLastEvent">LAST MIDI EVENT</label>
          <input id="midiLastEvent" type="text" value="none" readonly>
        </div>
        <div>
          <label for="midiLastAction">LAST ACTION</label>
          <input id="midiLastAction" type="text" value="none" readonly>
        </div>
        <div>
          <label for="midiEnabled">MIDI ENABLED</label>
          <select id="midiEnabled">
            <option value="true">enabled</option>
            <option value="false">disabled</option>
          </select>
        </div>
        <div>
          <label for="midiVelocityThreshold">DEFAULT MIN VALUE</label>
          <input id="midiVelocityThreshold" type="number" min="0" max="127" step="1" value="1">
        </div>
      </div>
      <div class="controlRow">
        <div>
          <label for="midiPortSelect">MIDI INPUT PORT</label>
          <select id="midiPortSelect"></select>
        </div>
        <div>
          <label for="midiDeviceMatch">DEVICE MATCH (OPTIONAL)</label>
          <input id="midiDeviceMatch" type="text" placeholder="partial port name">
        </div>
        <div class="grid2">
          <button id="midiRefreshBtn" type="button">REFRESH PORTS</button>
          <button id="midiSaveCfgBtn" type="button">SAVE MIDI CFG</button>
        </div>
      </div>
    </div>

    <div class="subcluster">
      <h3>LEARN + BINDINGS</h3>
      <div class="controlRow">
        <div>
          <label for="midiLearnAction">LEARN ACTION</label>
          <select id="midiLearnAction"></select>
        </div>
        <div class="grid3">
          <button id="midiLearnArmBtn" type="button">ARM LEARN</button>
          <button id="midiLearnCancelBtn" type="button">CANCEL LEARN</button>
          <button id="midiTriggerBtn" type="button">TRIGGER ACTION</button>
        </div>
      </div>

      <div class="controlRow">
        <div>
          <label for="midiBindingAction">BINDING ACTION</label>
          <select id="midiBindingAction"></select>
        </div>
        <div>
          <label for="midiBindingType">MESSAGE TYPE</label>
          <select id="midiBindingType">
            <option value="note">note</option>
            <option value="cc">cc</option>
          </select>
        </div>
        <div>
          <label for="midiBindingNumber">NUMBER</label>
          <input id="midiBindingNumber" type="number" min="0" max="127" step="1" value="36">
        </div>
        <div>
          <label for="midiBindingChannel">CHANNEL (blank = any)</label>
          <input id="midiBindingChannel" type="number" min="1" max="16" step="1" placeholder="any">
        </div>
      </div>
      <div class="controlRow">
        <div>
          <label for="midiBindingMinValue">MIN VALUE</label>
          <input id="midiBindingMinValue" type="number" min="0" max="127" step="1" value="1">
        </div>
        <div class="grid3">
          <button id="midiBindingSaveBtn" type="button">SAVE BINDING</button>
          <button id="midiBindingClearBtn" type="button" class="warn">CLEAR ACTION BINDING</button>
          <button id="midiBindingResetBtn" type="button" class="warn">RESET DEFAULT BINDINGS</button>
        </div>
      </div>

      <div>
        <label for="midiBindingsDump">BINDINGS SNAPSHOT</label>
        <textarea id="midiBindingsDump" readonly>no bindings loaded yet</textarea>
      </div>
      <p class="hint">
        Tip: if a control keeps re-triggering, raise <b>MIN VALUE</b> or use a button that sends 0 on release and 127 on press.
      </p>
    </div>
  </div>
</div>

<div class="panel tabPage" data-tab="custom">
  <div class="cluster">
    <h3>CUSTOM FIXTURE CONTROL</h3>
    <p class="hint">
      This tab is for per-device custom behavior driven by live audio metrics. <code>STATIC</code> mode keeps output fixed and only reacts to manual/apply + rave start/stop updates.
    </p>
      <div class="controlRow">
        <div>
          <label for="customFixtureSelect">SELECT CUSTOM FIXTURE (HUE + WiZ)</label>
          <select id="customFixtureSelect">
            <option value="">no custom fixture routed</option>
          </select>
        </div>
        <div class="grid2">
          <button id="customFixtureSyncBtn" type="button" title="Use selected custom fixture as the active routing target.">USE SELECTED FIXTURE</button>
        </div>
      </div>
  </div>
  <div id="customStandaloneMount"></div>
</div>

<div class="panel tabPage" data-tab="system">
  <div class="cluster collapsible" data-collapsible-key="systemSettings">
    <div class="clusterHeaderRow">
      <h3>SYSTEM SETTINGS</h3>
      <button type="button" class="collapseBtn" data-collapse-btn aria-expanded="true" title="Show or hide system-level runtime settings.">COLLAPSE</button>
    </div>
    <div class="clusterBody">
      <div class="controlRow">
        <div>
          <label for="systemStartTab">START TAB</label>
          <select id="systemStartTab">
            <option value="live">live</option>
            <option value="fixtures">fixtures</option>
            <option value="audio">audio</option>
            <option value="midi">midi</option>
            <option value="custom">custom</option>
            <option value="mods">mods</option>
            <option value="system">system</option>
          </select>
        </div>
        <div>
          <label for="systemConfirmActions">CONFIRM DANGEROUS ACTIONS</label>
          <select id="systemConfirmActions">
            <option value="true">enabled</option>
            <option value="false">disabled</option>
          </select>
        </div>
        <div>
          <label for="systemPollingMode">AUTO POLLING</label>
          <select id="systemPollingMode">
            <option value="live">live</option>
            <option value="paused">paused</option>
          </select>
        </div>
        <div>
          <label for="systemAutoLaunchBrowser">SERVER BROWSER AUTO-LAUNCH</label>
          <select id="systemAutoLaunchBrowser">
            <option value="true">enabled</option>
            <option value="false">disabled</option>
          </select>
        </div>
        <div>
          <label for="systemHueTransportPreference">HUE TRANSPORT DEFAULT</label>
          <select id="systemHueTransportPreference">
            <option value="auto">auto (entertainment preferred)</option>
            <option value="rest">rest only</option>
          </select>
        </div>
        <div>
          <label for="systemUnsafeSensitiveLogs">SERVER LOG REDACTION</label>
          <select id="systemUnsafeSensitiveLogs">
            <option value="false">redacted (safe default)</option>
            <option value="true">expose sensitive logs (DEV RISK)</option>
          </select>
        </div>
        <div class="grid2">
          <button id="systemSettingsSaveBtn" type="button">SAVE SYSTEM SETTINGS</button>
          <button id="systemSettingsResetBtn" type="button">RESET SYSTEM DEFAULTS</button>
        </div>
      </div>
      <div class="controlRow">
        <div>
          <label for="systemSettingsStatus">SETTINGS STATUS</label>
          <input id="systemSettingsStatus" type="text" value="SYSTEM SETTINGS READY" readonly>
        </div>
        <div class="grid2">
          <button id="systemPollNowBtn" type="button">POLL NOW</button>
          <button id="systemClearCacheBtn" type="button" class="warn">CLEAR UI CACHE</button>
        </div>
      </div>
      <div class="apiBaseRow">
        <div class="apiBaseInputWrap">
          <label for="apiBaseInput">API BASE (optional)</label>
          <input id="apiBaseInput" type="text" placeholder="http://127.0.0.1:5050" />
        </div>
        <button id="apiBaseSaveBtn" type="button" title="Save a custom API endpoint when this UI and bridge are on different hosts.">SAVE API BASE</button>
        <button id="apiBaseResetBtn" type="button" title="Reset API BASE to this page origin.">USE DEFAULT</button>
      </div>
      <p class="hint">System settings include browser-local controls plus server browser auto-launch behavior.</p>
      <p class="hint">Set <code>HUE TRANSPORT DEFAULT</code> to <code>rest only</code> if you want to avoid Entertainment mode auto-switching.</p>
      <p class="hint">Danger: disabling log redaction can expose usernames, client keys, bridge IDs, area IDs, bearer tokens, and network addresses in plain text logs.</p>
      <p class="hint">Use API BASE if this UI runs on a different host than the bridge server.</p>
    </div>
  </div>

  <div id="standCustomCluster" class="cluster hidden">
    <h3>CUSTOM DEVICE CONTROL</h3>
    <p class="hint">Visible when <code>ROUTE CUSTOM</code> is enabled for the selected fixture. Use scene + ranges for animation, or toggle <code>STATIC</code> to hold one frame. <code>CCT</code> can still animate and follow audio speed when <code>STATIC</code> is off.</p>
    <div class="controlRow">
      <div>
        <label for="standPower">POWER</label>
        <select id="standPower">
          <option value="true">on</option>
          <option value="false">off</option>
        </select>
      </div>
      <div>
        <label for="standMode">MODE</label>
        <select id="standMode">
          <option value="rgb">RGB STATIC</option>
          <option value="scene">SCENE CYCLE</option>
          <option value="auto">AUTO HZ</option>
        </select>
      </div>
      <div>
        <label for="standSpeedHz">SPEED HZ</label>
        <input id="standSpeedHz" type="number" min="0.2" max="12" step="0.1" value="1.2">
      </div>
      <div>
        <label for="standTransitionMs">TRANSITION MS</label>
        <input id="standTransitionMs" type="number" min="0" max="10000" step="10" value="350">
      </div>
    </div>
    <div class="controlRow">
      <div>
        <label for="standScene">SCENE</label>
        <select id="standScene">
          <option value="sweep">SWEEP</option>
          <option value="bounce">BOUNCE</option>
          <option value="pulse">PULSE</option>
          <option value="spark">SPARK</option>
        </select>
      </div>
      <div>
        <label for="standSpeedMode">SPEED SOURCE</label>
        <select id="standSpeedMode">
          <option value="fixed">FIXED HZ</option>
          <option value="audio">AUDIO REACTIVE HZ</option>
        </select>
      </div>
      <div>
        <label for="standSpeedMinHz">AUDIO MIN HZ <span id="standSpeedMinHzVal">0.6</span></label>
        <input id="standSpeedMinHz" type="range" min="0.2" max="12" step="0.1" value="0.6">
      </div>
      <div>
        <label for="standSpeedMaxHz">AUDIO MAX HZ <span id="standSpeedMaxHzVal">3.2</span></label>
        <input id="standSpeedMaxHz" type="range" min="0.2" max="12" step="0.1" value="3.2">
      </div>
    </div>
    <div class="controlRow">
      <div>
        <label for="standColorMode">COLOR MODE</label>
        <select id="standColorMode">
          <option value="hsv">HSV RANGE</option>
          <option value="cct">CCT (WiZ + HUE CT)</option>
        </select>
      </div>
      <div class="grid3">
        <button id="standStaticBtn" type="button" data-on="false" aria-pressed="false">STATIC OFF</button>
        <button id="standRaveStartBtn" type="button" data-on="false" aria-pressed="false">RAVE-START UPDATE OFF</button>
        <button id="standRaveStopBtn" type="button" data-on="false" aria-pressed="false">RAVE-END UPDATE OFF</button>
      </div>
      <div class="grid2">
        <button id="standApplyBtn" type="button">APPLY TO DEVICE</button>
      </div>
      <div>
        <label for="standStatus">CUSTOM STATUS</label>
        <input id="standStatus" type="text" value="No custom fixture selected." readonly>
      </div>
    </div>
    <div class="controlRow">
      <div>
        <label for="standBrightness">BRIGHTNESS % <span id="standBrightnessVal">70</span></label>
        <input id="standBrightness" type="range" min="1" max="100" value="70">
      </div>
      <div id="standHsvSingleWrap">
        <label for="standHue">HUE <span id="standHueVal">210</span></label>
        <input id="standHue" type="range" min="0" max="359" value="210">
      </div>
      <div>
        <label for="standSat">SAT % <span id="standSatVal">80</span></label>
        <input id="standSat" type="range" min="0" max="100" value="80">
      </div>
      <div>
        <label for="standCctKelvin">CCT K <span id="standCctKelvinVal">4000</span></label>
        <input id="standCctKelvin" type="range" min="2200" max="6500" step="50" value="4000">
      </div>
    </div>
    <div class="controlRow">
      <div>
        <label for="standRaveStopBrightness">RAVE-END BRIGHTNESS % <span id="standRaveStopBrightnessVal">100</span></label>
        <input id="standRaveStopBrightness" type="range" min="1" max="100" value="100">
      </div>
    </div>
    <div id="standHsvRangeRow" class="controlRow">
      <div>
        <label for="standHueMin">HUE MIN <span id="standHueMinVal">0</span></label>
        <input id="standHueMin" type="range" min="0" max="359" value="0">
      </div>
      <div>
        <label for="standHueMax">HUE MAX <span id="standHueMaxVal">359</span></label>
        <input id="standHueMax" type="range" min="0" max="359" value="359">
      </div>
      <div>
        <label for="standSatMin">SAT MIN % <span id="standSatMinVal">45</span></label>
        <input id="standSatMin" type="range" min="0" max="100" value="45">
      </div>
      <div>
        <label for="standSatMax">SAT MAX % <span id="standSatMaxVal">100</span></label>
        <input id="standSatMax" type="range" min="0" max="100" value="100">
      </div>
    </div>
    <div id="standCctRangeRow" class="controlRow hidden">
      <div>
        <label for="standCctMinKelvin">CCT MIN K <span id="standCctMinKelvinVal">2700</span></label>
        <input id="standCctMinKelvin" type="range" min="2200" max="6500" step="50" value="2700">
      </div>
      <div>
        <label for="standCctMaxKelvin">CCT MAX K <span id="standCctMaxKelvinVal">6500</span></label>
        <input id="standCctMaxKelvin" type="range" min="2200" max="6500" step="50" value="6500">
      </div>
    </div>
    <input id="standAnimate" type="hidden" value="false">
  </div>

  <div class="cluster">
    <h3>FIXTURE TOPOLOGY</h3>
    <div class="telemetry">
      <div>HUE<br><span id="fixHue">0</span></div>
      <div>WIZ<br><span id="fixWiz">0</span></div>
      <div>HUE READY<br><span id="fixHueReady">0</span></div>
      <div>WIZ READY<br><span id="fixWizReady">0</span></div>
      <div>R:HUE<br><span id="routeHue">-</span></div>
      <div>R:WIZ<br><span id="routeWiz">-</span></div>
      <div>R:T-HUE<br><span id="routeTwitchHue">-</span></div>
      <div>R:T-WIZ<br><span id="routeTwitchWiz">-</span></div>
      <div>CFG VER<br><span id="cfgVer">0</span></div>
      <div>CFG AT<br><span id="cfgAt">-</span></div>
      <div>LOCK<br><span id="sceneLockStat">AUTO</span></div>
      <div>POLL(ms)<br><span id="pollMs">220</span></div>
    </div>
  </div>

  <div class="cluster collapsible" data-collapsible-key="engineUtilities" data-collapsed-default="1">
    <div class="clusterHeaderRow">
      <h3>ENGINE UTILITIES</h3>
      <button type="button" class="collapseBtn" data-collapse-btn aria-expanded="true" title="Show or hide advanced utility controls.">COLLAPSE</button>
    </div>
    <div class="clusterBody">
      <div class="grid3">
        <button id="reloadBtn" type="button" class="warn" title="Reload server runtime modules without closing the app window.">HOT RELOAD</button>
        <button id="dropBtn" type="button" class="warn" title="Trigger one manual drop hit event for testing visuals.">DROP HIT</button>
        <button id="hueEntBtn" type="button" title="Force Hue transport to Entertainment mode.">HUE ENTERTAINMENT</button>
        <button id="hueRestBtn" type="button" title="Force Hue transport to REST mode.">HUE REST</button>
        <button id="serverStopBtn" type="button" class="bad" title="Gracefully stop the local bridge process from the browser UI.">STOP SERVER (UI)</button>
      </div>
      <p class="hint">Rave mode auto-switches Hue transport. These controls are for diagnostics. MIDI mapping is managed in the MIDI tab.</p>
      <p class="hint">Browser security cannot run local .bat files directly. Use this UI stop button or <code>RaveLink-Bridge-Stop.bat</code>.</p>
    </div>
  </div>

  <div class="cluster collapsible" data-collapsible-key="automationRules" data-collapsed-default="1">
    <div class="clusterHeaderRow">
      <h3>NO-CODE AUTOMATION RULES</h3>
      <button type="button" class="collapseBtn" data-collapse-btn aria-expanded="true" title="Show or hide automation rule editor.">COLLAPSE</button>
    </div>
    <div class="clusterBody">
    <div class="controlRow">
      <div>
        <label for="autoRulesEnabled">AUTOMATION</label>
        <select id="autoRulesEnabled">
          <option value="true">enabled</option>
          <option value="false">disabled</option>
        </select>
      </div>
      <div>
        <label for="autoRulesTargetZone">TARGET ZONE</label>
        <select id="autoRulesTargetZone">
          <option value="all">all hue fixtures</option>
        </select>
      </div>
      <div>
        <label for="autoRulesTransitionMs">TRANSITION MS</label>
        <input id="autoRulesTransitionMs" type="number" min="0" max="10000" step="50" value="400" />
      </div>
    </div>

    <div class="controlRow">
      <div>
        <label for="autoStartEnabled">ON ENGINE START</label>
        <select id="autoStartEnabled">
          <option value="true">run</option>
          <option value="false">skip</option>
        </select>
      </div>
      <div>
        <label for="autoStartPercent">START BRIGHTNESS % <span id="autoStartPercentVal">80%</span></label>
        <input id="autoStartPercent" type="range" min="1" max="100" value="80" />
      </div>
      <div>
        <label for="autoStartDelayMs">START DELAY MS</label>
        <input id="autoStartDelayMs" type="number" min="0" max="60000" step="100" value="0" />
      </div>
    </div>

    <div class="controlRow">
      <div>
        <label for="autoStopEnabled">ON ENGINE STOP</label>
        <select id="autoStopEnabled">
          <option value="true">run</option>
          <option value="false">skip</option>
        </select>
      </div>
      <div>
        <label for="autoStopPercent">STOP BRIGHTNESS % <span id="autoStopPercentVal">100%</span></label>
        <input id="autoStopPercent" type="range" min="1" max="100" value="100" />
      </div>
      <div>
        <label for="autoStopDelayMs">STOP DELAY MS</label>
        <input id="autoStopDelayMs" type="number" min="0" max="60000" step="100" value="0" />
      </div>
    </div>

    <div class="grid4">
      <button id="autoRulesSaveBtn" type="button" class="warn">SAVE RULES</button>
      <button id="autoRulesReloadBtn" type="button">RELOAD RULES</button>
      <button id="autoRulesTestStartBtn" type="button">TEST START ACTION</button>
      <button id="autoRulesTestStopBtn" type="button">TEST STOP ACTION</button>
    </div>

    <p class="hint">
      Rules run automatically on <code>/rave/on</code> and <code>/rave/off</code>. Every save writes a backup in
      <code>core/backups/automation</code>.
    </p>

    <div class="telemetry">
      <div>AUTO<br><span id="autoRulesState">-</span></div>
      <div>ZONE<br><span id="autoRulesZone">-</span></div>
      <div>TRANS<br><span id="autoRulesTransition">-</span></div>
      <div>START<br><span id="autoRulesStart">-</span></div>
      <div>STOP<br><span id="autoRulesStop">-</span></div>
      <div>CFG VER<br><span id="autoRulesVersion">0</span></div>
      <div>LOADED<br><span id="autoRulesLoadedAt">-</span></div>
      <div>LAST BACKUP<br><span id="autoRulesBackup">-</span></div>
    </div>
    </div>
  </div>
</div>

<div id="modUiPanel" class="panel tabPage" data-tab="mods">
  <div class="cluster collapsible" id="modCenter" data-collapsible-key="modCenter" data-collapsed-default="1">
    <div class="clusterHeaderRow">
      <h3>MOD CENTER</h3>
      <div class="clusterHeaderActions">
        <button id="moddingReadmeBtn" type="button" class="modReadmeBtn" title="Open developer modding docs in a separate page.">MODDING README</button>
        <button type="button" class="collapseBtn" data-collapse-btn aria-expanded="true" title="Show or hide mod controls.">COLLAPSE</button>
      </div>
    </div>
    <div class="clusterBody">
      <p class="hint">
        Add mod folders under <code>mods/</code> (each with <code>mod.json</code>), then use <b>RELOAD MODS</b>.
      </p>
      <p class="hint">
        <code>0/2 loaded</code> is normal in a fresh distro when mods exist but are disabled in <code>mods/mods.config.json</code>.
      </p>
      <div id="modDropZone" class="modDropZone">
        <div class="controlRow">
          <div>
            <label>DRAG + DROP MOD IMPORT</label>
            <input id="modImportStatus" type="text" value="Drop a mod folder here, or browse and pick a folder." readonly>
          </div>
          <div class="grid2">
            <button id="modImportBrowseBtn" type="button">BROWSE FOLDER</button>
          </div>
        </div>
        <div class="controlRow">
          <div>
            <label style="font-size:11px;">
              <input id="modImportOverwrite" type="checkbox">
              overwrite existing mod with same id
            </label>
          </div>
          <div>
            <label style="font-size:11px;">
              <input id="modImportEnable" type="checkbox" checked>
              auto-enable + hotswap after import
            </label>
          </div>
        </div>
        <p class="hint">Folder must include <code>mod.json</code>. Supports drag/drop directly from Explorer.</p>
        <input id="modImportPicker" type="file" webkitdirectory directory multiple class="hidden">
      </div>
      <div class="controlRow">
        <div>
          <label>MOD STATUS</label>
          <input id="modsStatus" type="text" value="No mod data loaded yet." readonly>
        </div>
        <div class="grid2">
          <button id="modsRefreshBtn" type="button" title="Fetch mod status from server without reloading modules.">REFRESH MODS</button>
          <button id="modsReloadBtn" type="button" class="warn" title="Reload mods.config.json and re-instantiate enabled mods.">RELOAD MODS</button>
        </div>
      </div>
      <div class="controlRow">
        <div>
          <label>MOD DEBUG LOGS</label>
          <input id="modsDebugStatus" type="text" value="MOD DEBUG OFF" readonly>
        </div>
        <div class="grid2">
          <button id="modsDebugToggleBtn" type="button" title="Enable or disable verbose [MODS][DBG] console logs.">MOD DEBUG OFF</button>
          <button id="modsDebugClearBtn" type="button" title="Clear in-memory mod debug history buffer.">CLEAR DEBUG BUFFER</button>
        </div>
      </div>
      <p class="hint">Average-user mode keeps mod debug logs off. Turn this on only while troubleshooting.</p>
      <div class="controlRow">
        <div>
          <label for="modEnableId">MOD ID</label>
          <input id="modEnableId" type="text" placeholder="quiet-hours-mod">
          <label for="modHotswapStatus">HOTSWAP STATUS</label>
          <input id="modHotswapStatus" type="text" value="No pending mod changes." readonly>
        </div>
        <div class="grid4">
          <button id="modEnableBtn" type="button" title="Queue this mod to enable. Changes are not live until APPLY HOTSWAP.">QUEUE ENABLE</button>
          <button id="modDisableBtn" type="button" title="Queue this mod to disable. Changes are not live until APPLY HOTSWAP.">QUEUE DISABLE</button>
          <button id="modApplyBtn" type="button" class="warn" title="Apply all queued mod enable/disable changes live.">APPLY HOTSWAP</button>
          <button id="modDiscardBtn" type="button" title="Discard queued changes and keep current loaded mods.">DISCARD CHANGES</button>
        </div>
      </div>
      <p class="hint">Queue one or more mod enable/disable changes, then press <b>APPLY HOTSWAP</b> to load/unload without restarting the bridge.</p>
      <p class="hint">Hover a mod ID to see its summary from <code>mod-info.txt</code>/<code>README.md</code> or <code>mod.json description</code>.</p>

      <div class="tableWrap">
        <table>
          <thead>
            <tr>
              <th>ID</th>
              <th>VERSION</th>
              <th>ENABLED</th>
              <th>PENDING</th>
              <th>LOADED</th>
              <th>HOOKS</th>
              <th>ERROR</th>
            </tr>
          </thead>
          <tbody id="modsRows"></tbody>
        </table>
      </div>

      <div class="subcluster">
        <h3>RUN MOD ACTION</h3>
        <div class="controlRow">
          <div>
            <label for="modActionModId">MOD ID</label>
            <input id="modActionModId" type="text" placeholder="hello-mod">
          </div>
          <div>
            <label for="modActionName">ACTION</label>
            <input id="modActionName" type="text" placeholder="status">
          </div>
          <div>
            <label for="modActionMethod">METHOD</label>
            <select id="modActionMethod">
              <option value="GET">GET</option>
              <option value="POST">POST</option>
            </select>
          </div>
          <div class="grid2">
            <button id="modActionRunBtn" type="button" title="Call /mods/:modId/:action using selected method.">RUN ACTION</button>
          </div>
        </div>
        <textarea id="modActionOutput" readonly>Waiting for mod action...</textarea>
        <p class="hint">Action calls use /mods/:modId/:action routes. Leave action blank to call /mods/:modId.</p>
      </div>
    </div>
  </div>

  <div class="cluster">
    <h3>MOD UI WORKBENCH</h3>
    <p class="hint">Enabled mods with packaged UI create their own top tabs automatically. This workbench lets you inspect and manually reload/open those UIs.</p>
    <p class="hint">Mod UI asset route pattern: <code>/mods-ui/&lt;mod-id&gt;/</code> (catalog at <code>/mods/ui/catalog</code>).</p>

    <div class="modUiToolbar">
      <div>
        <label for="modUiSelect">MOD UI</label>
        <select id="modUiSelect">
          <option value="">no loaded mod UI</option>
        </select>
      </div>
      <button id="modUiRefreshBtn" type="button" title="Refresh mod UI catalog from /mods/ui/catalog.">REFRESH UIs</button>
      <button id="modUiReloadBtn" type="button" title="Reload selected mod UI frame without reloading mod runtime.">RELOAD FRAME</button>
    </div>

    <div class="controlRow">
      <div>
        <label for="modUiStatus">MOD UI STATUS</label>
        <input id="modUiStatus" type="text" value="Waiting for mod UI catalog..." readonly>
      </div>
      <div class="grid2">
        <button id="modUiOpenBtn" type="button" title="Open selected mod UI in a separate browser tab.">OPEN IN NEW TAB</button>
      </div>
    </div>

    <div id="modUiEmpty" class="modUiEmpty">
      No loaded mods expose UI assets yet. Add <code>ui/index.html</code> (or a <code>ui</code> entry in <code>mod.json</code>), then enable the mod and apply hotswap.
    </div>
    <div id="modUiFrameWrap" class="modUiFrameWrap hidden">
      <iframe
        id="modUiFrame"
        title="Mod UI host frame"
        sandbox="allow-same-origin allow-scripts allow-forms allow-popups"
      ></iframe>
    </div>
  </div>
</div>

<script>
// [TITLE] UI Functionality Index:
// [TITLE] - Theme + Layout State
// [TITLE] - Engine Controls + Telemetry Polling
// [TITLE] - Fixture Catalog + Routing Editor
// [TITLE] - Custom/Standalone Fixture Control
// [TITLE] - Audio Config + Per-Brand Reactivity Map
// [TITLE] - Hue Bridge Pairing + Entertainment Area Setup
// [TITLE] - Twitch/Color Routing + Prefixes
// [TITLE] - Mods Dashboard + Embedded Mod UI
const THEME_STORAGE_KEY = "ravelink_ui_theme_v1";
const OBS_DOCK_COMPACT_KEY = "ravelink_obs_dock_compact_v1";
const PALETTE_FIXTURE_SELECTION_KEY = "ravelink_palette_fixture_selection_v1";
const DEFAULT_THEME_NAME = "midnight";

const THEME_PRESETS = {
  midnight: {
    bg: "#050507",
    panel: "#0b0e18",
    panel2: "#121a2f",
    accent: "#8b001f",
    edge: "#233055",
    btnBg: "#14182c",
    text: "#eaeaea"
  },
  ember: {
    bg: "#120807",
    panel: "#1a0f10",
    panel2: "#2a1617",
    accent: "#d84a1c",
    edge: "#5d2b2c",
    btnBg: "#2b1a18",
    text: "#f2e6dd"
  },
  ocean: {
    bg: "#050c13",
    panel: "#081823",
    panel2: "#0e2434",
    accent: "#00a7c4",
    edge: "#1d4d66",
    btnBg: "#132436",
    text: "#e1effa"
  },
  matrix: {
    bg: "#020807",
    panel: "#061211",
    panel2: "#0b1f1d",
    accent: "#00cf72",
    edge: "#1b4d3c",
    btnBg: "#102120",
    text: "#d9f7e7"
  }
};

function parseDockFlag(rawValue) {
  const raw = String(rawValue || "").trim().toLowerCase();
  return raw === "1" || raw === "true" || raw === "yes" || raw === "on";
}

const dockSearchParams = new URLSearchParams(location.search || "");
const detectedObsDockMode =
  parseDockFlag(dockSearchParams.get("obsdock")) ||
  parseDockFlag(dockSearchParams.get("obsDock")) ||
  parseDockFlag(dockSearchParams.get("dock")) ||
  /obsbrowser|obs studio|obs\//i.test(String(navigator.userAgent || ""));
const detectedObsDockCompact = detectedObsDockMode
  ? (dockSearchParams.has("compact")
    ? parseDockFlag(dockSearchParams.get("compact"))
    : localStorage.getItem(OBS_DOCK_COMPACT_KEY) !== "0")
  : false;

function readPaletteFixtureSelectionBootstrap() {
  const fallback = { hue: "__all__", wiz: "__all__" };
  try {
    const raw = String(localStorage.getItem(PALETTE_FIXTURE_SELECTION_KEY) || "").trim();
    if (!raw) return { ...fallback };
    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== "object") return { ...fallback };
    return {
      hue: String(parsed.hue || "__all__").trim() || "__all__",
      wiz: String(parsed.wiz || "__all__").trim() || "__all__"
    };
  } catch {
    return { ...fallback };
  }
}

const ui = {
  raveOn: false,
  mode: "interpret",
  modeLock: "interpret",
  autoProfile: "balanced",
  audioReactivityPreset: "balanced",
  audioQuickProfile: "balanced",
  flowIntensity: 1,
  wizSceneSync: true,
  sceneSyncStrategy: "linked",
  sceneSyncActiveBrands: [],
  flowIntensityInputUntil: 0,
  metaAutoEnabled: false,
  metaAutoReason: "off",
  metaAutoGenre: "auto",
  metaAutoHz: 2,
  metaAutoHueWizBaselineBlend: true,
  metaAutoTempoTrackersAuto: false,
  metaAutoTempoTrackers: {
    baseline: true,
    peaks: false,
    transients: false,
    flux: false
  },
  metaAutoTempoTrackersActive: {
    baseline: true,
    peaks: false,
    transients: false,
    flux: false
  },
  overclockAutoEnabled: false,
  overclockAutoReason: "off",
  overclockAutoHz: 2,
  limiterPreset: "balanced",
  activeTab: "live",
  paletteColorsPerFamily: 3,
  paletteFamilies: ["red", "green", "blue"],
  paletteDisorder: false,
  paletteDisorderAggression: 0.35,
  paletteCycleMode: "on_trigger",
  paletteTimedIntervalSec: 5,
  paletteBeatLock: false,
  paletteBeatLockGraceSec: 2,
  paletteReactiveMargin: 28,
  paletteBrightnessMode: "legacy",
  paletteBrightnessFollowAmount: 1,
  paletteVividness: 2,
  paletteSpectrumMapMode: "auto",
  paletteSpectrumFeatureMap: ["lows", "mids", "highs", "rms", "flux"],
  paletteBrandOverrides: { hue: null, wiz: null },
  paletteFixtureOverrides: {},
  paletteControlScope: "global",
  paletteCustomBrand: "hue",
  paletteGlobalModeNotice: "",
  paletteBrandModeNotices: { hue: "", wiz: "" },
  fixtureMetricConfig: { mode: "manual", metric: "baseline", metaAutoFlip: false, harmonySize: 1, maxHz: null },
  fixtureMetricBrandOverrides: { hue: null, wiz: null },
  fixtureMetricFixtureOverrides: {},
  paletteBrandFixtures: { hue: [], wiz: [] },
  paletteFixtureSelectionByBrand: readPaletteFixtureSelectionBootstrap(),
  overclock: true,
  overclockLevel: 2,
  devDebugMode: localStorage.getItem("ravelink_dev_debug_v1") === "1",
  sceneLock: "auto",
  visualMaster: 1,
  dropIntensity: 1,
  audioReactivityMapLoaded: false,
  audioReactivityMapDirty: false,
  audioReactivityMap: null,
  lastRaveTelemetry: null,
  lastAudioTelemetry: null,
  smartMatchFingerprint: "",
  smartMatchNextRetuneAt: 0,
  reactSmartMatchEnabled: localStorage.getItem("ravelink_react_smart_match_v1") !== "0",
  reactForceLockEnabled: localStorage.getItem("ravelink_react_force_lock_v1") === "1",
  reactForceMatchOverride: localStorage.getItem("ravelink_react_force_override_v1") === "1",
  pollErrors: 0,
  audioConfigLoaded: false,
  audioAppsLoaded: false,
  audioRunningApps: [],
  audioRunningAppsHinted: [],
  audioAppHintMeta: null,
  audioAudioCapableTokens: [],
  audioAppsShowAll: localStorage.getItem("ravelink_audio_apps_show_all_v1") === "1",
  audioSimpleRoutingMode: localStorage.getItem("ravelink_audio_simple_mode_v1") !== "0",
  audioOptionalToolsStatus: null,
  audioOptionalToolsDismissed: localStorage.getItem("ravelink_audio_optional_tools_dismissed_v1") === "1",
  midiConfigLoaded: false,
  midiDetected: false,
  midiActions: [],
  midiSnapshot: null,
  midiTabForced: localStorage.getItem("ravelink_midi_tab_forced_v1") === "1",
  automationConfigLoaded: false,
  modsLoadedAt: 0,
  modsTotal: 0,
  modsActive: 0,
  modsDebugEnabled: false,
  modsDebugLoaded: false,
  modUiCatalog: [],
  modUiSelectedId: localStorage.getItem("ravelink_mod_ui_selected_v1") || "",
  modUiLastId: "",
  modUiLastUrl: "",
  modUiLoadedAt: 0,
  modsSnapshot: null,
  modsRuntimeConfig: { enabled: [], order: [], disabled: [] },
  modsDraftConfig: { enabled: [], order: [], disabled: [] },
  modsDraftDirty: false,
  fixtureModBrands: [],
  fixturesCatalog: [],
  fixturesSnapshotLoaded: false,
  standaloneFixtures: [],
  standaloneSelectedId: "",
  standaloneModeByFixture: {},
  standaloneDraftDirty: false,
  standaloneDraftFixtureId: "",
  standaloneDraftTouchedAt: 0,
  lastBpm: 0,
  routeDraftDirty: false,
  routeDraftFixtureId: "",
  routeDraftFlags: null,
  routeLastSavedAt: 0,
  engineReadyTargets: 0,
  engineModeTargets: 0,
  fixtureConnectivityById: {},
  connectivitySummary: null,
  onboardingAcknowledged: false,
  hueEntGuideAcknowledged: false,
  colorPrefixConfigLoaded: false,
  colorPrefixOtherEnabled: false,
  colorPrefixDefaultTarget: "both",
  colorPrefixes: { hue: "hue", wiz: "wiz", other: "" },
  colorFixturePrefixes: {},
  colorRaveOffEnabled: true,
  colorRaveOffDefaultText: "random",
  colorRaveOffGroups: {},
  colorRaveOffFixtures: {},
  guidedOnboardingStatus: "",
  guidedOnboardingActive: false,
  guidedOnboardingStep: 0,
  obsDockMode: detectedObsDockMode,
  obsDockCompact: detectedObsDockCompact,
  startTabPreference: String(localStorage.getItem("ravelink_ui_start_tab_v1") || "live").trim().toLowerCase(),
  confirmDangerousActions: localStorage.getItem("ravelink_ui_confirm_danger_v1") !== "0",
  pollPaused: localStorage.getItem("ravelink_ui_poll_paused_v1") === "1",
  serverAutoLaunchBrowser: true,
  serverHueTransportPreference: "auto",
  serverUnsafeSensitiveLogs: false,
  serverUnsafeSensitiveLogsBaseline: false,
  themeName: DEFAULT_THEME_NAME,
  themeConfig: { ...THEME_PRESETS[DEFAULT_THEME_NAME] }
};

const pollIntervalMs = 220;
let pollTick = 0;

const inferredApiBase = (() => {
  if (location.protocol === "file:") return "http://127.0.0.1:5050";
  const isHttp = location.protocol === "http:" || location.protocol === "https:";
  if (isHttp && location.port === "5050") return "";
  if (isHttp) {
    return `${location.protocol}//${location.hostname}:5050`;
  }
  return "";
})();

let apiBase = normalizeApiBaseInput(localStorage.getItem("rave_api_base") || inferredApiBase);
function normalizeUiRelativePath(rawPath) {
  const raw = String(rawPath || "").trim();
  if (!raw) return "/";
  if (raw.startsWith("//")) return "/";
  if (/^[a-z][a-z0-9+.-]*:/i.test(raw)) return "/";
  return raw.startsWith("/") ? raw : `/${raw}`;
}

const withBase = path => {
  const safePath = normalizeUiRelativePath(path);
  return apiBase ? `${apiBase}${safePath}` : safePath;
};
const DEV_DEBUG_KEY = "ravelink_dev_debug_v1";
const DEV_DEBUG_WARN_ONCE_KEY = "ravelink_dev_debug_warn_once_v1";
const DEV_OVERCLOCK_COMICAL_ACK_KEY = "ravelink_dev_overclock_comical_ack_v1";
const MOD_UI_SELECTED_KEY = "ravelink_mod_ui_selected_v1";
const ONBOARD_ACK_KEY = "ravelink_onboard_ack_v1";
const HUE_ENT_GUIDE_ACK_KEY = "ravelink_hue_ent_guide_ack_v1";
const GUIDED_ONBOARDING_STATE_KEY = "ravelink_guided_onboarding_v1";
const UI_STORAGE_MIGRATION_KEY = "ravelink_ui_storage_migration_v1";
const UI_STORAGE_MIGRATION_TARGET = "2026-02-19-v1.5-repack-pass-2";
const UI_START_TAB_KEY = "ravelink_ui_start_tab_v1";
const UI_CONFIRM_DANGER_KEY = "ravelink_ui_confirm_danger_v1";
const UI_POLL_PAUSED_KEY = "ravelink_ui_poll_paused_v1";
const AUDIO_REACT_SMART_MATCH_KEY = "ravelink_react_smart_match_v1";
const AUDIO_REACT_FORCE_LOCK_KEY = "ravelink_react_force_lock_v1";
const AUDIO_REACT_FORCE_OVERRIDE_KEY = "ravelink_react_force_override_v1";
const MIDI_TAB_FORCE_KEY = "ravelink_midi_tab_forced_v1";
const AUDIO_APPS_SHOW_ALL_KEY = "ravelink_audio_apps_show_all_v1";
const AUDIO_SIMPLE_MODE_KEY = "ravelink_audio_simple_mode_v1";
const AUDIO_OPTIONAL_TOOLS_DISMISS_KEY = "ravelink_audio_optional_tools_dismissed_v1";
const LIVE_PROFILE_STORE_KEY = "ravelink_live_profiles_v1";
const LIVE_PROFILE_LAST_KEY = "ravelink_live_profile_last_v1";
const DEV_OVERCLOCK_COMICAL_TEXT = "I AM REALLY REALLY REALLY REALLY REALLY REALLY REALLY SURE";
const UNSAFE_LOG_ACK_PHRASE = "I_UNDERSTAND_SENSITIVE_LOG_RISK";
const UI_STORAGE_RESET_KEYS = Object.freeze([
  "rave_api_base",
  THEME_STORAGE_KEY,
  DEV_DEBUG_KEY,
  DEV_DEBUG_WARN_ONCE_KEY,
  DEV_OVERCLOCK_COMICAL_ACK_KEY,
  MOD_UI_SELECTED_KEY,
  ONBOARD_ACK_KEY,
  HUE_ENT_GUIDE_ACK_KEY,
  GUIDED_ONBOARDING_STATE_KEY,
  UI_STORAGE_MIGRATION_KEY,
  OBS_DOCK_COMPACT_KEY,
  UI_START_TAB_KEY,
  UI_CONFIRM_DANGER_KEY,
  UI_POLL_PAUSED_KEY,
  AUDIO_REACT_SMART_MATCH_KEY,
  AUDIO_REACT_FORCE_LOCK_KEY,
  AUDIO_REACT_FORCE_OVERRIDE_KEY,
  MIDI_TAB_FORCE_KEY,
  AUDIO_APPS_SHOW_ALL_KEY,
  AUDIO_SIMPLE_MODE_KEY,
  AUDIO_OPTIONAL_TOOLS_DISMISS_KEY,
  LIVE_PROFILE_STORE_KEY,
  LIVE_PROFILE_LAST_KEY,
  PALETTE_FIXTURE_SELECTION_KEY
]);
const UI_STORAGE_RESET_PREFIXES = Object.freeze([
  "ravelink_ui_collapsed_",
  "ravelink_ui_theme_",
  "ravelink_guided_"
]);
let hueEntGuideAckResolver = null;
let hueEntGuideAckPromise = null;
let guidedTourFocusEl = null;
let guidedTourAutoStartTimer = null;
let devOcAckResolver = null;
let devOcAckKeydownHandler = null;

ui.devDebugWarned = localStorage.getItem(DEV_DEBUG_WARN_ONCE_KEY) === "1";
ui.devOverclockComicalAcked = localStorage.getItem(DEV_OVERCLOCK_COMICAL_ACK_KEY) === "1";

function removeStorageKeys(storage, keys = []) {
  if (!storage || typeof storage.removeItem !== "function") return;
  for (const key of keys) {
    try {
      storage.removeItem(String(key || ""));
    } catch {}
  }
}

function removeStoragePrefixKeys(storage, prefixes = []) {
  if (!storage || typeof storage.key !== "function" || typeof storage.removeItem !== "function") return;
  for (let i = Number(storage.length || 0) - 1; i >= 0; i -= 1) {
    const key = String(storage.key(i) || "");
    if (!key) continue;
    if (prefixes.some(prefix => key.startsWith(prefix))) {
      try {
        storage.removeItem(key);
      } catch {}
    }
  }
}

async function clearBrowserCacheStorage() {
  if (typeof window === "undefined" || !window.caches || typeof window.caches.keys !== "function") return;
  try {
    const cacheNames = await window.caches.keys();
    await Promise.all(
      cacheNames.map(name => window.caches.delete(name).catch(() => false))
    );
  } catch {}
}

async function wipeUiBrowserMemory(options = {}) {
  const opts = options && typeof options === "object" ? options : {};
  const includeCacheStorage = opts.includeCacheStorage === true;
  removeStorageKeys(localStorage, UI_STORAGE_RESET_KEYS);
  removeStoragePrefixKeys(localStorage, UI_STORAGE_RESET_PREFIXES);
  removeStorageKeys(sessionStorage, UI_STORAGE_RESET_KEYS);
  removeStoragePrefixKeys(sessionStorage, UI_STORAGE_RESET_PREFIXES);
  if (includeCacheStorage) {
    await clearBrowserCacheStorage();
  }
}

async function applyUiStorageMigration() {
  const applied = String(localStorage.getItem(UI_STORAGE_MIGRATION_KEY) || "").trim();
  if (applied === UI_STORAGE_MIGRATION_TARGET) return;

  // Ensure this release starts with a clean UI cache/state baseline.
  await wipeUiBrowserMemory({ includeCacheStorage: false });
  localStorage.setItem(UI_STORAGE_MIGRATION_KEY, UI_STORAGE_MIGRATION_TARGET);
}

applyUiStorageMigration().catch(() => {});

const el = {
  onBtn: document.getElementById("onBtn"),
  offBtn: document.getElementById("offBtn"),
  panicBtn: document.getElementById("panicBtn"),
  liveProfileName: document.getElementById("liveProfileName"),
  liveProfileSelect: document.getElementById("liveProfileSelect"),
  liveProfileSaveBtn: document.getElementById("liveProfileSaveBtn"),
  liveProfileLoadBtn: document.getElementById("liveProfileLoadBtn"),
  liveProfileDeleteBtn: document.getElementById("liveProfileDeleteBtn"),
  liveProfileResetBtn: document.getElementById("liveProfileResetBtn"),
  liveProfileStat: document.getElementById("liveProfileStat"),
  reloadBtn: document.getElementById("reloadBtn"),
  dropBtn: document.getElementById("dropBtn"),
  hueEntBtn: document.getElementById("hueEntBtn"),
  hueRestBtn: document.getElementById("hueRestBtn"),
  serverStopBtn: document.getElementById("serverStopBtn"),
  fixturesReloadBtn: document.getElementById("fixturesReloadBtn"),
  autoRulesEnabled: document.getElementById("autoRulesEnabled"),
  autoRulesTargetZone: document.getElementById("autoRulesTargetZone"),
  autoRulesTransitionMs: document.getElementById("autoRulesTransitionMs"),
  autoStartEnabled: document.getElementById("autoStartEnabled"),
  autoStartPercent: document.getElementById("autoStartPercent"),
  autoStartPercentVal: document.getElementById("autoStartPercentVal"),
  autoStartDelayMs: document.getElementById("autoStartDelayMs"),
  autoStopEnabled: document.getElementById("autoStopEnabled"),
  autoStopPercent: document.getElementById("autoStopPercent"),
  autoStopPercentVal: document.getElementById("autoStopPercentVal"),
  autoStopDelayMs: document.getElementById("autoStopDelayMs"),
  autoRulesSaveBtn: document.getElementById("autoRulesSaveBtn"),
  autoRulesReloadBtn: document.getElementById("autoRulesReloadBtn"),
  autoRulesTestStartBtn: document.getElementById("autoRulesTestStartBtn"),
  autoRulesTestStopBtn: document.getElementById("autoRulesTestStopBtn"),
  autoRulesState: document.getElementById("autoRulesState"),
  autoRulesZone: document.getElementById("autoRulesZone"),
  autoRulesTransition: document.getElementById("autoRulesTransition"),
  autoRulesStart: document.getElementById("autoRulesStart"),
  autoRulesStop: document.getElementById("autoRulesStop"),
  autoRulesVersion: document.getElementById("autoRulesVersion"),
  autoRulesLoadedAt: document.getElementById("autoRulesLoadedAt"),
  autoRulesBackup: document.getElementById("autoRulesBackup"),
  systemStartTab: document.getElementById("systemStartTab"),
  systemConfirmActions: document.getElementById("systemConfirmActions"),
  systemPollingMode: document.getElementById("systemPollingMode"),
  systemAutoLaunchBrowser: document.getElementById("systemAutoLaunchBrowser"),
  systemHueTransportPreference: document.getElementById("systemHueTransportPreference"),
  systemUnsafeSensitiveLogs: document.getElementById("systemUnsafeSensitiveLogs"),
  systemSettingsSaveBtn: document.getElementById("systemSettingsSaveBtn"),
  systemSettingsResetBtn: document.getElementById("systemSettingsResetBtn"),
  systemPollNowBtn: document.getElementById("systemPollNowBtn"),
  systemClearCacheBtn: document.getElementById("systemClearCacheBtn"),
  systemSettingsStatus: document.getElementById("systemSettingsStatus"),
  aRefreshBtn: document.getElementById("aRefreshBtn"),
  aScanBtn: document.getElementById("aScanBtn"),
  aApplyBtn: document.getElementById("aApplyBtn"),
  aRestartBtn: document.getElementById("aRestartBtn"),
  aResetDefaultsBtn: document.getElementById("aResetDefaultsBtn"),
  aOptionalToolsBanner: document.getElementById("aOptionalToolsBanner"),
  aOptionalToolsBadge: document.getElementById("aOptionalToolsBadge"),
  aOptionalToolsText: document.getElementById("aOptionalToolsText"),
  aOptionalToolsInfoBtn: document.getElementById("aOptionalToolsInfoBtn"),
  aOptionalToolsDismissBtn: document.getElementById("aOptionalToolsDismissBtn"),
  metaAutoOnBtn: document.getElementById("metaAutoOnBtn"),
  metaAutoOffBtn: document.getElementById("metaAutoOffBtn"),
  metaAutoTrackerAutoBtn: document.getElementById("metaAutoTrackerAutoBtn"),
  metaAutoTrackerCandidatesBtn: document.getElementById("metaAutoTrackerCandidatesBtn"),
  metaAutoHueWizBaselineBlendBtn: document.getElementById("metaAutoHueWizBaselineBlendBtn"),
  metaAutoTrackerPeaksBtn: document.getElementById("metaAutoTrackerPeaksBtn"),
  metaAutoTrackerTransientsBtn: document.getElementById("metaAutoTrackerTransientsBtn"),
  metaAutoTrackerFluxBtn: document.getElementById("metaAutoTrackerFluxBtn"),
  metaAutoHueWizBaselineBlendStat: document.getElementById("metaAutoHueWizBaselineBlendStat"),
  ocAutoBtn: document.getElementById("ocAutoBtn"),
  ocInsaneBtn: document.getElementById("ocInsaneBtn"),
  ocHyperBtn: document.getElementById("ocHyperBtn"),
  ocLudicrousBtn: document.getElementById("ocLudicrousBtn"),
  ocExtremeBtn: document.getElementById("ocExtremeBtn"),
  ocUltraBtn: document.getElementById("ocUltraBtn"),
  ocTurboBtn: document.getElementById("ocTurboBtn"),
  ocOnBtn: document.getElementById("ocOnBtn"),
  ocOffBtn: document.getElementById("ocOffBtn"),
  ocDevCluster: document.getElementById("ocDevCluster"),
  ocDev20Btn: document.getElementById("ocDev20Btn"),
  ocDev30Btn: document.getElementById("ocDev30Btn"),
  ocDev40Btn: document.getElementById("ocDev40Btn"),
  ocDev50Btn: document.getElementById("ocDev50Btn"),
  ocDev60Btn: document.getElementById("ocDev60Btn"),
  sceneAutoBtn: document.getElementById("sceneAutoBtn"),
  sceneSyncOnBtn: document.getElementById("sceneSyncOnBtn"),
  sceneSyncOffBtn: document.getElementById("sceneSyncOffBtn"),
  sceneSyncStat: document.getElementById("sceneSyncStat"),
  themeCogBtn: document.getElementById("themeCogBtn"),
  themePanel: document.getElementById("themePanel"),
  tabsBar: document.getElementById("tabsBar"),
  midiTabBtn: document.getElementById("midiTabBtn"),
  midiTabPage: document.getElementById("midiTabPage"),
  themeLogoColor: document.getElementById("themeLogoColor"),
  themeButtonColor: document.getElementById("themeButtonColor"),
  themeResetBtn: document.getElementById("themeResetBtn"),
  themeCloseBtn: document.getElementById("themeCloseBtn"),
  devDebugToggleBtn: document.getElementById("devDebugToggleBtn"),
  devDebugStatus: document.getElementById("devDebugStatus"),
  devToolsPanel: document.getElementById("devToolsPanel"),
  midiTabToggleBtn: document.getElementById("midiTabToggleBtn"),
  midiCogStatus: document.getElementById("midiCogStatus"),
  devToolRuntimeBtn: document.getElementById("devToolRuntimeBtn"),
  devToolConnectivityBtn: document.getElementById("devToolConnectivityBtn"),
  devToolHooksBtn: document.getElementById("devToolHooksBtn"),
  devToolTiersBtn: document.getElementById("devToolTiersBtn"),
  devToolsStatus: document.getElementById("devToolsStatus"),
  devToolsDump: document.getElementById("devToolsDump"),
  devOcAckGate: document.getElementById("devOcAckGate"),
  devOcAckInput: document.getElementById("devOcAckInput"),
  devOcAckPhrase: document.getElementById("devOcAckPhrase"),
  devOcAckCancelBtn: document.getElementById("devOcAckCancelBtn"),
  devOcAckConfirmBtn: document.getElementById("devOcAckConfirmBtn"),
  onboardStartBtn: document.getElementById("onboardStartBtn"),
  onboardResetBtn: document.getElementById("onboardResetBtn"),
  obsDockCompactBtn: document.getElementById("obsDockCompactBtn"),
  health: document.getElementById("health"),
  netBadge: document.getElementById("netBadge"),
  onboardGate: document.getElementById("onboardGate"),
  onboardAckBtn: document.getElementById("onboardAckBtn"),
  hueEntGuideGate: document.getElementById("hueEntGuideGate"),
  hueEntGuideAckBtn: document.getElementById("hueEntGuideAckBtn"),
  guidedTourGate: document.getElementById("guidedTourGate"),
  guidedTourStep: document.getElementById("guidedTourStep"),
  guidedTourTitle: document.getElementById("guidedTourTitle"),
  guidedTourText: document.getElementById("guidedTourText"),
  guidedTourPrevBtn: document.getElementById("guidedTourPrevBtn"),
  guidedTourNextBtn: document.getElementById("guidedTourNextBtn"),
  guidedTourSkipBtn: document.getElementById("guidedTourSkipBtn"),
  jumpRoutingLink: document.getElementById("jumpRoutingLink"),
  jumpModsLink: document.getElementById("jumpModsLink"),
  apiBaseInput: document.getElementById("apiBaseInput"),
  apiBaseSaveBtn: document.getElementById("apiBaseSaveBtn"),
  apiBaseResetBtn: document.getElementById("apiBaseResetBtn"),
  aDeviceMatch: document.getElementById("aDeviceMatch"),
  aDeviceId: document.getElementById("aDeviceId"),
  aInputBackend: document.getElementById("aInputBackend"),
  aFfmpegPath: document.getElementById("aFfmpegPath"),
  aFfmpegFormat: document.getElementById("aFfmpegFormat"),
  aFfmpegDevice: document.getElementById("aFfmpegDevice"),
  aFfmpegSources: document.getElementById("aFfmpegSources"),
  aAppIsolationEnabled: document.getElementById("aAppIsolationEnabled"),
  aAppIsolationMultiSource: document.getElementById("aAppIsolationMultiSource"),
  aAppIsolationStrict: document.getElementById("aAppIsolationStrict"),
  aAppIsolationCheckMs: document.getElementById("aAppIsolationCheckMs"),
  aIsoSimpleMode: document.getElementById("aIsoSimpleMode"),
  aAppsShowAll: document.getElementById("aAppsShowAll"),
  aAppsFilterHint: document.getElementById("aAppsFilterHint"),
  aAppPrimary: document.getElementById("aAppPrimary"),
  aAppFallback: document.getElementById("aAppFallback"),
  aAppPrimarySources: document.getElementById("aAppPrimarySources"),
  aAppFallbackSources: document.getElementById("aAppFallbackSources"),
  aAppsRefreshBtn: document.getElementById("aAppsRefreshBtn"),
  aAppIsolationStatus: document.getElementById("aAppIsolationStatus"),
  liveAudioAppSearchBtn: document.getElementById("liveAudioAppSearchBtn"),
  liveAudioAppSearchStat: document.getElementById("liveAudioAppSearchStat"),
  aSampleRate: document.getElementById("aSampleRate"),
  aFrames: document.getElementById("aFrames"),
  aChannels: document.getElementById("aChannels"),
  aGain: document.getElementById("aGain"),
  aQuickSnapStages: document.getElementById("aQuickSnapStages"),
  aQuickTuneResetBtn: document.getElementById("aQuickTuneResetBtn"),
  aQuickProfileMix: document.getElementById("aQuickProfileMix"),
  aQuickProfileMixVal: document.getElementById("aQuickProfileMixVal"),
  aQuickProfileStage: document.getElementById("aQuickProfileStage"),
  aQuickGain: document.getElementById("aQuickGain"),
  aQuickGainVal: document.getElementById("aQuickGainVal"),
  aQuickGainStage: document.getElementById("aQuickGainStage"),
  aQuickNoiseGate: document.getElementById("aQuickNoiseGate"),
  aQuickNoiseGateVal: document.getElementById("aQuickNoiseGateVal"),
  aQuickNoiseGateStage: document.getElementById("aQuickNoiseGateStage"),
  aQuickAutoTarget: document.getElementById("aQuickAutoTarget"),
  aQuickAutoTargetVal: document.getElementById("aQuickAutoTargetVal"),
  aQuickAutoTargetStage: document.getElementById("aQuickAutoTargetStage"),
  aQuickAutoGate: document.getElementById("aQuickAutoGate"),
  aQuickAutoGateVal: document.getElementById("aQuickAutoGateVal"),
  aQuickAutoGateStage: document.getElementById("aQuickAutoGateStage"),
  aQuickLimiter: document.getElementById("aQuickLimiter"),
  aQuickLimiterVal: document.getElementById("aQuickLimiterVal"),
  aQuickLimiterStage: document.getElementById("aQuickLimiterStage"),
  aQuickTuneApplyBtn: document.getElementById("aQuickTuneApplyBtn"),
  aAutoLevelEnabled: document.getElementById("aAutoLevelEnabled"),
  aAutoLevelTarget: document.getElementById("aAutoLevelTarget"),
  aAutoLevelMinGain: document.getElementById("aAutoLevelMinGain"),
  aAutoLevelMaxGain: document.getElementById("aAutoLevelMaxGain"),
  aAutoLevelGate: document.getElementById("aAutoLevelGate"),
  aNoise: document.getElementById("aNoise"),
  aPeakDecay: document.getElementById("aPeakDecay"),
  aBandLowHz: document.getElementById("aBandLowHz"),
  aBandMidHz: document.getElementById("aBandMidHz"),
  aLimiterThreshold: document.getElementById("aLimiterThreshold"),
  aLimiterKnee: document.getElementById("aLimiterKnee"),
  aRestartMs: document.getElementById("aRestartMs"),
  aLogTicks: document.getElementById("aLogTicks"),
  aDevices: document.getElementById("aDevices"),
  midiModuleStatus: document.getElementById("midiModuleStatus"),
  midiRuntimeStatus: document.getElementById("midiRuntimeStatus"),
  midiActivePort: document.getElementById("midiActivePort"),
  midiLearnStatus: document.getElementById("midiLearnStatus"),
  midiLastEvent: document.getElementById("midiLastEvent"),
  midiLastAction: document.getElementById("midiLastAction"),
  midiEnabled: document.getElementById("midiEnabled"),
  midiVelocityThreshold: document.getElementById("midiVelocityThreshold"),
  midiPortSelect: document.getElementById("midiPortSelect"),
  midiDeviceMatch: document.getElementById("midiDeviceMatch"),
  midiRefreshBtn: document.getElementById("midiRefreshBtn"),
  midiSaveCfgBtn: document.getElementById("midiSaveCfgBtn"),
  midiLearnAction: document.getElementById("midiLearnAction"),
  midiLearnArmBtn: document.getElementById("midiLearnArmBtn"),
  midiLearnCancelBtn: document.getElementById("midiLearnCancelBtn"),
  midiTriggerBtn: document.getElementById("midiTriggerBtn"),
  midiBindingAction: document.getElementById("midiBindingAction"),
  midiBindingType: document.getElementById("midiBindingType"),
  midiBindingNumber: document.getElementById("midiBindingNumber"),
  midiBindingChannel: document.getElementById("midiBindingChannel"),
  midiBindingMinValue: document.getElementById("midiBindingMinValue"),
  midiBindingSaveBtn: document.getElementById("midiBindingSaveBtn"),
  midiBindingClearBtn: document.getElementById("midiBindingClearBtn"),
  midiBindingResetBtn: document.getElementById("midiBindingResetBtn"),
  midiBindingsDump: document.getElementById("midiBindingsDump"),
  master: document.getElementById("master"),
  masterVal: document.getElementById("masterVal"),
  masterInlineResetBtn: document.getElementById("masterInlineResetBtn"),
  flowIntensity: document.getElementById("flowIntensity"),
  flowIntensityVal: document.getElementById("flowIntensityVal"),
  flowResetBtn: document.getElementById("flowResetBtn"),
  dropIntensity: document.getElementById("dropIntensity"),
  dropVal: document.getElementById("dropVal"),
  dropInlineResetBtn: document.getElementById("dropInlineResetBtn"),
  reactorResetBtn: document.getElementById("reactorResetBtn"),
  reactorRiskNotice: document.getElementById("reactorRiskNotice"),
  reactDropEnabled: document.getElementById("reactDropEnabled"),
  reactHardwareRateLimitsEnabled: document.getElementById("reactHardwareRateLimitsEnabled"),
  reactSmartMatchEnabled: document.getElementById("reactSmartMatchEnabled"),
  reactForceLockEnabled: document.getElementById("reactForceLockEnabled"),
  reactForceMatchOverride: document.getElementById("reactForceMatchOverride"),
  reactCompatSummary: document.getElementById("reactCompatSummary"),
  reactHueEnabled: document.getElementById("reactHueEnabled"),
  reactWizEnabled: document.getElementById("reactWizEnabled"),
  reactOtherEnabled: document.getElementById("reactOtherEnabled"),
  reactHueSources: document.getElementById("reactHueSources"),
  reactWizSources: document.getElementById("reactWizSources"),
  reactOtherSources: document.getElementById("reactOtherSources"),
  reactHueAmount: document.getElementById("reactHueAmount"),
  reactWizAmount: document.getElementById("reactWizAmount"),
  reactOtherAmount: document.getElementById("reactOtherAmount"),
  reactHueAmountVal: document.getElementById("reactHueAmountVal"),
  reactWizAmountVal: document.getElementById("reactWizAmountVal"),
  reactOtherAmountVal: document.getElementById("reactOtherAmountVal"),
  reactMapApplyBtn: document.getElementById("reactMapApplyBtn"),
  reactMapResetBtn: document.getElementById("reactMapResetBtn"),
  reactMapStatus: document.getElementById("reactMapStatus"),
  rms: document.getElementById("rms"),
  eng: document.getElementById("eng"),
  mode: document.getElementById("mode"),
  autoProfile: document.getElementById("autoProfile"),
  audioReact: document.getElementById("audioReact"),
  flowStat: document.getElementById("flowStat"),
  scene: document.getElementById("scene"),
  behavior: document.getElementById("behavior"),
  phrase: document.getElementById("phrase"),
  dropStat: document.getElementById("dropStat"),
  metaAutoStat: document.getElementById("metaAutoStat"),
  paletteStat: document.getElementById("paletteStat"),
  paletteOrderStat: document.getElementById("paletteOrderStat"),
  hSent: document.getElementById("hSent"),
  hSkip: document.getElementById("hSkip"),
  hLat: document.getElementById("hLat"),
  hState: document.getElementById("hState"),
  wSent: document.getElementById("wSent"),
  wSkip: document.getElementById("wSkip"),
  wLat: document.getElementById("wLat"),
  wState: document.getElementById("wState"),
  aLevel: document.getElementById("aLevel"),
  aRaw: document.getElementById("aRaw"),
  aPeak: document.getElementById("aPeak"),
  aTransient: document.getElementById("aTransient"),
  aZcr: document.getElementById("aZcr"),
  aBandLow: document.getElementById("aBandLow"),
  aBandMid: document.getElementById("aBandMid"),
  aBandHigh: document.getElementById("aBandHigh"),
  aFlux: document.getElementById("aFlux"),
  aAutoGain: document.getElementById("aAutoGain"),
  aEffectiveGain: document.getElementById("aEffectiveGain"),
  aDevice: document.getElementById("aDevice"),
  aRunning: document.getElementById("aRunning"),
  aRestart: document.getElementById("aRestart"),
  aError: document.getElementById("aError"),
  fixHue: document.getElementById("fixHue"),
  fixWiz: document.getElementById("fixWiz"),
  fixHueReady: document.getElementById("fixHueReady"),
  fixWizReady: document.getElementById("fixWizReady"),
  routeHue: document.getElementById("routeHue"),
  routeWiz: document.getElementById("routeWiz"),
  routeTwitchHue: document.getElementById("routeTwitchHue"),
  routeTwitchWiz: document.getElementById("routeTwitchWiz"),
  cfgVer: document.getElementById("cfgVer"),
  cfgAt: document.getElementById("cfgAt"),
  routeHueInput: document.getElementById("routeHueInput"),
  routeWizInput: document.getElementById("routeWizInput"),
  routeTwitchHueInput: document.getElementById("routeTwitchHueInput"),
  routeTwitchWizInput: document.getElementById("routeTwitchWizInput"),
  colorPrefixHue: document.getElementById("colorPrefixHue"),
  colorPrefixWiz: document.getElementById("colorPrefixWiz"),
  colorPrefixDefaultTarget: document.getElementById("colorPrefixDefaultTarget"),
  colorPrefixOtherWrap: document.getElementById("colorPrefixOtherWrap"),
  colorPrefixOther: document.getElementById("colorPrefixOther"),
  colorPrefixFixtureMap: document.getElementById("colorPrefixFixtureMap"),
  colorRaveOffEnabled: document.getElementById("colorRaveOffEnabled"),
  colorRaveOffDefault: document.getElementById("colorRaveOffDefault"),
  colorRaveOffGroupMap: document.getElementById("colorRaveOffGroupMap"),
  colorRaveOffFixtureMap: document.getElementById("colorRaveOffFixtureMap"),
  colorPrefixSaveBtn: document.getElementById("colorPrefixSaveBtn"),
  colorPrefixResetBtn: document.getElementById("colorPrefixResetBtn"),
  colorPrefixStatus: document.getElementById("colorPrefixStatus"),
  fxBrand: document.getElementById("fxBrand"),
  fxModBrandGroup: document.getElementById("fxModBrandGroup"),
  fxModBrandStatus: document.getElementById("fxModBrandStatus"),
  fxModBrandWrap: document.getElementById("fxModBrandWrap"),
  fxModBrandId: document.getElementById("fxModBrandId"),
  fxId: document.getElementById("fxId"),
  fxZone: document.getElementById("fxZone"),
  fxEnabled: document.getElementById("fxEnabled"),
  fxEngineEnabled: document.getElementById("fxEngineEnabled"),
  fxCustomEnabled: document.getElementById("fxCustomEnabled"),
  fxControlMode: document.getElementById("fxControlMode"),
  fxEngineBinding: document.getElementById("fxEngineBinding"),
  fxTwitchEnabled: document.getElementById("fxTwitchEnabled"),
  fxOriginalId: document.getElementById("fxOriginalId"),
  fxCompatHint: document.getElementById("fxCompatHint"),
  fxBridgeIp: document.getElementById("fxBridgeIp"),
  fxUsername: document.getElementById("fxUsername"),
  fxLightId: document.getElementById("fxLightId"),
  fxBridgeId: document.getElementById("fxBridgeId"),
  fxClientKey: document.getElementById("fxClientKey"),
  fxEntertainmentAreaId: document.getElementById("fxEntertainmentAreaId"),
  fxHueDiscoverBtn: document.getElementById("fxHueDiscoverBtn"),
  fxHuePairBtn: document.getElementById("fxHuePairBtn"),
  fxHueSaveBridgeBtn: document.getElementById("fxHueSaveBridgeBtn"),
  fxWizIp: document.getElementById("fxWizIp"),
  fxBridgeIpShowBtn: document.getElementById("fxBridgeIpShowBtn"),
  fxUsernameShowBtn: document.getElementById("fxUsernameShowBtn"),
  fxClientKeyShowBtn: document.getElementById("fxClientKeyShowBtn"),
  fxWizIpShowBtn: document.getElementById("fxWizIpShowBtn"),
  fxSaveBtn: document.getElementById("fxSaveBtn"),
  fxResetBtn: document.getElementById("fxResetBtn"),
  fxHueBridgeBlock: document.getElementById("fxHueBridgeBlock"),
  fxHueBridgeWrap: document.getElementById("fxHueBridgeWrap"),
  fxHueUserWrap: document.getElementById("fxHueUserWrap"),
  fxHueLightWrap: document.getElementById("fxHueLightWrap"),
  fxHueBridgeIdWrap: document.getElementById("fxHueBridgeIdWrap"),
  fxHueClientKeyWrap: document.getElementById("fxHueClientKeyWrap"),
  fxHueEntWrap: document.getElementById("fxHueEntWrap"),
  fxHuePairWrap: document.getElementById("fxHuePairWrap"),
  fxWizIpWrap: document.getElementById("fxWizIpWrap"),
  fxWizIpLabel: document.getElementById("fxWizIpLabel"),
  fixtureRows: document.getElementById("fixtureRows"),
  standFixtureSelect: document.getElementById("standFixtureSelect"),
  customFixtureSelect: document.getElementById("customFixtureSelect"),
  customFixtureSyncBtn: document.getElementById("customFixtureSyncBtn"),
  customStandaloneMount: document.getElementById("customStandaloneMount"),
  standRouteEngine: document.getElementById("standRouteEngine"),
  standRouteTwitch: document.getElementById("standRouteTwitch"),
  standRouteCustom: document.getElementById("standRouteCustom"),
  standRouteApplyBtn: document.getElementById("standRouteApplyBtn"),
  standConnectivityBtn: document.getElementById("standConnectivityBtn"),
  standRouteStatus: document.getElementById("standRouteStatus"),
  standConnectivityStatus: document.getElementById("standConnectivityStatus"),
  standCustomCluster: document.getElementById("standCustomCluster"),
  standPower: document.getElementById("standPower"),
  standMode: document.getElementById("standMode"),
  standScene: document.getElementById("standScene"),
  standAnimate: document.getElementById("standAnimate"),
  standSpeedMode: document.getElementById("standSpeedMode"),
  standSpeedHz: document.getElementById("standSpeedHz"),
  standSpeedMinHz: document.getElementById("standSpeedMinHz"),
  standSpeedMinHzVal: document.getElementById("standSpeedMinHzVal"),
  standSpeedMaxHz: document.getElementById("standSpeedMaxHz"),
  standSpeedMaxHzVal: document.getElementById("standSpeedMaxHzVal"),
  standBrightness: document.getElementById("standBrightness"),
  standBrightnessVal: document.getElementById("standBrightnessVal"),
  standRaveStopBrightness: document.getElementById("standRaveStopBrightness"),
  standRaveStopBrightnessVal: document.getElementById("standRaveStopBrightnessVal"),
  standColorMode: document.getElementById("standColorMode"),
  standStaticBtn: document.getElementById("standStaticBtn"),
  standRaveStartBtn: document.getElementById("standRaveStartBtn"),
  standRaveStopBtn: document.getElementById("standRaveStopBtn"),
  standHsvSingleWrap: document.getElementById("standHsvSingleWrap"),
  standHsvRangeRow: document.getElementById("standHsvRangeRow"),
  standCctRangeRow: document.getElementById("standCctRangeRow"),
  standHue: document.getElementById("standHue"),
  standHueVal: document.getElementById("standHueVal"),
  standHueMin: document.getElementById("standHueMin"),
  standHueMinVal: document.getElementById("standHueMinVal"),
  standHueMax: document.getElementById("standHueMax"),
  standHueMaxVal: document.getElementById("standHueMaxVal"),
  standSat: document.getElementById("standSat"),
  standSatVal: document.getElementById("standSatVal"),
  standSatMin: document.getElementById("standSatMin"),
  standSatMinVal: document.getElementById("standSatMinVal"),
  standSatMax: document.getElementById("standSatMax"),
  standSatMaxVal: document.getElementById("standSatMaxVal"),
  standCctKelvin: document.getElementById("standCctKelvin"),
  standCctKelvinVal: document.getElementById("standCctKelvinVal"),
  standCctMinKelvin: document.getElementById("standCctMinKelvin"),
  standCctMinKelvinVal: document.getElementById("standCctMinKelvinVal"),
  standCctMaxKelvin: document.getElementById("standCctMaxKelvin"),
  standCctMaxKelvinVal: document.getElementById("standCctMaxKelvinVal"),
  standTransitionMs: document.getElementById("standTransitionMs"),
  standApplyBtn: document.getElementById("standApplyBtn"),
  standRefreshBtn: document.getElementById("standRefreshBtn"),
  standStatus: document.getElementById("standStatus"),
  sceneLockStat: document.getElementById("sceneLockStat"),
  pollMs: document.getElementById("pollMs"),
  dropOverlay: document.getElementById("dropOverlay"),
  modsStatus: document.getElementById("modsStatus"),
  modDropZone: document.getElementById("modDropZone"),
  modImportStatus: document.getElementById("modImportStatus"),
  modImportBrowseBtn: document.getElementById("modImportBrowseBtn"),
  modImportOverwrite: document.getElementById("modImportOverwrite"),
  modImportEnable: document.getElementById("modImportEnable"),
  modImportPicker: document.getElementById("modImportPicker"),
  modsRows: document.getElementById("modsRows"),
  moddingReadmeBtn: document.getElementById("moddingReadmeBtn"),
  modsRefreshBtn: document.getElementById("modsRefreshBtn"),
  modsReloadBtn: document.getElementById("modsReloadBtn"),
  modsDebugStatus: document.getElementById("modsDebugStatus"),
  modsDebugToggleBtn: document.getElementById("modsDebugToggleBtn"),
  modsDebugClearBtn: document.getElementById("modsDebugClearBtn"),
  modEnableId: document.getElementById("modEnableId"),
  modEnableBtn: document.getElementById("modEnableBtn"),
  modDisableBtn: document.getElementById("modDisableBtn"),
  modApplyBtn: document.getElementById("modApplyBtn"),
  modDiscardBtn: document.getElementById("modDiscardBtn"),
  modHotswapStatus: document.getElementById("modHotswapStatus"),
  modActionModId: document.getElementById("modActionModId"),
  modActionName: document.getElementById("modActionName"),
  modActionMethod: document.getElementById("modActionMethod"),
  modActionRunBtn: document.getElementById("modActionRunBtn"),
  modActionOutput: document.getElementById("modActionOutput"),
  modUiPanel: document.getElementById("modUiPanel"),
  modUiSelect: document.getElementById("modUiSelect"),
  modUiRefreshBtn: document.getElementById("modUiRefreshBtn"),
  modUiReloadBtn: document.getElementById("modUiReloadBtn"),
  modUiOpenBtn: document.getElementById("modUiOpenBtn"),
  modUiStatus: document.getElementById("modUiStatus"),
  modUiFrameWrap: document.getElementById("modUiFrameWrap"),
  modUiFrame: document.getElementById("modUiFrame"),
  modUiEmpty: document.getElementById("modUiEmpty"),
  scopeDrive: document.getElementById("scopeDrive"),
  scopeMotion: document.getElementById("scopeMotion"),
  scopeScene: document.getElementById("scopeScene"),
  scopeBehav: document.getElementById("scopeBehav"),
  canvas: document.getElementById("canvas"),
  telemetryCanvas: document.getElementById("telemetryCanvas"),
  paletteScopeGlobalBtn: document.getElementById("paletteScopeGlobalBtn"),
  paletteScopeCustomBtn: document.getElementById("paletteScopeCustomBtn"),
  paletteGlobalPanel: document.getElementById("paletteGlobalPanel"),
  paletteCustomPanel: document.getElementById("paletteCustomPanel"),
  paletteCustomBrandTabs: document.getElementById("paletteCustomBrandTabs"),
  paletteModeNotice: document.getElementById("paletteModeNotice"),
  paletteFamilyGrid: document.getElementById("paletteFamilyGrid"),
  paletteBrandMenus: document.getElementById("paletteBrandMenus"),
  paletteDisorderAggression: document.getElementById("paletteDisorderAggression"),
  paletteDisorderAggressionVal: document.getElementById("paletteDisorderAggressionVal"),
  paletteDisorderAggressionResetBtn: document.getElementById("paletteDisorderAggressionResetBtn"),
  paletteTimedControls: document.getElementById("paletteTimedControls"),
  paletteTimedIntervalSec: document.getElementById("paletteTimedIntervalSec"),
  paletteTimedIntervalSecVal: document.getElementById("paletteTimedIntervalSecVal"),
  paletteBeatLockGraceSec: document.getElementById("paletteBeatLockGraceSec"),
  paletteBeatLockGraceSecVal: document.getElementById("paletteBeatLockGraceSecVal"),
  paletteReactiveControls: document.getElementById("paletteReactiveControls"),
  paletteReactiveMargin: document.getElementById("paletteReactiveMargin"),
  paletteReactiveMarginVal: document.getElementById("paletteReactiveMarginVal"),
  paletteBrightnessFollowWrap: document.getElementById("paletteBrightnessFollowWrap"),
  paletteBrightnessFollowAmount: document.getElementById("paletteBrightnessFollowAmount"),
  paletteBrightnessFollowAmountVal: document.getElementById("paletteBrightnessFollowAmountVal"),
  paletteSpectrumControls: document.getElementById("paletteSpectrumControls")
};

const tabButtons = Array.from(document.querySelectorAll("[data-tab-btn]"));
const tabPages = Array.from(document.querySelectorAll("[data-tab]"));
const sceneButtons = Array.from(document.querySelectorAll("[data-scene]"));
const autoProfileButtons = Array.from(document.querySelectorAll("[data-auto-profile]"));
const audioReactivityButtons = Array.from(document.querySelectorAll("[data-audio-reactivity]"));
const audioQuickPresetButtons = Array.from(document.querySelectorAll("[data-audio-quick]"));
const paletteCountButtons = Array.from(document.querySelectorAll("[data-palette-count]"));
const paletteVividnessButtons = Array.from(document.querySelectorAll("[data-palette-vividness]"));
const palettePresetButtons = Array.from(document.querySelectorAll("[data-palette-preset]"));
const paletteDisorderButtons = Array.from(document.querySelectorAll("[data-palette-disorder]"));
const paletteCycleModeButtons = Array.from(document.querySelectorAll("[data-palette-cycle-mode]"));
const paletteBeatLockButtons = Array.from(document.querySelectorAll("[data-palette-beat-lock]"));
const paletteBrightnessModeButtons = Array.from(document.querySelectorAll("[data-palette-brightness-mode]"));
const paletteSpectrumModeButtons = Array.from(document.querySelectorAll("[data-palette-spectrum-mode]"));
const paletteCustomBrandButtons = Array.from(document.querySelectorAll("[data-palette-custom-brand]"));
const getPaletteSpectrumFeatureSelectors = () =>
  Array.from(document.querySelectorAll("[data-palette-spectrum-feature-slot]"));
const limiterPresetButtons = Array.from(document.querySelectorAll("[data-limiter-preset]"));
const getPaletteFamilyButtons = () =>
  el.paletteFamilyGrid
    ? Array.from(el.paletteFamilyGrid.querySelectorAll("[data-palette-family]"))
    : [];
const themePresetButtons = Array.from(document.querySelectorAll("[data-theme-preset]"));
const MOD_BRAND_RE = /^[a-z][a-z0-9_-]{1,31}$/;
const FIXTURE_MOD_CUSTOM_BRAND_VALUE = "__mod_custom__";

const LIMITER_PRESETS = {
  transparent: { limiterThreshold: 0.9, limiterKnee: 0.24 },
  balanced: { limiterThreshold: 0.82, limiterKnee: 0.16 },
  hard: { limiterThreshold: 0.72, limiterKnee: 0.08 }
};
const AUDIO_QUICK_PROFILES = Object.freeze({
  safe: { sampleRate: 48000, framesPerBuffer: 512 },
  balanced: { sampleRate: 48000, framesPerBuffer: 256 },
  fast: { sampleRate: 48000, framesPerBuffer: 128 },
  hires: { sampleRate: 96000, framesPerBuffer: 256 }
});
const AUDIO_CONFIG_DEFAULTS = Object.freeze({
  inputBackend: "auto",
  deviceMatch: "",
  deviceId: null,
  ffmpegPath: "ffmpeg",
  ffmpegInputFormat: "dshow",
  ffmpegInputDevice: "",
  ffmpegInputDevices: [],
  ffmpegLogLevel: "error",
  ffmpegUseWallclock: true,
  ffmpegAppIsolationEnabled: false,
  ffmpegAppIsolationStrict: false,
  ffmpegAppIsolationPrimaryApp: "",
  ffmpegAppIsolationFallbackApp: "",
  ffmpegAppIsolationPrimaryDevices: [],
  ffmpegAppIsolationFallbackDevices: [],
  ffmpegAppIsolationMultiSource: false,
  ffmpegAppIsolationCheckMs: 300000,
  sampleRate: 96000,
  framesPerBuffer: 256,
  channels: 2,
  outputGain: 1,
  autoLevelEnabled: true,
  autoLevelTargetRms: 0.028,
  autoLevelMinGain: 0.45,
  autoLevelMaxGain: 1.55,
  autoLevelResponse: 0.015,
  autoLevelGate: 0.007,
  noiseFloorMin: 0.00045,
  peakDecay: 0.93,
  bandLowHz: 180,
  bandMidHz: 2200,
  limiterThreshold: 0.82,
  limiterKnee: 0.16,
  restartMs: 1500,
  logEveryTicks: 60
});
const AUDIO_REACTIVITY_SOURCE_CATALOG_DEFAULT = Object.freeze({
  smart: Object.freeze({ label: "SMART", description: "Adaptive blend" }),
  baseline: Object.freeze({ label: "BASE", description: "Steady RMS/body" }),
  bass: Object.freeze({ label: "BASS", description: "Low band" }),
  mids: Object.freeze({ label: "MIDS", description: "Mid band" }),
  highs: Object.freeze({ label: "HIGHS", description: "High band" }),
  peaks: Object.freeze({ label: "PEAKS", description: "Peak envelope" }),
  transients: Object.freeze({ label: "TRANS", description: "Attack spikes" }),
  flux: Object.freeze({ label: "FLUX", description: "Spectral motion" }),
  drums: Object.freeze({ label: "DRUMS", description: "Percussive blend" }),
  vocals: Object.freeze({ label: "VOCALS", description: "Vocal focus" }),
  beat: Object.freeze({ label: "BEAT", description: "Beat confidence" }),
  groove: Object.freeze({ label: "GROOVE", description: "Body blend" })
});
const AUDIO_REACTIVITY_TARGET_KEYS = Object.freeze(["hue", "wiz", "other"]);
const META_AUTO_TEMPO_TRACKER_KEYS = Object.freeze([
  "baseline",
  "peaks",
  "transients",
  "flux"
]);
const AUDIO_REACTIVITY_MAP_DEFAULT = Object.freeze({
  version: 1,
  dropEnabled: false,
  hardwareRateLimitsEnabled: true,
  metaAutoHueWizBaselineBlend: true,
  metaAutoTempoTrackersAuto: false,
  metaAutoTempoTrackers: Object.freeze({
    baseline: true,
    peaks: false,
    transients: false,
    flux: false
  }),
  targets: Object.freeze({
    hue: Object.freeze({ enabled: true, amount: 1, sources: Object.freeze(["smart"]) }),
    wiz: Object.freeze({ enabled: true, amount: 1, sources: Object.freeze(["smart"]) }),
    other: Object.freeze({ enabled: true, amount: 1, sources: Object.freeze(["smart"]) })
  })
});
const AUDIO_REACTIVITY_SOURCE_ORDER = Object.freeze([
  "smart",
  "baseline",
  "bass",
  "mids",
  "highs",
  "peaks",
  "transients",
  "flux",
  "drums",
  "vocals",
  "beat",
  "groove"
]);
const LIVE_REACTIVITY_STATE_WEIGHT = Object.freeze({
  modeLock: 1.2,
  autoProfile: 0.95,
  audioReactivityPreset: 1.25,
  sceneLock: 1.45,
  paletteDisorder: 0.42,
  overclockBand: 0.85
});
const LIVE_REACTIVITY_SOURCE_BY_STATE = Object.freeze({
  modeLock: Object.freeze({
    auto: Object.freeze(["smart", "drums", "transients", "beat"]),
    clamp: Object.freeze(["drums", "transients", "bass", "peaks"]),
    interpret: Object.freeze(["beat", "drums", "transients", "groove"])
  }),
  autoProfile: Object.freeze({
    reactive: Object.freeze(["transients", "drums", "peaks", "flux"]),
    balanced: Object.freeze(["smart", "drums", "beat", "transients"]),
    cinematic: Object.freeze(["baseline", "vocals", "mids", "smart"])
  }),
  audioReactivityPreset: Object.freeze({
    balanced: Object.freeze(["smart", "drums", "beat", "transients"]),
    aggressive: Object.freeze(["peaks", "transients", "drums", "bass"]),
    precision: Object.freeze(["beat", "vocals", "highs", "baseline"])
  }),
  sceneLock: Object.freeze({
    auto: Object.freeze(["smart", "drums", "transients", "beat"]),
    idle_soft: Object.freeze(["baseline", "vocals", "mids"]),
    flow: Object.freeze(["groove", "mids", "flux", "bass"]),
    pulse_strobe: Object.freeze(["drums", "peaks", "transients", "beat"])
  }),
  paletteDisorder: Object.freeze({
    ordered: Object.freeze(["smart", "groove", "beat", "mids"]),
    disorder: Object.freeze(["flux", "transients", "peaks", "drums"])
  }),
  overclockBand: Object.freeze({
    low: Object.freeze(["smart", "beat", "groove", "mids"]),
    medium: Object.freeze(["drums", "transients", "beat", "smart"]),
    high: Object.freeze(["transients", "peaks", "drums", "flux"])
  })
});
const LIVE_REACTIVITY_TARGET_BIAS = Object.freeze({
  hue: Object.freeze({
    smart: 0.28,
    baseline: 0.12,
    groove: 0.08,
    beat: 0.16,
    vocals: 0.08,
    mids: 0.11,
    highs: 0.06,
    bass: 0.12,
    transients: 0.16,
    peaks: 0.14,
    flux: 0.1,
    drums: 0.18
  }),
  wiz: Object.freeze({
    smart: 0.14,
    drums: 0.3,
    transients: 0.24,
    peaks: 0.22,
    flux: 0.2,
    bass: 0.14,
    beat: 0.14,
    groove: 0.1,
    mids: 0.08,
    highs: 0.11,
    baseline: -0.04,
    vocals: -0.02
  }),
  other: Object.freeze({
    smart: 0.22,
    groove: 0.14,
    beat: 0.16,
    mids: 0.12,
    bass: 0.14,
    vocals: 0.06,
    highs: 0.07,
    flux: 0.12,
    transients: 0.14,
    peaks: 0.12,
    drums: 0.16,
    baseline: 0.04
  })
});
let liveSmartMatchSaveTimer = null;
let liveSmartMatchSaveInFlight = false;
let liveSmartMatchSaveQueued = false;
let audioReactivitySourceCatalogRuntime = { ...AUDIO_REACTIVITY_SOURCE_CATALOG_DEFAULT };
const DEV_OVERCLOCK_LEVEL_BY_HZ = Object.freeze({
  20: 8,
  30: 9,
  40: 10,
  50: 11,
  60: 12
});
const MIDI_ACTION_LABELS = Object.freeze({
  drop: "DROP HIT",
  overclock_toggle: "OVERCLOCK TOGGLE",
  overclock_on: "OVERCLOCK ON",
  overclock_off: "OVERCLOCK OFF",
  overclock_up: "OVERCLOCK UP",
  overclock_down: "OVERCLOCK DOWN",
  overclock_auto_toggle: "AUTO HZ TOGGLE",
  overclock_auto_on: "AUTO HZ ON",
  overclock_auto_off: "AUTO HZ OFF",
  behavior_interpret: "MODE BPM/INTERPRET",
  scene_auto: "SCENE AUTO",
  scene_idle: "SCENE IDLE",
  scene_flow: "SCENE FLOW",
  scene_pulse: "SCENE PULSE",
  auto_profile_reactive: "AUTO PROFILE REACTIVE",
  auto_profile_balanced: "AUTO PROFILE BALANCED",
  auto_profile_cinematic: "AUTO PROFILE CINEMATIC",
  audio_reactivity_balanced: "AUDIO REACT BALANCED",
  audio_reactivity_aggressive: "AUDIO REACT AGGRESSIVE",
  audio_reactivity_precision: "AUDIO REACT PRECISION",
  meta_auto_toggle: "META AUTO TOGGLE",
  meta_auto_on: "META AUTO ON",
  meta_auto_off: "META AUTO OFF",
  flow_intensity_up: "FLOW INTENSITY +",
  flow_intensity_down: "FLOW INTENSITY -",
  flow_intensity_reset: "FLOW INTENSITY RESET",
  wiz_scene_sync_toggle: "WIZ SCENE SYNC TOGGLE",
  wiz_scene_sync_on: "WIZ SCENE SYNC ON",
  wiz_scene_sync_off: "WIZ SCENE SYNC OFF",
  palette_ordered: "PALETTE ORDERED",
  palette_disorder: "PALETTE DISORDER",
  palette_colors_1: "PALETTE 1 COLOR",
  palette_colors_3: "PALETTE 3 COLORS",
  palette_colors_5: "PALETTE 5 COLORS",
  palette_colors_8: "PALETTE 8 COLORS",
  palette_colors_12: "PALETTE 12 COLORS",
  palette_family_red: "PALETTE RED",
  palette_family_green: "PALETTE GREEN",
  palette_family_blue: "PALETTE BLUE",
  palette_family_purple: "PALETTE RED TONE",
  palette_family_yellow: "PALETTE GREEN TONE",
  palette_preset_all_1: "PALETTE PRESET ALL x1",
  palette_preset_all_3: "PALETTE PRESET ALL x3",
  palette_preset_duo_cool: "PALETTE PRESET DUO COOL",
  palette_preset_duo_warm: "PALETTE PRESET DUO WARM"
});
const MIDI_FALLBACK_ACTIONS = Object.freeze(Object.keys(MIDI_ACTION_LABELS));

function setNodeTitle(node, text) {
  if (!node) return;
  node.title = text;
}

function applyUiTooltips() {
  setNodeTitle(el.onBtn, "Start reactive rave output.");
  setNodeTitle(el.offBtn, "Stop reactive rave output.");
  setNodeTitle(el.panicBtn, "Emergency blackout command.");
  setNodeTitle(el.liveProfileName, "Local profile name for quick save/load in LIVE.");
  setNodeTitle(el.liveProfileSelect, "Browse and select saved local LIVE profiles.");
  setNodeTitle(el.liveProfileSaveBtn, "Save current LIVE controls to local profile storage.");
  setNodeTitle(el.liveProfileLoadBtn, "Load and apply saved LIVE controls from local profile storage.");
  setNodeTitle(el.liveProfileDeleteBtn, "Delete selected local LIVE profile.");
  setNodeTitle(el.liveProfileResetBtn, "Apply built-in LIVE defaults (balanced profile/reactivity, AUTO scene, 6Hz, flow 1.00x).");
  setNodeTitle(el.liveProfileStat, "Status of the currently selected local LIVE profile.");
  setNodeTitle(el.themeCogBtn, "Open theme settings.");
  setNodeTitle(el.obsDockCompactBtn, "Toggle compact OBS dock layout.");
  setNodeTitle(
    el.devDebugToggleBtn,
    "Toggle DEV/DEBUG mode. One-time warning on first enable, then unsafe 20-60Hz controls remain unlocked."
  );
  setNodeTitle(
    el.devDebugStatus,
    "DEV mode exposes unsafe overclock routes and is intended only for controlled test environments."
  );
  setNodeTitle(el.devToolRuntimeBtn, "Fetch /mods/runtime and show a quick runtime snapshot.");
  setNodeTitle(el.devToolConnectivityBtn, "Fetch /fixtures/connectivity for quick fixture health checks.");
  setNodeTitle(el.devToolHooksBtn, "Fetch /mods/hooks to inspect loaded hook maps.");
  setNodeTitle(el.devToolTiersBtn, "Fetch /rave/overclock/tiers to inspect safe/dev tier availability.");
  setNodeTitle(el.devToolsStatus, "Last dev tool execution status.");
  setNodeTitle(el.devToolsDump, "Latest JSON response from dev tools.");
  setNodeTitle(el.midiTabToggleBtn, "Show or hide MIDI tab when no MIDI device is detected.");
  setNodeTitle(el.midiCogStatus, "Current MIDI detection + tab visibility policy.");
  setNodeTitle(el.devOcAckInput, "Comical destructive overclock confirmation phrase input.");
  setNodeTitle(el.devOcAckConfirmBtn, "Arm unsafe overclock if phrase matches exactly.");
  setNodeTitle(el.devOcAckCancelBtn, "Cancel unsafe overclock arming.");
  setNodeTitle(
    el.metaAutoOnBtn,
    "Enable Meta Auto. It infers live style from audio metrics and controls profile/reactivity/Hz."
  );
  setNodeTitle(
    el.metaAutoOffBtn,
    "Disable Meta Auto and return to manual controls. Manual profile/reactivity/palette/overclock selections also disable Meta Auto."
  );
  setNodeTitle(
    el.metaAutoTrackerAutoBtn,
    "Meta Auto-only dominant-factor auto mode. When ON, the engine picks dominant factors from enabled candidate toggles in real time."
  );
  setNodeTitle(
    el.metaAutoTrackerCandidatesBtn,
    "Generate beneficial dominant-factor candidates from current song telemetry and enable tracker-auto if needed."
  );
  setNodeTitle(
    el.metaAutoHueWizBaselineBlendBtn,
    "Hard toggle for baseline+drums dominant-factor candidate in Meta Auto. OFF excludes it from selection; ON allows it."
  );
  setNodeTitle(
    el.metaAutoTrackerPeaksBtn,
    "Hard toggle for peaks dominant-factor candidate in Meta Auto. OFF excludes it from selection; ON allows it."
  );
  setNodeTitle(
    el.metaAutoTrackerTransientsBtn,
    "Hard toggle for transient dominant-factor candidate in Meta Auto. OFF excludes it from selection; ON allows it."
  );
  setNodeTitle(
    el.metaAutoTrackerFluxBtn,
    "Hard toggle for flux dominant-factor candidate in Meta Auto. OFF excludes it from selection; ON allows it."
  );
  setNodeTitle(
    el.metaAutoHueWizBaselineBlendStat,
    "Meta Auto-only dominant-factor status and mode. This does not modify manual/non-meta behavior."
  );
  setNodeTitle(
    el.ocAutoBtn,
    "Auto-tune overclock Hz from live audio only. This does not change Meta profile/reactivity."
  );
  setNodeTitle(el.aResetDefaultsBtn, "Restore audio controls to defaults and apply immediately.");
  setNodeTitle(el.aOptionalToolsBanner, "Optional app-isolation tool status and install guidance.");
  setNodeTitle(el.aOptionalToolsInfoBtn, "Show simple install instructions for optional audio tools.");
  setNodeTitle(el.aOptionalToolsDismissBtn, "Hide this optional-tools banner.");
  setNodeTitle(el.aIsoSimpleMode, "Hide advanced app-isolation controls for easier setup.");
  setNodeTitle(el.aAppsShowAll, "Show every running process, not just likely audio-capable apps.");
  setNodeTitle(el.aAppsFilterHint, "Current app list filtering mode and count.");
  setNodeTitle(el.reactDropEnabled, "Enable/disable drop-trigger behavior (off by default).");
  setNodeTitle(
    el.reactHardwareRateLimitsEnabled,
    "Recommended ON: clamp Hue/WiZ send rates to hardware-safe ranges. Turn off only for controlled testing."
  );
  setNodeTitle(
    el.reactSmartMatchEnabled,
    "Recommended: LIVE tab selections auto-pick per-brand compatible sources and keep Smart Mix available."
  );
  setNodeTitle(
    el.reactForceLockEnabled,
    "Force each brand to one source. Incompatible sources are locked unless FORCE MATCH OVERRIDE is enabled."
  );
  setNodeTitle(
    el.reactForceMatchOverride,
    "Allow forced sources even when they do not match current LIVE compatibility profile."
  );
  setNodeTitle(el.reactCompatSummary, "Current LIVE compatibility + lock policy summary.");
  setNodeTitle(el.reactMapApplyBtn, "Save per-brand audio source routing map.");
  setNodeTitle(el.reactMapResetBtn, "Reset per-brand audio source routing map to defaults.");
  setNodeTitle(el.reactMapStatus, "Current audio reactivity routing summary.");
  setNodeTitle(el.ocDev20Btn, "Unsafe manual overclock 20Hz.");
  setNodeTitle(el.ocDev30Btn, "Unsafe manual overclock 30Hz.");
  setNodeTitle(el.ocDev40Btn, "Unsafe manual overclock 40Hz.");
  setNodeTitle(el.ocDev50Btn, "Unsafe manual overclock 50Hz.");
  setNodeTitle(el.ocDev60Btn, "Unsafe manual overclock 60Hz.");
  setNodeTitle(el.master, "Overall output scaling multiplier.");
  setNodeTitle(el.masterInlineResetBtn, "Reset MASTER to default.");
  setNodeTitle(el.flowIntensity, "Flow animation intensity multiplier for flow behavior.");
  setNodeTitle(el.flowResetBtn, "Reset FLOW INTENSITY back to default (1.00x).");
  setNodeTitle(el.sceneSyncOnBtn, "Link WiZ scene selection to Hue scene behavior by default.");
  setNodeTitle(el.sceneSyncOffBtn, "Run WiZ scene selection independently from Hue.");
  setNodeTitle(el.sceneSyncStat, "Current Hue/WiZ scene link strategy.");
  setNodeTitle(el.dropIntensity, "How hard drop events hit visuals.");
  setNodeTitle(el.dropInlineResetBtn, "Reset DROP IMPACT to default.");
  setNodeTitle(el.reactorResetBtn, "Reset both MASTER and DROP IMPACT to defaults.");
  setNodeTitle(
    el.reactorRiskNotice,
    "High MASTER and DROP values can reduce quality and increase instability, especially with high OVERCLOCK."
  );
  setNodeTitle(el.colorPrefixHue, "Quick setup: Hue prefix token for /color (example: /color hue red). Leave blank to disable.");
  setNodeTitle(el.colorPrefixWiz, "Quick setup: WiZ prefix token for /color (example: /color wiz blue). Leave blank to disable.");
  setNodeTitle(el.colorPrefixDefaultTarget, "Where unprefixed /color commands are sent.");
  setNodeTitle(
    el.colorPrefixOther,
    "Optional prefix for mod-brand Twitch fixtures. Enabled only when mod brands are available."
  );
  setNodeTitle(
    el.colorPrefixFixtureMap,
    "Advanced rule list. One line per rule: fixtureId=prefix. These override brand prefixes."
  );
  setNodeTitle(el.colorRaveOffEnabled, "Enable automatic RAVE OFF end-color profile.");
  setNodeTitle(el.colorRaveOffDefault, "Default /color command for RAVE OFF when no override matches.");
  setNodeTitle(
    el.colorRaveOffGroupMap,
    "Advanced group rules. One line per rule: key=command where key is hue, wiz, hue:zone, or wiz:zone."
  );
  setNodeTitle(
    el.colorRaveOffFixtureMap,
    "Advanced fixture rules. One line per rule: fixtureId=command. Fixture rules override group/default."
  );
  setNodeTitle(el.colorPrefixSaveBtn, "Save all Twitch color routing settings on this panel.");
  setNodeTitle(el.colorPrefixResetBtn, "Reset Twitch color routing settings to defaults.");
  setNodeTitle(el.modUiSelect, "Choose a loaded mod UI package.");
  setNodeTitle(el.modUiRefreshBtn, "Refresh UI catalog from mod loader routes.");
  setNodeTitle(el.modUiReloadBtn, "Reload selected mod UI frame.");
  setNodeTitle(el.modUiOpenBtn, "Open selected mod UI in a separate browser tab.");
  setNodeTitle(el.modUiStatus, "Current status for mod UI catalog and selected host frame.");
  setNodeTitle(el.modUiFrame, "Sandboxed mod UI frame.");
  setNodeTitle(el.customFixtureSelect, "Custom-routed fixtures from both Hue and WiZ brands.");
  setNodeTitle(el.customFixtureSyncBtn, "Use selected custom fixture as active device control target.");
  setNodeTitle(el.modDropZone, "Drop a mod folder here to import directly.");
  setNodeTitle(el.modImportStatus, "Current drag/drop import status.");
  setNodeTitle(el.modImportBrowseBtn, "Pick a mod folder from disk and import it.");
  setNodeTitle(el.modImportOverwrite, "Replace existing mod files when mod id already exists.");
  setNodeTitle(el.modImportEnable, "Automatically enable imported mod and apply hotswap.");
  setNodeTitle(el.modImportPicker, "Folder picker for mod import.");
  setNodeTitle(el.moddingReadmeBtn, "Open formatted modding developer docs in a separate page.");
  setNodeTitle(el.systemStartTab, "Default tab to open when this UI loads.");
  setNodeTitle(el.systemConfirmActions, "Require confirms for panic/reload/stop actions.");
  setNodeTitle(el.systemPollingMode, "Pause or resume automatic telemetry polling.");
  setNodeTitle(el.systemAutoLaunchBrowser, "Enable/disable browser auto-launch when the server starts.");
  setNodeTitle(
    el.systemUnsafeSensitiveLogs,
    "Dangerous DEV option: disable server-side redaction and allow sensitive credentials/ids/tokens to appear in logs."
  );
  setNodeTitle(el.systemSettingsSaveBtn, "Persist local settings plus server browser-launch and log-redaction settings.");
  setNodeTitle(el.systemSettingsResetBtn, "Reset system settings back to defaults.");
  setNodeTitle(el.systemPollNowBtn, "Run one immediate telemetry/config poll.");
  setNodeTitle(el.systemClearCacheBtn, "Clear UI local/session/cache memory and reload this page.");
  setNodeTitle(el.systemSettingsStatus, "Current saved system settings summary.");
  setNodeTitle(el.fxBridgeIpShowBtn, "Reveal/hide Hue bridge IP after warning confirmation.");
  setNodeTitle(el.fxUsernameShowBtn, "Reveal/hide Hue username/app key after warning confirmation.");
  setNodeTitle(el.fxClientKeyShowBtn, "Reveal/hide Hue client key after warning confirmation.");
  setNodeTitle(el.fxWizIpShowBtn, "Reveal/hide WiZ IP after warning confirmation.");
  setNodeTitle(el.midiModuleStatus, "Whether Node MIDI module is available.");
  setNodeTitle(el.midiRuntimeStatus, "MIDI runtime connection status.");
  setNodeTitle(el.midiActivePort, "Currently opened MIDI input port.");
  setNodeTitle(el.midiLearnStatus, "Current MIDI learn target and timeout status.");
  setNodeTitle(el.midiLastEvent, "Most recent MIDI packet observed by runtime.");
  setNodeTitle(el.midiLastAction, "Most recent engine action triggered from MIDI.");
  setNodeTitle(el.midiEnabled, "Enable or disable MIDI input handling.");
  setNodeTitle(el.midiVelocityThreshold, "Default minimum value threshold for new bindings.");
  setNodeTitle(el.midiPortSelect, "Preferred MIDI input port. AUTO uses first available/match.");
  setNodeTitle(el.midiDeviceMatch, "Optional case-insensitive port-name contains matcher.");
  setNodeTitle(el.midiRefreshBtn, "Rescan MIDI ports and reconnect runtime.");
  setNodeTitle(el.midiSaveCfgBtn, "Save MIDI config and reconnect if needed.");
  setNodeTitle(el.midiLearnAction, "Action that learn mode will map to next MIDI input.");
  setNodeTitle(el.midiLearnArmBtn, "Arm learn mode for selected action.");
  setNodeTitle(el.midiLearnCancelBtn, "Cancel active learn mode.");
  setNodeTitle(el.midiTriggerBtn, "Trigger selected action directly for testing.");
  setNodeTitle(el.midiBindingAction, "Action whose binding you want to inspect or edit.");
  setNodeTitle(el.midiBindingType, "Binding message type.");
  setNodeTitle(el.midiBindingNumber, "MIDI note/CC number (0-127).");
  setNodeTitle(el.midiBindingChannel, "Optional MIDI channel filter (1-16). Leave blank for any.");
  setNodeTitle(el.midiBindingMinValue, "Minimum value required to trigger action (0-127).");
  setNodeTitle(el.midiBindingSaveBtn, "Save/update binding for selected action.");
  setNodeTitle(el.midiBindingClearBtn, "Remove binding for selected action.");
  setNodeTitle(el.midiBindingResetBtn, "Restore default DROP + OVERCLOCK bindings.");
  setNodeTitle(el.midiBindingsDump, "Current MIDI config and action bindings snapshot.");

  const autoProfileTips = {
    reactive: "Fastest confirms/holds for punchy behavior and rapid scene changes.",
    balanced: "Middle-ground timing and hysteresis for general use.",
    cinematic: "Longest holds/confirms and strongest hysteresis for smoother output."
  };
  autoProfileButtons.forEach(btn => {
    const key = String(btn.dataset.autoProfile || "");
    setNodeTitle(btn, autoProfileTips[key] || "Set automatic profile behavior.");
  });

  const reactTips = {
    balanced: "Neutral detection and pulse thresholds.",
    aggressive: "Lower pulse gates and higher motion gain for stronger hits.",
    precision: "Higher gates and stricter trend checks for calmer, cleaner output."
  };
  audioReactivityButtons.forEach(btn => {
    const key = String(btn.dataset.audioReactivity || "");
    setNodeTitle(btn, reactTips[key] || "Set audio reactivity preset.");
  });

  sceneButtons.forEach(btn => {
    const key = String(btn.dataset.scene || "").toLowerCase();
    if (key === "auto") setNodeTitle(btn, "Auto-select scene based on telemetry.");
    else if (key === "flow") setNodeTitle(btn, "Lock scene to a fixed flow variant (not rotating).");
    else setNodeTitle(btn, `Lock scene to ${key}.`);
  });

  paletteCountButtons.forEach(btn => {
    const count = Number(btn.dataset.paletteCount || 3);
    setNodeTitle(btn, `Use ${count} color${count === 1 ? "" : "s"} per selected family.`);
  });
  paletteVividnessButtons.forEach(btn => {
    const level = Number(btn.dataset.paletteVividness || 2);
    setNodeTitle(btn, `Set palette vividness level to ${level}. Higher levels increase saturation and separation.`);
  });
  palettePresetButtons.forEach(btn => {
    const key = String(btn.dataset.palettePreset || "").trim().toLowerCase();
    const preset = PALETTE_PRESETS[key];
    if (!preset) {
      setNodeTitle(btn, "Apply quick palette preset.");
      return;
    }
    const families = preset.families.map(name => String(name || "").toUpperCase()).join("+");
    const countText = Number.isFinite(Number(preset.colorsPerFamily))
      ? `x${Number(preset.colorsPerFamily)}`
      : "x current";
    setNodeTitle(btn, `Apply ${families} ${countText}. Keeps current ORDERED/DISORDER mode.`);
  });
  getPaletteFamilyButtons().forEach(btn => {
    const key = String(btn.dataset.paletteFamily || "").toUpperCase();
    setNodeTitle(btn, `Toggle ${key} in the active sequence.`);
  });
  paletteDisorderButtons.forEach(btn => {
    const disorder = String(btn.dataset.paletteDisorder || "") === "true";
    setNodeTitle(
      btn,
      disorder
        ? "Disorder mode: play colors/families out of order."
        : "Ordered mode: play selected families in fixed sequence."
    );
  });
  paletteBrightnessModeButtons.forEach(btn => {
    const mode = String(btn.dataset.paletteBrightnessMode || "").trim().toLowerCase();
    setNodeTitle(
      btn,
      mode === "test"
        ? "TEST mode: brightness follows palette color movement + audio activity."
        : "LEGACY mode: keep current brightness behavior."
    );
  });
  setNodeTitle(el.paletteDisorderAggression, "How aggressively disorder jumps between colors/families.");
  setNodeTitle(el.paletteDisorderAggressionResetBtn, "Reset disorder aggression to default.");
  setNodeTitle(el.paletteBrightnessFollowAmount, "Strength of TEST brightness-follow behavior (0.00x to 2.00x).");
}

function detectLimiterPreset(config = {}) {
  const threshold = Number(config.limiterThreshold);
  const knee = Number(config.limiterKnee);
  if (!Number.isFinite(threshold) || !Number.isFinite(knee)) return "balanced";

  let best = "balanced";
  let bestDist = Number.POSITIVE_INFINITY;
  for (const [name, p] of Object.entries(LIMITER_PRESETS)) {
    const dist = Math.abs(threshold - p.limiterThreshold) + Math.abs(knee - p.limiterKnee);
    if (dist < bestDist) {
      bestDist = dist;
      best = name;
    }
  }
  return bestDist <= 0.035 ? best : "custom";
}

function setBadge(node, state, text) {
  if (!node) return;
  const nextState = String(state || "").trim().toLowerCase();
  const nextText = String(text || "");
  const stateChanged = !node.classList.contains(nextState);
  const textChanged = node.textContent !== nextText;
  if (!stateChanged && !textChanged) return;
  node.classList.remove("ok", "warn", "bad");
  if (nextState) node.classList.add(nextState);
  node.textContent = nextText;
}

const LIVE_PROFILE_DEFAULT = Object.freeze({
  autoProfile: "balanced",
  audioReactivityPreset: "balanced",
  sceneLock: "auto",
  flowIntensity: 1,
  overclockAutoEnabled: false,
  overclockLevel: 2,
  metaAutoEnabled: false
});
const LIVE_PROFILE_ALLOWED_AUTO = new Set(["reactive", "balanced", "cinematic"]);
const LIVE_PROFILE_ALLOWED_REACTIVITY = new Set(["balanced", "aggressive", "precision"]);
const LIVE_PROFILE_ALLOWED_SCENES = new Set(["auto", "idle_soft", "flow", "pulse_strobe"]);
const LIVE_PROFILE_OVERCLOCK_ROUTE_BY_LEVEL = Object.freeze({
  0: "/rave/overclock/off",
  1: "/rave/overclock/on",
  2: "/rave/overclock/turbo/on",
  3: "/rave/overclock/ultra/on",
  4: "/rave/overclock/extreme/on",
  5: "/rave/overclock/insane/on",
  6: "/rave/overclock/hyper/on",
  7: "/rave/overclock/ludicrous/on"
});
const LIVE_PROFILE_SELECT_CUSTOM_VALUE = "__custom__";
let liveProfileStatusResetTimer = null;

function normalizeLiveProfileName(value, fallback = "default") {
  const raw = String(value || "").trim().toLowerCase();
  const compact = raw.replace(/\s+/g, " ");
  if (/^[a-z0-9][a-z0-9 _-]{0,31}$/.test(compact)) return compact;
  return String(fallback || "default").trim().toLowerCase() || "default";
}

function normalizeLiveProfileSnapshot(raw = {}, fallback = LIVE_PROFILE_DEFAULT) {
  const source = raw && typeof raw === "object" ? raw : {};
  const base = fallback && typeof fallback === "object" ? fallback : LIVE_PROFILE_DEFAULT;
  const autoProfileRaw = String(source.autoProfile || base.autoProfile || "balanced").trim().toLowerCase();
  const audioPresetRaw = String(source.audioReactivityPreset || base.audioReactivityPreset || "balanced").trim().toLowerCase();
  const sceneRaw = String(source.sceneLock || base.sceneLock || "auto").trim().toLowerCase();
  const overclockLevelRaw = Number(source.overclockLevel);
  const overclockLevelBase = Number(base.overclockLevel);
  const overclockLevel = Number.isFinite(overclockLevelRaw)
    ? Math.max(0, Math.min(7, Math.round(overclockLevelRaw)))
    : (Number.isFinite(overclockLevelBase) ? Math.max(0, Math.min(7, Math.round(overclockLevelBase))) : 2);
  let overclockAutoEnabled = parseBooleanUi(
    source.overclockAutoEnabled,
    parseBooleanUi(base.overclockAutoEnabled, false)
  ) === true;
  const metaAutoEnabled = parseBooleanUi(
    source.metaAutoEnabled,
    parseBooleanUi(base.metaAutoEnabled, false)
  ) === true;
  if (metaAutoEnabled && overclockAutoEnabled) {
    overclockAutoEnabled = false;
  }
  return {
    autoProfile: LIVE_PROFILE_ALLOWED_AUTO.has(autoProfileRaw) ? autoProfileRaw : "balanced",
    audioReactivityPreset: LIVE_PROFILE_ALLOWED_REACTIVITY.has(audioPresetRaw) ? audioPresetRaw : "balanced",
    sceneLock: LIVE_PROFILE_ALLOWED_SCENES.has(sceneRaw) ? sceneRaw : "auto",
    flowIntensity: clampFlowIntensity(source.flowIntensity ?? base.flowIntensity ?? 1),
    overclockAutoEnabled,
    overclockLevel,
    metaAutoEnabled
  };
}

function readLiveProfileStore() {
  const empty = { version: 1, profiles: {} };
  try {
    const raw = String(localStorage.getItem(LIVE_PROFILE_STORE_KEY) || "").trim();
    if (!raw) return empty;
    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== "object" || Array.isArray(parsed)) return empty;
    const profilesRaw = parsed.profiles && typeof parsed.profiles === "object" && !Array.isArray(parsed.profiles)
      ? parsed.profiles
      : {};
    const profiles = {};
    for (const [rawName, payload] of Object.entries(profilesRaw)) {
      const name = normalizeLiveProfileName(rawName, "");
      if (!name) continue;
      const snapshotRaw = payload && typeof payload === "object" && !Array.isArray(payload)
        ? payload.snapshot
        : null;
      const snapshot = normalizeLiveProfileSnapshot(snapshotRaw || payload || {}, LIVE_PROFILE_DEFAULT);
      const savedAt = Number(payload?.savedAt);
      profiles[name] = {
        savedAt: Number.isFinite(savedAt) ? savedAt : Date.now(),
        snapshot
      };
      if (Object.keys(profiles).length >= 24) break;
    }
    return { version: 1, profiles };
  } catch {
    return empty;
  }
}

function writeLiveProfileStore(store) {
  const safeStore = store && typeof store === "object" ? store : {};
  const profilesRaw = safeStore.profiles && typeof safeStore.profiles === "object" ? safeStore.profiles : {};
  const profiles = {};
  for (const [rawName, payload] of Object.entries(profilesRaw)) {
    const name = normalizeLiveProfileName(rawName, "");
    if (!name) continue;
    const snapshot = normalizeLiveProfileSnapshot(payload?.snapshot || payload || {}, LIVE_PROFILE_DEFAULT);
    const savedAt = Number(payload?.savedAt);
    profiles[name] = {
      savedAt: Number.isFinite(savedAt) ? savedAt : Date.now(),
      snapshot
    };
    if (Object.keys(profiles).length >= 24) break;
  }
  const safe = { version: 1, profiles };
  localStorage.setItem(LIVE_PROFILE_STORE_KEY, JSON.stringify(safe));
  return safe;
}

function getLiveProfileStoreEntriesSorted(store = null) {
  const source = store && typeof store === "object" ? store : readLiveProfileStore();
  const profiles = source.profiles && typeof source.profiles === "object" ? source.profiles : {};
  return Object.entries(profiles)
    .map(([name, entry]) => {
      const safeName = normalizeLiveProfileName(name, "");
      const savedAt = Number(entry?.savedAt);
      return {
        name: safeName,
        savedAt: Number.isFinite(savedAt) ? savedAt : 0
      };
    })
    .filter(entry => Boolean(entry.name))
    .sort((a, b) => {
      const byTime = b.savedAt - a.savedAt;
      if (byTime !== 0) return byTime;
      return String(a.name).localeCompare(String(b.name));
    });
}

function syncLiveProfileSelectOptions(nameHint = null) {
  if (!el.liveProfileSelect) return;
  const currentName = normalizeLiveProfileName(nameHint || resolveCurrentLiveProfileName(), "default");
  const store = readLiveProfileStore();
  const entries = getLiveProfileStoreEntriesSorted(store);

  const options = [
    { value: LIVE_PROFILE_SELECT_CUSTOM_VALUE, label: "CUSTOM / TYPE NAME" },
    ...entries.map(entry => {
      const timeText = formatLiveProfileSavedAt(entry.savedAt);
      const suffix = timeText ? ` (${timeText})` : "";
      return {
        value: entry.name,
        label: `${entry.name}${suffix}`
      };
    })
  ];

  el.liveProfileSelect.innerHTML = options
    .map(opt => `<option value="${escapeHtmlUi(opt.value)}">${escapeHtmlUi(opt.label)}</option>`)
    .join("");

  const hasCurrent = entries.some(entry => entry.name === currentName);
  el.liveProfileSelect.value = hasCurrent ? currentName : LIVE_PROFILE_SELECT_CUSTOM_VALUE;
  if (el.liveProfileDeleteBtn) {
    const selectedName = normalizeLiveProfileName(el.liveProfileSelect.value, "");
    const canDeleteSelected = entries.some(entry => entry.name === selectedName);
    el.liveProfileDeleteBtn.disabled = !(canDeleteSelected || hasCurrent);
  }
}

function resolveLiveProfileSelectedName() {
  if (!el.liveProfileSelect) return "";
  return normalizeLiveProfileName(el.liveProfileSelect.value, "");
}

function resolveLiveProfileActionName() {
  const selected = resolveLiveProfileSelectedName();
  if (selected) return selected;
  return resolveCurrentLiveProfileName();
}

function clearLiveProfileStatusResetTimer() {
  if (!liveProfileStatusResetTimer) return;
  clearTimeout(liveProfileStatusResetTimer);
  liveProfileStatusResetTimer = null;
}

function scheduleLiveProfileStatusReset(name, delayMs = 3600) {
  clearLiveProfileStatusResetTimer();
  const waitMs = Math.max(1200, Number(delayMs) || 3600);
  liveProfileStatusResetTimer = setTimeout(() => {
    refreshLiveProfileStatus(name);
  }, waitMs);
}

function formatLiveProfileSnapshotSummary(snapshot = {}) {
  const safe = normalizeLiveProfileSnapshot(snapshot, LIVE_PROFILE_DEFAULT);
  const scene = safe.sceneLock === "auto" ? "SCENE AUTO" : `SCENE ${String(safe.sceneLock || "").toUpperCase()}`;
  const hz = safe.overclockAutoEnabled
    ? "AUTO HZ"
    : `${Math.max(0, Math.min(7, Math.round(Number(safe.overclockLevel) || 0)))} STEP HZ`;
  return [
    `AUTO ${String(safe.autoProfile || "balanced").toUpperCase()}`,
    `A-REACT ${String(safe.audioReactivityPreset || "balanced").toUpperCase()}`,
    scene,
    hz,
    `META ${safe.metaAutoEnabled ? "ON" : "OFF"}`
  ].join(" | ");
}

function pulseLiveProfileAppliedControls(snapshot = {}) {
  const safe = normalizeLiveProfileSnapshot(snapshot, LIVE_PROFILE_DEFAULT);
  const targets = [];
  const autoBtn = autoProfileButtons.find(btn => btn.dataset.autoProfile === safe.autoProfile);
  if (autoBtn) targets.push(autoBtn);
  const reactBtn = audioReactivityButtons.find(btn => btn.dataset.audioReactivity === safe.audioReactivityPreset);
  if (reactBtn) targets.push(reactBtn);
  const sceneBtn = sceneButtons.find(btn => btn.dataset.scene === safe.sceneLock);
  if (sceneBtn) targets.push(sceneBtn);

  if (safe.overclockAutoEnabled && el.ocAutoBtn) {
    targets.push(el.ocAutoBtn);
  } else {
    const overclockButtonsByLevel = {
      0: el.ocOffBtn,
      1: el.ocOnBtn,
      2: el.ocTurboBtn,
      3: el.ocUltraBtn,
      4: el.ocExtremeBtn,
      5: el.ocInsaneBtn,
      6: el.ocHyperBtn,
      7: el.ocLudicrousBtn
    };
    const level = Math.max(0, Math.min(7, Math.round(Number(safe.overclockLevel) || 0)));
    const targetBtn = overclockButtonsByLevel[level];
    if (targetBtn) targets.push(targetBtn);
  }

  if (safe.metaAutoEnabled && el.metaAutoOnBtn) {
    targets.push(el.metaAutoOnBtn);
  }
  if (!safe.metaAutoEnabled && el.metaAutoOffBtn) {
    targets.push(el.metaAutoOffBtn);
  }

  const uniqueTargets = [...new Set(targets.filter(Boolean))];
  for (const node of uniqueTargets) {
    node.classList.remove("profileAppliedPulse");
  }
  requestAnimationFrame(() => {
    for (const node of uniqueTargets) {
      node.classList.add("profileAppliedPulse");
    }
    setTimeout(() => {
      for (const node of uniqueTargets) {
        node.classList.remove("profileAppliedPulse");
      }
    }, 1000);
  });
}

function resolveCurrentLiveProfileName() {
  return normalizeLiveProfileName(
    el.liveProfileName?.value ||
      localStorage.getItem(LIVE_PROFILE_LAST_KEY) ||
      "default",
    "default"
  );
}

function setCurrentLiveProfileName(name) {
  const safe = normalizeLiveProfileName(name, "default");
  if (el.liveProfileName) el.liveProfileName.value = safe;
  localStorage.setItem(LIVE_PROFILE_LAST_KEY, safe);
  return safe;
}

function formatLiveProfileSavedAt(savedAt) {
  const ms = Number(savedAt);
  if (!Number.isFinite(ms) || ms <= 0) return "";
  try {
    return new Date(ms).toLocaleTimeString();
  } catch {
    return "";
  }
}

function refreshLiveProfileStatus(name = null, overrideText = "") {
  if (!el.liveProfileStat) return;
  const custom = String(overrideText || "").trim();
  if (custom) {
    el.liveProfileStat.textContent = custom;
    return;
  }
  const profileName = normalizeLiveProfileName(name || resolveCurrentLiveProfileName(), "default");
  const store = readLiveProfileStore();
  const entry = store.profiles[profileName];
  if (!entry) {
    el.liveProfileStat.textContent = `LIVE PROFILE: ${profileName} (unsaved)`;
    return;
  }
  const timeText = formatLiveProfileSavedAt(entry.savedAt);
  el.liveProfileStat.textContent = timeText
    ? `LIVE PROFILE: ${profileName} (saved ${timeText})`
    : `LIVE PROFILE: ${profileName} (saved)`;
}

function buildLiveProfileSnapshotFromUi() {
  return normalizeLiveProfileSnapshot({
    autoProfile: ui.autoProfile,
    audioReactivityPreset: ui.audioReactivityPreset,
    sceneLock: ui.sceneLock,
    flowIntensity: ui.flowIntensity,
    overclockAutoEnabled: ui.overclockAutoEnabled,
    overclockLevel: ui.overclockLevel,
    metaAutoEnabled: ui.metaAutoEnabled
  }, LIVE_PROFILE_DEFAULT);
}

async function applyLiveProfileSnapshot(snapshot = {}, options = {}) {
  const announce = options.announce !== false;
  const forcePoll = options.forcePoll === true;
  const pulse = options.pulse !== false;
  const next = normalizeLiveProfileSnapshot(snapshot, LIVE_PROFILE_DEFAULT);
  let ok = true;

  const autoHzOk = await setOverclockAutoEnabled(next.overclockAutoEnabled, { announce: false });
  if (!autoHzOk) ok = false;

  if (!next.overclockAutoEnabled) {
    const route = LIVE_PROFILE_OVERCLOCK_ROUTE_BY_LEVEL[next.overclockLevel] || LIVE_PROFILE_OVERCLOCK_ROUTE_BY_LEVEL[2];
    const overclockOk = await setOverclockPreset(next.overclockLevel, route, "");
    if (!overclockOk) ok = false;
  }

  const autoProfileOk = await api(`/rave/auto/profile?name=${encodeURIComponent(next.autoProfile)}`);
  if (autoProfileOk) {
    ui.autoProfile = next.autoProfile;
  } else {
    ok = false;
  }

  const reactOk = await api(`/rave/audio/reactivity?name=${encodeURIComponent(next.audioReactivityPreset)}`);
  if (reactOk) {
    ui.audioReactivityPreset = next.audioReactivityPreset;
  } else {
    ok = false;
  }

  const sceneOk = next.sceneLock === "auto"
    ? await api("/rave/scene/auto")
    : await api(`/rave/scene?name=${encodeURIComponent(next.sceneLock)}`);
  if (sceneOk) {
    ui.sceneLock = next.sceneLock;
  } else {
    ok = false;
  }

  ui.flowIntensity = next.flowIntensity;
  ui.flowIntensityInputUntil = Date.now() + 600;
  applyFlowIntensityUi();
  const flowOk = await commitFlowIntensity({ silent: true });
  if (!flowOk) ok = false;

  const metaResponse = await postJson(`/rave/meta/auto?enabled=${next.metaAutoEnabled ? "true" : "false"}`, {});
  if (metaResponse.ok && metaResponse.data) {
    ui.metaAutoEnabled = Boolean(metaResponse.data.enabled);
    ui.metaAutoReason = ui.metaAutoEnabled ? "enabled" : "off";
  } else {
    ok = false;
  }

  maybeApplySmartLiveReactivityPolicy("LIVE PROFILE LOAD");
  if (forcePoll) {
    try {
      await poll({ force: true });
    } catch {
      ok = false;
      sync();
    }
  } else {
    sync();
  }
  if (pulse) {
    pulseLiveProfileAppliedControls(buildLiveProfileSnapshotFromUi());
  }
  if (announce) {
    setBadge(el.health, ok ? "ok" : "warn", ok ? "LIVE PROFILE APPLIED" : "LIVE PROFILE APPLIED (PARTIAL)");
  }
  return ok;
}

function initLiveProfileControls() {
  const initialName = setCurrentLiveProfileName(resolveCurrentLiveProfileName());
  syncLiveProfileSelectOptions(initialName);
  refreshLiveProfileStatus(initialName);

  if (el.liveProfileName) {
    el.liveProfileName.addEventListener("change", () => {
      const name = setCurrentLiveProfileName(el.liveProfileName.value);
      syncLiveProfileSelectOptions(name);
      refreshLiveProfileStatus(name);
    });
    el.liveProfileName.addEventListener("blur", () => {
      const name = setCurrentLiveProfileName(el.liveProfileName.value);
      syncLiveProfileSelectOptions(name);
      refreshLiveProfileStatus(name);
    });
  }

  if (el.liveProfileSelect) {
    el.liveProfileSelect.addEventListener("change", () => {
      const selectedName = resolveLiveProfileSelectedName();
      if (!selectedName) {
        const typed = normalizeLiveProfileName(el.liveProfileName?.value, "");
        const store = readLiveProfileStore();
        if (el.liveProfileDeleteBtn) {
          el.liveProfileDeleteBtn.disabled = !typed || !store.profiles[typed];
        }
        refreshLiveProfileStatus(resolveCurrentLiveProfileName());
        return;
      }
      const name = setCurrentLiveProfileName(selectedName);
      syncLiveProfileSelectOptions(name);
      refreshLiveProfileStatus(name);
    });
  }

  if (el.liveProfileSaveBtn) {
    el.liveProfileSaveBtn.onclick = () => {
      const name = setCurrentLiveProfileName(resolveCurrentLiveProfileName());
      const store = readLiveProfileStore();
      const snapshot = buildLiveProfileSnapshotFromUi();
      store.profiles[name] = {
        savedAt: Date.now(),
        snapshot
      };
      writeLiveProfileStore(store);
      syncLiveProfileSelectOptions(name);
      refreshLiveProfileStatus(name, `LIVE PROFILE: ${name} saved | ${formatLiveProfileSnapshotSummary(snapshot)}`);
      scheduleLiveProfileStatusReset(name);
      setBadge(el.health, "ok", `LIVE PROFILE SAVED (${name.toUpperCase()})`);
    };
  }

  if (el.liveProfileLoadBtn) {
    el.liveProfileLoadBtn.onclick = async () => {
      const store = readLiveProfileStore();
      const name = setCurrentLiveProfileName(resolveLiveProfileActionName());
      const entry = store.profiles[name];
      if (!entry?.snapshot) {
        syncLiveProfileSelectOptions(name);
        refreshLiveProfileStatus(name, `LIVE PROFILE: ${name} not found`);
        scheduleLiveProfileStatusReset(name);
        setBadge(el.health, "warn", `LIVE PROFILE MISSING (${name.toUpperCase()})`);
        return;
      }
      const snapshot = normalizeLiveProfileSnapshot(entry.snapshot, LIVE_PROFILE_DEFAULT);
      const ok = await applyLiveProfileSnapshot(snapshot, { announce: false, forcePoll: true, pulse: true });
      syncLiveProfileSelectOptions(name);
      const summary = formatLiveProfileSnapshotSummary(snapshot);
      refreshLiveProfileStatus(name, ok
        ? `LIVE PROFILE: ${name} loaded | ${summary}`
        : `LIVE PROFILE: ${name} loaded (partial) | ${summary}`);
      scheduleLiveProfileStatusReset(name);
      setBadge(el.health, ok ? "ok" : "warn", ok ? `LIVE PROFILE LOADED (${name.toUpperCase()})` : `LIVE PROFILE PARTIAL (${name.toUpperCase()})`);
    };
  }

  if (el.liveProfileDeleteBtn) {
    el.liveProfileDeleteBtn.onclick = () => {
      const store = readLiveProfileStore();
      const selected = resolveLiveProfileSelectedName();
      const typed = normalizeLiveProfileName(resolveCurrentLiveProfileName(), "");
      const target = store.profiles[selected]
        ? selected
        : (store.profiles[typed] ? typed : "");
      if (!target) {
        const name = resolveCurrentLiveProfileName();
        syncLiveProfileSelectOptions(name);
        refreshLiveProfileStatus(name, `LIVE PROFILE: ${name} not saved`);
        scheduleLiveProfileStatusReset(name);
        setBadge(el.health, "warn", "NO SAVED PROFILE TO DELETE");
        return;
      }
      const confirmDelete = window.confirm(`Delete LIVE profile "${target}" from local storage?`);
      if (!confirmDelete) return;
      delete store.profiles[target];
      const written = writeLiveProfileStore(store);
      const current = resolveCurrentLiveProfileName();
      const entries = getLiveProfileStoreEntriesSorted(written);
      const nextName = current === target
        ? (entries[0]?.name || "default")
        : current;
      setCurrentLiveProfileName(nextName);
      syncLiveProfileSelectOptions(nextName);
      refreshLiveProfileStatus(nextName, `LIVE PROFILE: ${target} deleted`);
      scheduleLiveProfileStatusReset(nextName);
      setBadge(el.health, "ok", `LIVE PROFILE DELETED (${target.toUpperCase()})`);
    };
  }

  if (el.liveProfileResetBtn) {
    el.liveProfileResetBtn.onclick = async () => {
      const ok = await applyLiveProfileSnapshot(LIVE_PROFILE_DEFAULT, { announce: false, forcePoll: true, pulse: true });
      const name = resolveCurrentLiveProfileName();
      const summary = formatLiveProfileSnapshotSummary(LIVE_PROFILE_DEFAULT);
      syncLiveProfileSelectOptions(name);
      refreshLiveProfileStatus(resolveCurrentLiveProfileName(), ok
        ? `LIVE PROFILE: defaults loaded | ${summary}`
        : `LIVE PROFILE: defaults loaded (partial) | ${summary}`);
      scheduleLiveProfileStatusReset(name);
      setBadge(el.health, ok ? "ok" : "warn", ok ? "LIVE PROFILE DEFAULTS APPLIED" : "LIVE PROFILE DEFAULTS PARTIAL");
    };
  }
}

const PALETTE_FAMILY_ORDER = Object.freeze(["red", "green", "blue"]);
const PALETTE_FAMILY_ALIASES = Object.freeze({
  magenta: "red",
  purple: "red",
  pink: "red",
  amber: "green",
  yellow: "green",
  lime: "green",
  cyan: "blue",
  aqua: "blue",
  teal: "blue"
});
const PALETTE_COLOR_COUNT_OPTIONS = Object.freeze([1, 3, 5, 8, 12]);
const PALETTE_SUPPORTED_BRANDS = Object.freeze(["hue", "wiz"]);
const PALETTE_BRAND_LABELS = Object.freeze({
  hue: "HUE",
  wiz: "WIZ"
});
const PALETTE_ALL_FIXTURES_VALUE = "__all__";
const PALETTE_CYCLE_MODE_ORDER = Object.freeze([
  "on_trigger",
  "timed_cycle",
  "reactive_shift",
  "spectrum_mapper"
]);
const PALETTE_CYCLE_MODE_LABELS = Object.freeze({
  on_trigger: "ON TRIGGER",
  timed_cycle: "TIMED CYCLE",
  reactive_shift: "REACTIVE SHIFT",
  spectrum_mapper: "SPECTRUM MAPPER"
});
const PALETTE_BRIGHTNESS_MODE_ORDER = Object.freeze(["legacy", "test"]);
const PALETTE_BRIGHTNESS_MODE_LABELS = Object.freeze({
  legacy: "LEGACY",
  test: "TEST FOLLOW"
});
const PALETTE_SPECTRUM_MAP_MODE_ORDER = Object.freeze(["auto", "manual"]);
const PALETTE_AUDIO_FEATURE_KEYS = Object.freeze([
  "lows",
  "mids",
  "highs",
  "rms",
  "energy",
  "flux",
  "peaks",
  "transients",
  "beat"
]);
const PALETTE_AUDIO_FEATURE_LABELS = Object.freeze({
  lows: "LOWS",
  mids: "MIDS",
  highs: "HIGHS",
  rms: "RMS",
  energy: "ENERGY",
  flux: "FLUX",
  peaks: "PEAKS",
  transients: "TRANSIENTS",
  beat: "BEAT"
});
const PALETTE_DEFAULT_SPECTRUM_FEATURE_MAP = Object.freeze([
  "lows",
  "mids",
  "highs",
  "rms",
  "flux"
]);
const PALETTE_TIMED_INTERVAL_MIN_SEC = 2;
const PALETTE_TIMED_INTERVAL_MAX_SEC = 60;
const PALETTE_BEAT_LOCK_GRACE_MIN_SEC = 0;
const PALETTE_BEAT_LOCK_GRACE_MAX_SEC = 8;
const PALETTE_REACTIVE_MARGIN_MIN = 5;
const PALETTE_REACTIVE_MARGIN_MAX = 100;
const PALETTE_BRIGHTNESS_FOLLOW_AMOUNT_MIN = 0;
const PALETTE_BRIGHTNESS_FOLLOW_AMOUNT_MAX = 2;
const PALETTE_VIVIDNESS_LEVEL_OPTIONS = Object.freeze([0, 1, 2, 3, 4]);
const PALETTE_VIVIDNESS_LABELS = Object.freeze({
  0: "SOFT",
  1: "BALANCED",
  2: "HIGH",
  3: "ULTRA",
  4: "MAX"
});

function normalizePaletteControlScopeUi(value, fallback = "global") {
  const mode = String(value || "").trim().toLowerCase();
  if (mode === "custom") return "custom";
  if (mode === "global") return "global";
  const fallbackMode = String(fallback || "").trim().toLowerCase();
  return fallbackMode === "custom" ? "custom" : "global";
}

function normalizePaletteCustomBrandMemoryUi(value, fallback = "hue") {
  const brand = String(value || "").trim().toLowerCase();
  if (PALETTE_SUPPORTED_BRANDS.includes(brand)) return brand;
  const fallbackBrand = String(fallback || "").trim().toLowerCase();
  return PALETTE_SUPPORTED_BRANDS.includes(fallbackBrand) ? fallbackBrand : "hue";
}

function normalizePaletteFixtureSelectionByBrandMemory(value = null) {
  const base = {
    hue: PALETTE_ALL_FIXTURES_VALUE,
    wiz: PALETTE_ALL_FIXTURES_VALUE
  };
  const source = value && typeof value === "object" && !Array.isArray(value)
    ? value
    : {};
  for (const brand of PALETTE_SUPPORTED_BRANDS) {
    const raw = String(source[brand] || PALETTE_ALL_FIXTURES_VALUE).trim();
    base[brand] = raw || PALETTE_ALL_FIXTURES_VALUE;
  }
  return base;
}

function persistPaletteFixtureSelectionMemory() {
  try {
    const safe = normalizePaletteFixtureSelectionByBrandMemory(ui.paletteFixtureSelectionByBrand);
    ui.paletteFixtureSelectionByBrand = { ...safe };
    localStorage.setItem(PALETTE_FIXTURE_SELECTION_KEY, JSON.stringify(safe));
  } catch {}
}

ui.paletteFixtureSelectionByBrand = normalizePaletteFixtureSelectionByBrandMemory(
  ui.paletteFixtureSelectionByBrand
);
let paletteGlobalModeNoticeTimer = null;
const paletteBrandModeNoticeTimers = {
  hue: null,
  wiz: null
};
let paletteBrandMenusDeferredRenderTimer = null;
let paletteBrandMenusInteractionUntil = 0;

const PALETTE_PRESETS = Object.freeze({
  all_1: Object.freeze({
    id: "all_1",
    label: "ALL COLORS x1",
    families: Object.freeze(["red", "green", "blue"]),
    colorsPerFamily: 1
  }),
  all_3: Object.freeze({
    id: "all_3",
    label: "ALL COLORS x3",
    families: Object.freeze(["red", "green", "blue"]),
    colorsPerFamily: 3
  }),
  duo_cool: Object.freeze({
    id: "duo_cool",
    label: "DUO COOL",
    families: Object.freeze(["green", "blue"]),
    colorsPerFamily: null
  }),
  duo_warm: Object.freeze({
    id: "duo_warm",
    label: "DUO WARM",
    families: Object.freeze(["red", "green"]),
    colorsPerFamily: null
  })
});
const FIXTURE_METRIC_MODE_ORDER = Object.freeze(["manual", "meta_auto"]);
const FIXTURE_METRIC_KEYS = Object.freeze(["baseline", "peaks", "transients", "flux"]);
const FIXTURE_METRIC_LABELS = Object.freeze({
  baseline: "BASELINE",
  peaks: "PEAKS",
  transients: "TRANSIENTS",
  flux: "FLUX"
});
const FIXTURE_METRIC_CONFIG_DEFAULT = Object.freeze({
  mode: "manual",
  metric: "baseline",
  metaAutoFlip: false,
  harmonySize: 1,
  maxHz: null
});
const FIXTURE_METRIC_HARMONY_MIN = 1;
const FIXTURE_METRIC_HARMONY_MAX = 8;
const FIXTURE_METRIC_MAX_HZ_MIN = 0.5;
const FIXTURE_METRIC_MAX_HZ_MAX = 24;
const FIXTURE_METRIC_MAX_HZ_DEFAULT = 8;
const FIXTURE_METRIC_MAX_HZ_STEP = 0.1;

function parseBooleanUi(value, fallback = false) {
  if (typeof value === "boolean") return value;
  if (value === 1 || value === "1") return true;
  if (value === 0 || value === "0") return false;
  if (typeof value === "string") {
    const raw = value.trim().toLowerCase();
    if (raw === "true" || raw === "on" || raw === "yes") return true;
    if (raw === "false" || raw === "off" || raw === "no") return false;
  }
  return fallback;
}

function normalizePaletteBrandUi(value) {
  const brand = String(value || "").trim().toLowerCase();
  return PALETTE_SUPPORTED_BRANDS.includes(brand) ? brand : "";
}

function paletteFamiliesSetEqualUi(a, b) {
  const aa = normalizePaletteFamiliesUi(a, ["red", "green", "blue"]);
  const bb = normalizePaletteFamiliesUi(b, ["red", "green", "blue"]);
  if (aa.length !== bb.length) return false;
  return aa.every(name => bb.includes(name));
}

function isPalettePresetActiveUi(presetId) {
  const key = String(presetId || "").trim().toLowerCase();
  const preset = PALETTE_PRESETS[key];
  if (!preset) return false;
  if (!paletteFamiliesSetEqualUi(ui.paletteFamilies, preset.families)) return false;
  if (Number.isFinite(Number(preset.colorsPerFamily))) {
    return normalizePaletteColorCountUi(ui.paletteColorsPerFamily, 3) === Number(preset.colorsPerFamily);
  }
  return true;
}

function normalizePaletteFamiliesUi(value, fallback = ["red", "green", "blue"]) {
  const list = Array.isArray(value)
    ? value
    : String(value || "")
      .split(",")
      .map(item => item.trim())
      .filter(Boolean);
  const out = [];
  for (const raw of list) {
    const key = String(raw || "").trim().toLowerCase();
    const mapped = PALETTE_FAMILY_ALIASES[key] || key;
    if (!PALETTE_FAMILY_ORDER.includes(mapped)) continue;
    if (out.includes(mapped)) continue;
    out.push(mapped);
  }
  if (out.length) return out;
  return Array.isArray(fallback) && fallback.length
    ? normalizePaletteFamiliesUi(fallback, PALETTE_FAMILY_ORDER)
    : ["red"];
}

function normalizePaletteColorCountUi(value, fallback = 3) {
  const parsed = Number(value);
  if (PALETTE_COLOR_COUNT_OPTIONS.includes(parsed)) return parsed;
  return fallback;
}

function normalizePaletteDisorderAggressionUi(value, fallback = 0.35) {
  const parsed = Number(value);
  if (!Number.isFinite(parsed)) return fallback;
  const normalized = parsed > 1 ? (parsed / 100) : parsed;
  return clampNumber(normalized, 0, 1, fallback);
}

function normalizePaletteCycleModeUi(value, fallback = "on_trigger") {
  const mode = String(value || "").trim().toLowerCase();
  if (PALETTE_CYCLE_MODE_ORDER.includes(mode)) return mode;
  const fallbackMode = String(fallback || "").trim().toLowerCase();
  return PALETTE_CYCLE_MODE_ORDER.includes(fallbackMode) ? fallbackMode : "on_trigger";
}

function normalizePaletteTimedIntervalSecUi(value, fallback = 5) {
  const parsed = Number(value);
  const normalize = raw => {
    const n = Number(raw);
    if (!Number.isFinite(n)) return null;
    if (n <= 3.5) return PALETTE_TIMED_INTERVAL_MIN_SEC;
    return clampNumber(
      Math.round(n / 5) * 5,
      5,
      PALETTE_TIMED_INTERVAL_MAX_SEC,
      5
    );
  };
  const normalized = normalize(parsed);
  if (Number.isFinite(normalized)) return normalized;
  const fallbackNormalized = normalize(fallback);
  return Number.isFinite(fallbackNormalized) ? fallbackNormalized : 5;
}

function normalizePaletteBeatLockGraceSecUi(value, fallback = 2) {
  const parsed = Number(value);
  if (Number.isFinite(parsed)) {
    return clampNumber(
      Math.round(parsed),
      PALETTE_BEAT_LOCK_GRACE_MIN_SEC,
      PALETTE_BEAT_LOCK_GRACE_MAX_SEC,
      2
    );
  }
  const fallbackNum = Number(fallback);
  if (Number.isFinite(fallbackNum)) {
    return clampNumber(
      Math.round(fallbackNum),
      PALETTE_BEAT_LOCK_GRACE_MIN_SEC,
      PALETTE_BEAT_LOCK_GRACE_MAX_SEC,
      2
    );
  }
  return 2;
}

function normalizePaletteReactiveMarginUi(value, fallback = 28) {
  const parsed = Number(value);
  if (Number.isFinite(parsed)) {
    return clampNumber(
      Math.round(parsed),
      PALETTE_REACTIVE_MARGIN_MIN,
      PALETTE_REACTIVE_MARGIN_MAX,
      28
    );
  }
  const fallbackNum = Number(fallback);
  if (Number.isFinite(fallbackNum)) {
    return clampNumber(
      Math.round(fallbackNum),
      PALETTE_REACTIVE_MARGIN_MIN,
      PALETTE_REACTIVE_MARGIN_MAX,
      28
    );
  }
  return 28;
}

function normalizePaletteBrightnessModeUi(value, fallback = "legacy") {
  const mode = String(value || "").trim().toLowerCase();
  if (PALETTE_BRIGHTNESS_MODE_ORDER.includes(mode)) return mode;
  const fallbackMode = String(fallback || "").trim().toLowerCase();
  return PALETTE_BRIGHTNESS_MODE_ORDER.includes(fallbackMode) ? fallbackMode : "legacy";
}

function normalizePaletteBrightnessFollowAmountUi(value, fallback = 1) {
  const parsed = Number(value);
  if (Number.isFinite(parsed)) {
    return clampNumber(
      parsed,
      PALETTE_BRIGHTNESS_FOLLOW_AMOUNT_MIN,
      PALETTE_BRIGHTNESS_FOLLOW_AMOUNT_MAX,
      1
    );
  }
  const fallbackNum = Number(fallback);
  if (Number.isFinite(fallbackNum)) {
    return clampNumber(
      fallbackNum,
      PALETTE_BRIGHTNESS_FOLLOW_AMOUNT_MIN,
      PALETTE_BRIGHTNESS_FOLLOW_AMOUNT_MAX,
      1
    );
  }
  return 1;
}

function normalizePaletteVividnessUi(value, fallback = 2) {
  const minLevel = PALETTE_VIVIDNESS_LEVEL_OPTIONS[0];
  const maxLevel = PALETTE_VIVIDNESS_LEVEL_OPTIONS[PALETTE_VIVIDNESS_LEVEL_OPTIONS.length - 1];
  const parsed = Number(value);
  if (Number.isFinite(parsed)) {
    return clampNumber(Math.round(parsed), minLevel, maxLevel, 2);
  }
  const fallbackNum = Number(fallback);
  if (Number.isFinite(fallbackNum)) {
    return clampNumber(Math.round(fallbackNum), minLevel, maxLevel, 2);
  }
  return 2;
}

function normalizePaletteSpectrumMapModeUi(value, fallback = "auto") {
  const mode = String(value || "").trim().toLowerCase();
  if (PALETTE_SPECTRUM_MAP_MODE_ORDER.includes(mode)) return mode;
  const fallbackMode = String(fallback || "").trim().toLowerCase();
  return PALETTE_SPECTRUM_MAP_MODE_ORDER.includes(fallbackMode) ? fallbackMode : "auto";
}

function normalizePaletteAudioFeatureUi(value, fallback = "rms") {
  const key = String(value || "").trim().toLowerCase();
  if (PALETTE_AUDIO_FEATURE_KEYS.includes(key)) return key;
  const fallbackKey = String(fallback || "").trim().toLowerCase();
  return PALETTE_AUDIO_FEATURE_KEYS.includes(fallbackKey) ? fallbackKey : "rms";
}

function normalizePaletteSpectrumFeatureMapUi(value, fallback = PALETTE_DEFAULT_SPECTRUM_FEATURE_MAP) {
  const list = Array.isArray(value)
    ? value
    : String(value || "")
      .split(",")
      .map(item => item.trim())
      .filter(Boolean);
  const fallbackList = Array.isArray(fallback) && fallback.length
    ? fallback
    : PALETTE_DEFAULT_SPECTRUM_FEATURE_MAP;
  const out = [];
  for (let i = 0; i < 5; i += 1) {
    const raw = Object.prototype.hasOwnProperty.call(list, i)
      ? list[i]
      : fallbackList[i % fallbackList.length];
    out.push(
      normalizePaletteAudioFeatureUi(raw, fallbackList[i % fallbackList.length])
    );
  }
  return out;
}

function getPaletteFamiliesLabelUi(families) {
  const normalized = normalizePaletteFamiliesUi(families, ui.paletteFamilies);
  return normalized.map(name => String(name || "").toUpperCase()).join("+");
}

function normalizePaletteConfigUi(config = {}, fallback = null) {
  const base = fallback && typeof fallback === "object"
    ? fallback
    : {
        colorsPerFamily: ui.paletteColorsPerFamily || 3,
        families: ui.paletteFamilies || ["red", "green", "blue"],
        disorder: ui.paletteDisorder,
        disorderAggression: ui.paletteDisorderAggression || 0.35,
        cycleMode: ui.paletteCycleMode || "on_trigger",
        timedIntervalSec: ui.paletteTimedIntervalSec || 5,
        beatLock: ui.paletteBeatLock === true,
        beatLockGraceSec: ui.paletteBeatLockGraceSec || 2,
        reactiveMargin: ui.paletteReactiveMargin || 28,
        brightnessMode: ui.paletteBrightnessMode || "legacy",
        brightnessFollowAmount: ui.paletteBrightnessFollowAmount ?? 1,
        vividness: ui.paletteVividness || 2,
        spectrumMapMode: ui.paletteSpectrumMapMode || "auto",
        spectrumFeatureMap: ui.paletteSpectrumFeatureMap || PALETTE_DEFAULT_SPECTRUM_FEATURE_MAP
      };
  const source = config && typeof config === "object" ? config : {};
  return {
    colorsPerFamily: normalizePaletteColorCountUi(source.colorsPerFamily, base.colorsPerFamily || 3),
    families: normalizePaletteFamiliesUi(source.families, base.families || ["red", "green", "blue"]),
    disorder: Object.prototype.hasOwnProperty.call(source, "disorder")
      ? Boolean(source.disorder)
      : Boolean(base.disorder),
    disorderAggression: normalizePaletteDisorderAggressionUi(
      source.disorderAggression,
      base.disorderAggression || 0.35
    ),
    cycleMode: normalizePaletteCycleModeUi(source.cycleMode, base.cycleMode || "on_trigger"),
    timedIntervalSec: normalizePaletteTimedIntervalSecUi(
      source.timedIntervalSec,
      base.timedIntervalSec || 5
    ),
    beatLock: Object.prototype.hasOwnProperty.call(source, "beatLock")
      ? parseBooleanUi(source.beatLock, Boolean(base.beatLock))
      : Boolean(base.beatLock),
    beatLockGraceSec: normalizePaletteBeatLockGraceSecUi(
      source.beatLockGraceSec,
      base.beatLockGraceSec || 2
    ),
    reactiveMargin: normalizePaletteReactiveMarginUi(
      source.reactiveMargin,
      base.reactiveMargin || 28
    ),
    brightnessMode: normalizePaletteBrightnessModeUi(
      source.brightnessMode,
      base.brightnessMode || "legacy"
    ),
    brightnessFollowAmount: normalizePaletteBrightnessFollowAmountUi(
      source.brightnessFollowAmount,
      base.brightnessFollowAmount ?? 1
    ),
    vividness: normalizePaletteVividnessUi(
      source.vividness,
      base.vividness || 2
    ),
    spectrumMapMode: normalizePaletteSpectrumMapModeUi(
      source.spectrumMapMode,
      base.spectrumMapMode || "auto"
    ),
    spectrumFeatureMap: normalizePaletteSpectrumFeatureMapUi(
      source.spectrumFeatureMap,
      base.spectrumFeatureMap || PALETTE_DEFAULT_SPECTRUM_FEATURE_MAP
    )
  };
}

function normalizePaletteBrandOverridesUi(raw = {}, globalConfig = null) {
  const source = raw && typeof raw === "object" ? raw : {};
  const base = normalizePaletteConfigUi(globalConfig || {}, globalConfig || null);
  const out = {};
  for (const brand of PALETTE_SUPPORTED_BRANDS) {
    const entry = source[brand];
    out[brand] = entry && typeof entry === "object"
      ? normalizePaletteConfigUi(entry, base)
      : null;
  }
  return out;
}

function normalizePaletteFixtureOverridesUi(raw = {}, brandOverrides = null, globalConfig = null) {
  const source = raw && typeof raw === "object" ? raw : {};
  const out = {};
  for (const [rawFixtureId, rawConfig] of Object.entries(source)) {
    const fixtureId = String(rawFixtureId || "").trim();
    if (!fixtureId) continue;
    if (!rawConfig || typeof rawConfig !== "object") continue;
    const brand = normalizePaletteBrandUi(rawConfig.brand);
    if (!brand) continue;
    const fallback = brandOverrides && brandOverrides[brand]
      ? brandOverrides[brand]
      : normalizePaletteConfigUi(globalConfig || {}, globalConfig || null);
    out[fixtureId] = {
      ...normalizePaletteConfigUi(rawConfig, fallback),
      brand,
      fixtureId
    };
  }
  return out;
}

function normalizeFixtureMetricModeUi(value, fallback = FIXTURE_METRIC_CONFIG_DEFAULT.mode) {
  const mode = String(value || "").trim().toLowerCase();
  if (FIXTURE_METRIC_MODE_ORDER.includes(mode)) return mode;
  const fallbackMode = String(fallback || "").trim().toLowerCase();
  return FIXTURE_METRIC_MODE_ORDER.includes(fallbackMode)
    ? fallbackMode
    : FIXTURE_METRIC_CONFIG_DEFAULT.mode;
}

function normalizeFixtureMetricKeyUi(value, fallback = FIXTURE_METRIC_CONFIG_DEFAULT.metric) {
  const metric = String(value || "").trim().toLowerCase();
  if (FIXTURE_METRIC_KEYS.includes(metric)) return metric;
  const fallbackMetric = String(fallback || "").trim().toLowerCase();
  return FIXTURE_METRIC_KEYS.includes(fallbackMetric)
    ? fallbackMetric
    : FIXTURE_METRIC_CONFIG_DEFAULT.metric;
}

function normalizeFixtureMetricHarmonySizeUi(value, fallback = FIXTURE_METRIC_CONFIG_DEFAULT.harmonySize) {
  const parsed = Number(value);
  if (Number.isFinite(parsed)) {
    return clampNumber(
      Math.round(parsed),
      FIXTURE_METRIC_HARMONY_MIN,
      FIXTURE_METRIC_HARMONY_MAX,
      FIXTURE_METRIC_CONFIG_DEFAULT.harmonySize
    );
  }
  const fallbackParsed = Number(fallback);
  if (Number.isFinite(fallbackParsed)) {
    return clampNumber(
      Math.round(fallbackParsed),
      FIXTURE_METRIC_HARMONY_MIN,
      FIXTURE_METRIC_HARMONY_MAX,
      FIXTURE_METRIC_CONFIG_DEFAULT.harmonySize
    );
  }
  return FIXTURE_METRIC_CONFIG_DEFAULT.harmonySize;
}

function normalizeFixtureMetricMaxHzUi(value, fallback = FIXTURE_METRIC_CONFIG_DEFAULT.maxHz) {
  const normalizeRaw = input => {
    if (input === undefined) return { ok: false, value: null };
    if (input === null) return { ok: true, value: null };
    if (typeof input === "string") {
      const raw = input.trim().toLowerCase();
      if (!raw) return { ok: true, value: null };
      if (
        raw === "off" ||
        raw === "none" ||
        raw === "null" ||
        raw === "unclamped" ||
        raw === "unclamp" ||
        raw === "disabled"
      ) {
        return { ok: true, value: null };
      }
    }
    const parsed = Number(input);
    if (!Number.isFinite(parsed) || parsed <= 0) return { ok: false, value: null };
    const clamped = clampNumber(parsed, FIXTURE_METRIC_MAX_HZ_MIN, FIXTURE_METRIC_MAX_HZ_MAX, null);
    if (!Number.isFinite(clamped) || clamped <= 0) return { ok: false, value: null };
    return { ok: true, value: Math.round(clamped * 10) / 10 };
  };

  const primary = normalizeRaw(value);
  if (primary.ok) return primary.value;
  const fallbackValue = normalizeRaw(fallback);
  return fallbackValue.ok ? fallbackValue.value : null;
}

function formatFixtureMetricMaxHzUi(value) {
  const hz = normalizeFixtureMetricMaxHzUi(value, null);
  if (!(Number.isFinite(hz) && hz > 0)) return "UNCLAMPED";
  const text = Number.isInteger(hz) ? String(hz) : hz.toFixed(1).replace(/\.0$/, "");
  return `${text} HZ`;
}

function normalizeFixtureMetricConfigUi(config = {}, fallback = null) {
  const base = fallback && typeof fallback === "object"
    ? fallback
    : {
      mode: ui.fixtureMetricConfig?.mode || FIXTURE_METRIC_CONFIG_DEFAULT.mode,
      metric: ui.fixtureMetricConfig?.metric || FIXTURE_METRIC_CONFIG_DEFAULT.metric,
      metaAutoFlip: ui.fixtureMetricConfig?.metaAutoFlip === true,
      harmonySize: ui.fixtureMetricConfig?.harmonySize || FIXTURE_METRIC_CONFIG_DEFAULT.harmonySize,
      maxHz: Object.prototype.hasOwnProperty.call(ui.fixtureMetricConfig || {}, "maxHz")
        ? ui.fixtureMetricConfig.maxHz
        : FIXTURE_METRIC_CONFIG_DEFAULT.maxHz
    };
  const source = config && typeof config === "object" ? config : {};
  return {
    mode: normalizeFixtureMetricModeUi(source.mode, base.mode),
    metric: normalizeFixtureMetricKeyUi(source.metric, base.metric),
    metaAutoFlip: Object.prototype.hasOwnProperty.call(source, "metaAutoFlip")
      ? Boolean(source.metaAutoFlip)
      : Boolean(base.metaAutoFlip),
    harmonySize: normalizeFixtureMetricHarmonySizeUi(source.harmonySize, base.harmonySize),
    maxHz: Object.prototype.hasOwnProperty.call(source, "maxHz")
      ? normalizeFixtureMetricMaxHzUi(source.maxHz, base.maxHz)
      : normalizeFixtureMetricMaxHzUi(base.maxHz, FIXTURE_METRIC_CONFIG_DEFAULT.maxHz)
  };
}

function normalizeFixtureMetricBrandOverridesUi(raw = {}, globalConfig = null) {
  const source = raw && typeof raw === "object" ? raw : {};
  const base = normalizeFixtureMetricConfigUi(globalConfig || {}, globalConfig || null);
  const out = {};
  for (const brand of PALETTE_SUPPORTED_BRANDS) {
    const entry = source[brand];
    out[brand] = entry && typeof entry === "object"
      ? normalizeFixtureMetricConfigUi(entry, base)
      : null;
  }
  return out;
}

function normalizeFixtureMetricFixtureOverridesUi(raw = {}, brandOverrides = null, globalConfig = null) {
  const source = raw && typeof raw === "object" ? raw : {};
  const out = {};
  for (const [rawFixtureId, rawConfig] of Object.entries(source)) {
    const fixtureId = String(rawFixtureId || "").trim();
    if (!fixtureId) continue;
    if (!rawConfig || typeof rawConfig !== "object") continue;
    const brand = normalizePaletteBrandUi(rawConfig.brand);
    if (!brand) continue;
    const fallback = brandOverrides && brandOverrides[brand]
      ? brandOverrides[brand]
      : normalizeFixtureMetricConfigUi(globalConfig || {}, globalConfig || null);
    out[fixtureId] = {
      ...normalizeFixtureMetricConfigUi(rawConfig, fallback),
      brand,
      fixtureId
    };
  }
  return out;
}

function applyFixtureMetricRoutingSnapshotToUi(snapshot = {}) {
  const source = snapshot && typeof snapshot === "object" ? snapshot : {};
  const normalizedGlobal = normalizeFixtureMetricConfigUi(source.config || source, FIXTURE_METRIC_CONFIG_DEFAULT);
  ui.fixtureMetricConfig = { ...normalizedGlobal };
  ui.fixtureMetricBrandOverrides = normalizeFixtureMetricBrandOverridesUi(
    source.brands,
    normalizedGlobal
  );
  ui.fixtureMetricFixtureOverrides = normalizeFixtureMetricFixtureOverridesUi(
    source.fixtureOverrides,
    ui.fixtureMetricBrandOverrides,
    normalizedGlobal
  );
}

function getFixtureMetricBrandConfigUi(brand) {
  const brandKey = normalizePaletteBrandUi(brand);
  const globalConfig = normalizeFixtureMetricConfigUi(ui.fixtureMetricConfig, FIXTURE_METRIC_CONFIG_DEFAULT);
  if (!brandKey) return globalConfig;
  const override = ui.fixtureMetricBrandOverrides && ui.fixtureMetricBrandOverrides[brandKey];
  return override
    ? normalizeFixtureMetricConfigUi(override, globalConfig)
    : globalConfig;
}

function getFixtureMetricScopedConfigUi(brand, fixtureId = PALETTE_ALL_FIXTURES_VALUE) {
  const brandKey = normalizePaletteBrandUi(brand);
  const base = getFixtureMetricBrandConfigUi(brandKey);
  const id = String(fixtureId || "").trim();
  if (!brandKey || !id || id === PALETTE_ALL_FIXTURES_VALUE) return base;
  const fixtureOverride = ui.fixtureMetricFixtureOverrides && ui.fixtureMetricFixtureOverrides[id];
  if (!fixtureOverride || fixtureOverride.brand !== brandKey) return base;
  return normalizeFixtureMetricConfigUi(fixtureOverride, base);
}

function applyPaletteSnapshotToUi(config = {}, options = {}) {
  const next = config && typeof config === "object" ? config : {};
  const normalizedGlobal = normalizePaletteConfigUi(
    next,
    {
      colorsPerFamily: ui.paletteColorsPerFamily || 3,
      families: ui.paletteFamilies || ["red", "green", "blue"],
      disorder: ui.paletteDisorder,
      disorderAggression: ui.paletteDisorderAggression || 0.35,
      cycleMode: ui.paletteCycleMode || "on_trigger",
      timedIntervalSec: ui.paletteTimedIntervalSec || 5,
      beatLock: ui.paletteBeatLock === true,
      beatLockGraceSec: ui.paletteBeatLockGraceSec || 2,
      reactiveMargin: ui.paletteReactiveMargin || 28,
      brightnessMode: ui.paletteBrightnessMode || "legacy",
      brightnessFollowAmount: ui.paletteBrightnessFollowAmount ?? 1,
      vividness: ui.paletteVividness || 2,
      spectrumMapMode: ui.paletteSpectrumMapMode || "auto",
      spectrumFeatureMap: ui.paletteSpectrumFeatureMap || PALETTE_DEFAULT_SPECTRUM_FEATURE_MAP
    }
  );
  ui.paletteColorsPerFamily = normalizedGlobal.colorsPerFamily;
  ui.paletteFamilies = normalizedGlobal.families.slice();
  ui.paletteDisorder = Boolean(normalizedGlobal.disorder);
  ui.paletteDisorderAggression = normalizedGlobal.disorderAggression;
  ui.paletteCycleMode = normalizedGlobal.cycleMode;
  ui.paletteTimedIntervalSec = normalizedGlobal.timedIntervalSec;
  ui.paletteBeatLock = normalizedGlobal.beatLock === true;
  ui.paletteBeatLockGraceSec = normalizedGlobal.beatLockGraceSec;
  ui.paletteReactiveMargin = normalizedGlobal.reactiveMargin;
  ui.paletteBrightnessMode = normalizedGlobal.brightnessMode;
  ui.paletteBrightnessFollowAmount = normalizedGlobal.brightnessFollowAmount;
  ui.paletteVividness = normalizedGlobal.vividness;
  ui.paletteSpectrumMapMode = normalizedGlobal.spectrumMapMode;
  ui.paletteSpectrumFeatureMap = normalizePaletteSpectrumFeatureMapUi(
    normalizedGlobal.spectrumFeatureMap,
    PALETTE_DEFAULT_SPECTRUM_FEATURE_MAP
  );

  ui.paletteBrandOverrides = normalizePaletteBrandOverridesUi(
    next.brands,
    normalizedGlobal
  );

  const opts = options && typeof options === "object" ? options : {};
  if (opts.fixtureOverrides && typeof opts.fixtureOverrides === "object") {
    ui.paletteFixtureOverrides = normalizePaletteFixtureOverridesUi(
      opts.fixtureOverrides,
      ui.paletteBrandOverrides,
      normalizedGlobal
    );
  }
  if (opts.brandFixtures && typeof opts.brandFixtures === "object") {
    ui.paletteBrandFixtures = {
      hue: Array.isArray(opts.brandFixtures.hue) ? opts.brandFixtures.hue.slice() : [],
      wiz: Array.isArray(opts.brandFixtures.wiz) ? opts.brandFixtures.wiz.slice() : []
    };
  }
}

function getPaletteGlobalConfigUi() {
  return normalizePaletteConfigUi({
    colorsPerFamily: ui.paletteColorsPerFamily,
    families: ui.paletteFamilies,
    disorder: ui.paletteDisorder,
    disorderAggression: ui.paletteDisorderAggression,
    cycleMode: ui.paletteCycleMode,
    timedIntervalSec: ui.paletteTimedIntervalSec,
    beatLock: ui.paletteBeatLock,
    beatLockGraceSec: ui.paletteBeatLockGraceSec,
    reactiveMargin: ui.paletteReactiveMargin,
    brightnessMode: ui.paletteBrightnessMode,
    brightnessFollowAmount: ui.paletteBrightnessFollowAmount,
    vividness: ui.paletteVividness,
    spectrumMapMode: ui.paletteSpectrumMapMode,
    spectrumFeatureMap: ui.paletteSpectrumFeatureMap
  });
}

function getPaletteBrandConfigUi(brand) {
  const brandKey = normalizePaletteBrandUi(brand);
  const globalConfig = getPaletteGlobalConfigUi();
  if (!brandKey) return globalConfig;
  const override = ui.paletteBrandOverrides && ui.paletteBrandOverrides[brandKey];
  return override
    ? normalizePaletteConfigUi(override, globalConfig)
    : globalConfig;
}

function getPaletteScopedConfigUi(brand, fixtureId = PALETTE_ALL_FIXTURES_VALUE) {
  const brandKey = normalizePaletteBrandUi(brand);
  const base = getPaletteBrandConfigUi(brandKey);
  const id = String(fixtureId || "").trim();
  if (!brandKey || !id || id === PALETTE_ALL_FIXTURES_VALUE) return base;
  const fixtureOverride = ui.paletteFixtureOverrides && ui.paletteFixtureOverrides[id];
  if (!fixtureOverride || fixtureOverride.brand !== brandKey) return base;
  return normalizePaletteConfigUi(fixtureOverride, base);
}

function getPaletteBrandFixturesUi(brand) {
  const brandKey = normalizePaletteBrandUi(brand);
  if (!brandKey) return [];
  const routed = ui.paletteBrandFixtures && Array.isArray(ui.paletteBrandFixtures[brandKey])
    ? ui.paletteBrandFixtures[brandKey]
    : [];
  if (routed.length) {
    return routed
      .map(entry => {
        const id = String(entry?.id || "").trim();
        const zone = String(entry?.zone || brandKey).trim().toLowerCase() || brandKey;
        return {
          id,
          label: `${id} | ${zone.toUpperCase()}`
        };
      })
      .filter(entry => Boolean(entry.id))
      .sort((a, b) => String(a.id).localeCompare(String(b.id)));
  }
  const catalog = Array.isArray(ui.fixturesCatalog) ? ui.fixturesCatalog : [];
  return catalog
    .filter(fixture => {
      if (!fixture || typeof fixture !== "object") return false;
      const fixtureBrand = normalizePaletteBrandUi(fixture.brand);
      if (fixtureBrand !== brandKey) return false;
      if (fixture.enabled === false) return false;
      return parseBooleanUi(fixture.engineEnabled, false);
    })
    .map(fixture => {
      const id = String(fixture.id || "").trim();
      const zone = String(fixture.zone || brandKey).trim().toLowerCase() || brandKey;
      return {
        id,
        label: `${id} | ${zone.toUpperCase()}`
      };
    })
    .filter(entry => Boolean(entry.id))
    .sort((a, b) => String(a.id).localeCompare(String(b.id)));
}

function escapeHtmlUi(value) {
  return String(value || "")
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#39;");
}

function getPaletteBrandSelectionUi(brand, fixtures = []) {
  const brandKey = normalizePaletteBrandUi(brand);
  if (!brandKey) return PALETTE_ALL_FIXTURES_VALUE;
  if (!ui.paletteFixtureSelectionByBrand || typeof ui.paletteFixtureSelectionByBrand !== "object") {
    ui.paletteFixtureSelectionByBrand = { hue: PALETTE_ALL_FIXTURES_VALUE, wiz: PALETTE_ALL_FIXTURES_VALUE };
  }
  const requested = String(ui.paletteFixtureSelectionByBrand[brandKey] || PALETTE_ALL_FIXTURES_VALUE).trim();
  const validFixtureIds = new Set((Array.isArray(fixtures) ? fixtures : []).map(entry => String(entry.id || "").trim()));
  const selected = requested === PALETTE_ALL_FIXTURES_VALUE || validFixtureIds.has(requested)
    ? requested
    : PALETTE_ALL_FIXTURES_VALUE;
  if (ui.paletteFixtureSelectionByBrand[brandKey] !== selected) {
    ui.paletteFixtureSelectionByBrand[brandKey] = selected;
    persistPaletteFixtureSelectionMemory();
  }
  return selected;
}

function buildPaletteBrandCardUi(brand, fixtures = []) {
  const brandKey = normalizePaletteBrandUi(brand);
  if (!brandKey) return "";
  const brandLabel = PALETTE_BRAND_LABELS[brandKey] || brandKey.toUpperCase();
  const selectedFixture = getPaletteBrandSelectionUi(brandKey, fixtures);
  const config = getPaletteScopedConfigUi(brandKey, selectedFixture);
  const colorsPerFamily = normalizePaletteColorCountUi(config.colorsPerFamily, 3);
  const families = normalizePaletteFamiliesUi(config.families, ["red", "green", "blue"]);
  const disorder = Boolean(config.disorder);
  const aggressionPct = Math.round(normalizePaletteDisorderAggressionUi(config.disorderAggression, 0.35) * 100);
  const cycleMode = normalizePaletteCycleModeUi(config.cycleMode, "on_trigger");
  const timedIntervalSec = normalizePaletteTimedIntervalSecUi(config.timedIntervalSec, 5);
  const beatLock = parseBooleanUi(config.beatLock, false) === true;
  const beatLockGraceSec = normalizePaletteBeatLockGraceSecUi(config.beatLockGraceSec, 2);
  const reactiveMargin = normalizePaletteReactiveMarginUi(config.reactiveMargin, 28);
  const brightnessMode = normalizePaletteBrightnessModeUi(config.brightnessMode, "legacy");
  const brightnessFollowAmount = normalizePaletteBrightnessFollowAmountUi(config.brightnessFollowAmount, 1);
  const brightnessFollowPct = Math.round(brightnessFollowAmount * 100);
  const vividness = normalizePaletteVividnessUi(config.vividness, 2);
  const spectrumMapMode = normalizePaletteSpectrumMapModeUi(config.spectrumMapMode, "auto");
  const spectrumFeatureMap = normalizePaletteSpectrumFeatureMapUi(
    config.spectrumFeatureMap,
    PALETTE_DEFAULT_SPECTRUM_FEATURE_MAP
  );
  const modeNotice = String(ui.paletteBrandModeNotices?.[brandKey] || "").trim();
  const fixtureOverrideCount = (Array.isArray(fixtures) ? fixtures : []).reduce((count, entry) => {
    const fixtureId = String(entry?.id || "").trim();
    if (!fixtureId) return count;
    const override = ui.paletteFixtureOverrides && ui.paletteFixtureOverrides[fixtureId];
    return override && override.brand === brandKey ? count + 1 : count;
  }, 0);
  const targetScopeHint = selectedFixture === PALETTE_ALL_FIXTURES_VALUE
    ? `Scope: brand default (${brandLabel} all fixtures).`
    : `Scope: fixture override (${selectedFixture}).`;
  const targetOverrideHint = selectedFixture === PALETTE_ALL_FIXTURES_VALUE && fixtureOverrideCount > 0
    ? `${fixtureOverrideCount} fixture override${fixtureOverrideCount === 1 ? "" : "s"} active. Brand edits do not replace fixture-specific overrides until cleared.`
    : "";
  const metricConfig = getFixtureMetricScopedConfigUi(brandKey, selectedFixture);
  const metricMode = normalizeFixtureMetricModeUi(metricConfig.mode, FIXTURE_METRIC_CONFIG_DEFAULT.mode);
  const metricKey = normalizeFixtureMetricKeyUi(metricConfig.metric, FIXTURE_METRIC_CONFIG_DEFAULT.metric);
  const metricFlip = Boolean(metricConfig.metaAutoFlip);
  const harmonySize = normalizeFixtureMetricHarmonySizeUi(
    metricConfig.harmonySize,
    FIXTURE_METRIC_CONFIG_DEFAULT.harmonySize
  );
  const maxHz = normalizeFixtureMetricMaxHzUi(
    metricConfig.maxHz,
    FIXTURE_METRIC_CONFIG_DEFAULT.maxHz
  );
  const maxHzClamped = Number.isFinite(maxHz) && maxHz > 0;
  const maxHzSliderValue = maxHzClamped ? maxHz : FIXTURE_METRIC_MAX_HZ_DEFAULT;
  const maxHzLabel = formatFixtureMetricMaxHzUi(maxHz);

  const fixtureOptions = [
    `<option value="${PALETTE_ALL_FIXTURES_VALUE}" ${selectedFixture === PALETTE_ALL_FIXTURES_VALUE ? "selected" : ""}>ALL ${brandLabel} FIXTURES</option>`,
    ...fixtures.map(entry => {
      const id = String(entry.id || "").trim();
      const label = escapeHtmlUi(entry.label || id);
      return `<option value="${escapeHtmlUi(id)}" ${selectedFixture === id ? "selected" : ""}>${label}</option>`;
    })
  ].join("");

  const countButtons = PALETTE_COLOR_COUNT_OPTIONS.map(count => (
    `<button type="button" data-palette-brand-count="${brandKey}" data-count="${count}" class="${count === colorsPerFamily ? "active" : ""}" title="Use ${count} color${count === 1 ? "" : "s"} from each selected family for this target.">${count} COLOR${count === 1 ? "" : "S"}</button>`
  )).join("");

  const familyButtons = PALETTE_FAMILY_ORDER.map(family => (
    `<button type="button" data-palette-brand-family="${brandKey}" data-family="${family}" class="${families.includes(family) ? "active" : ""}" title="Toggle ${family.toUpperCase()} family in the playback sequence for this target.">${family.toUpperCase()}</button>`
  )).join("");
  const vividnessButtons = PALETTE_VIVIDNESS_LEVEL_OPTIONS.map(level => (
    `<button type="button" data-palette-brand-vividness="${brandKey}" data-level="${level}" class="${level === vividness ? "active" : ""}" title="Set ${brandLabel} vividness to ${(PALETTE_VIVIDNESS_LABELS[level] || String(level)).toUpperCase()}.">${(PALETTE_VIVIDNESS_LABELS[level] || String(level)).toUpperCase()}</button>`
  )).join("");
  const metricModeButtons = FIXTURE_METRIC_MODE_ORDER.map(mode => (
    `<button type="button" data-fixture-metric-mode="${brandKey}" data-mode="${mode}" class="${metricMode === mode ? "active" : ""}" title="${mode === "meta_auto" ? "Let the engine auto-assign different song metrics across fixtures." : "Manually lock this target to one selected song metric."}">${mode === "meta_auto" ? "META AUTO" : "MANUAL"}</button>`
  )).join("");
  const metricButtons = FIXTURE_METRIC_KEYS.map(metric => (
    `<button type="button" data-fixture-metric-key="${brandKey}" data-metric="${metric}" class="${metricKey === metric ? "active" : ""}" title="${metric === "baseline" ? "Drive behavior from overall loudness level." : metric === "peaks" ? "Drive behavior from short peak hits." : metric === "transients" ? "Drive behavior from sharp attack changes." : "Drive behavior from spectral movement (flux)."}">${(FIXTURE_METRIC_LABELS[metric] || metric).toUpperCase()}</button>`
  )).join("");
  const cycleButtons = PALETTE_CYCLE_MODE_ORDER.map(mode => {
    const modeTitle = mode === "on_trigger"
      ? "Advance to the next palette group on beat/drop triggers. Colors inside the active group continue to move."
      : mode === "timed_cycle"
        ? "Advance to the next palette group every interval. Colors inside the active group continue to move between advances."
        : mode === "reactive_shift"
          ? "Advance to the next palette group when tempo/progression changes pass margin. Colors inside the active group continue to move."
          : "Choose active palette group from mapped audio features (lows/mids/highs/etc). Colors still move inside the selected group.";
    return `<button type="button" data-palette-brand-cycle-mode="${brandKey}" data-mode="${mode}" class="${cycleMode === mode ? "active" : ""}" title="${modeTitle}">${(PALETTE_CYCLE_MODE_LABELS[mode] || mode).toUpperCase()}</button>`;
  }).join("");
  const brightnessModeButtons = PALETTE_BRIGHTNESS_MODE_ORDER.map(mode => (
    `<button type="button" data-palette-brand-brightness-mode="${brandKey}" data-mode="${mode}" class="${brightnessMode === mode ? "active" : ""}" title="${mode === "test" ? "Brightness follows palette color movement + audio dynamics for this scope." : "Keep current legacy brightness behavior for this scope."}">${(PALETTE_BRIGHTNESS_MODE_LABELS[mode] || mode).toUpperCase()}</button>`
  )).join("");
  const beatLockButtons = [
    `<button type="button" data-palette-brand-beat-lock="${brandKey}" data-enabled="false" class="${!beatLock ? "active" : ""}" title="Advance exactly on the timer interval.">OFF</button>`,
    `<button type="button" data-palette-brand-beat-lock="${brandKey}" data-enabled="true" class="${beatLock ? "active" : ""}" title="Wait for beat/drop near interval, then advance.">ON</button>`
  ].join("");
  const spectrumModeButtons = PALETTE_SPECTRUM_MAP_MODE_ORDER.map(mode => (
    `<button type="button" data-palette-brand-spectrum-mode="${brandKey}" data-mode="${mode}" class="${spectrumMapMode === mode ? "active" : ""}" title="${mode === "manual" ? "Choose which audio feature maps to each slot." : "Use built-in auto mapping across slots."}">${mode === "manual" ? "MANUAL ASSIGN" : "AUTO ASSIGN"}</button>`
  )).join("");
  const spectrumSelectors = Array.from({ length: 5 }, (_, slot) => {
    const selectedFeature = normalizePaletteAudioFeatureUi(
      spectrumFeatureMap[slot],
      PALETTE_DEFAULT_SPECTRUM_FEATURE_MAP[slot % PALETTE_DEFAULT_SPECTRUM_FEATURE_MAP.length]
    );
    const options = PALETTE_AUDIO_FEATURE_KEYS.map(feature => (
      `<option value="${feature}" ${selectedFeature === feature ? "selected" : ""}>SLOT ${slot + 1}: ${(PALETTE_AUDIO_FEATURE_LABELS[feature] || feature).toUpperCase()}</option>`
    )).join("");
    return `<select data-palette-brand-spectrum="${brandKey}" data-palette-brand-spectrum-slot="${slot}" ${spectrumMapMode === "manual" ? "" : "disabled"}>${options}</select>`;
  }).join("");
  const timedWrapClass = cycleMode === "timed_cycle" ? "" : "hidden";
  const reactiveWrapClass = cycleMode === "reactive_shift" ? "" : "hidden";
  const spectrumWrapClass = cycleMode === "spectrum_mapper" ? "" : "hidden";
  const brightnessFollowWrapClass = brightnessMode === "test" ? "" : "hidden";

  return (
    `<div class="paletteBrandCard" data-palette-brand-card="${brandKey}">` +
      `<h4>${brandLabel} FIXTURE MENU</h4>` +
      `<div class="paletteBrandSections">` +
        `<details class="paletteBrandSection" open>` +
          `<summary>TARGET</summary>` +
          `<div class="paletteBrandSectionBody">` +
            `<div class="paletteBrandFixtureRow">` +
              `<div>` +
                `<p class="paletteBrandSubLabel">TARGET</p>` +
                `<select data-palette-brand-fixture="${brandKey}" title="Choose ALL fixtures of this brand, or one fixture ID for a per-fixture override.">${fixtureOptions}</select>` +
              `</div>` +
              `<button type="button" data-palette-brand-clear="${brandKey}" title="Clear all palette and song-metric overrides for the currently selected target.">CLEAR ALL OVERRIDE</button>` +
            `</div>` +
            `<p class="hint paletteScopeHint">${escapeHtmlUi(targetScopeHint)}</p>` +
            (targetOverrideHint
              ? `<p class="hint paletteScopeHint paletteScopeHintWarn">${escapeHtmlUi(targetOverrideHint)}</p>`
              : "") +
          `</div>` +
        `</details>` +
        `<details class="paletteBrandSection" open>` +
          `<summary>COLOR PALETTE</summary>` +
          `<div class="paletteBrandSectionBody">` +
            `<p class="paletteBrandSubLabel">COLORS PER FAMILY</p>` +
            `<div class="paletteBrandMiniGrid">${countButtons}</div>` +
            `<p class="paletteBrandSubLabel">VIVIDNESS</p>` +
            `<div class="paletteBrandMiniGrid">${vividnessButtons}</div>` +
            `<p class="paletteBrandSubLabel">FAMILIES</p>` +
            `<div class="paletteBrandFamilyGrid">${familyButtons}</div>` +
          `</div>` +
        `</details>` +
        `<details class="paletteBrandSection" open>` +
          `<summary>ORDER + CHAOS</summary>` +
          `<div class="paletteBrandSectionBody">` +
            `<p class="paletteBrandSubLabel">ORDER</p>` +
            `<div class="paletteBrandOrderGrid">` +
              `<button type="button" data-palette-brand-disorder="${brandKey}" data-disorder="false" class="${!disorder ? "active" : ""}" title="Play colors in their defined sequence.">ORDERED</button>` +
              `<button type="button" data-palette-brand-disorder="${brandKey}" data-disorder="true" class="${disorder ? "active" : ""}" title="Shuffle sequence order with chaos amount set by the slider.">DISORDER</button>` +
            `</div>` +
            `<div class="paletteBrandSlider">` +
              `<label>` +
                `<span>DISORDER AGGRESSION</span>` +
                `<span class="paletteBrandValue" data-palette-brand-aggression-val="${brandKey}">${aggressionPct}%</span>` +
              `</label>` +
              `<input type="range" min="0" max="100" step="1" value="${aggressionPct}" data-palette-brand-aggression="${brandKey}" title="Set how strongly disorder jumps between colors and families.">` +
            `</div>` +
          `</div>` +
        `</details>` +
        `<details class="paletteBrandSection" open>` +
          `<summary>COLOR ENGINE MODE</summary>` +
          `<div class="paletteBrandSectionBody">` +
            `<p class="paletteModeNotice" data-palette-brand-mode-notice="${brandKey}">${escapeHtmlUi(modeNotice)}</p>` +
            `<div class="paletteCycleGrid">${cycleButtons}</div>` +
            `<p class="paletteBrandSubLabel">BRIGHTNESS ENGINE (RAVE TEST)</p>` +
            `<div class="paletteBrandOrderGrid">${brightnessModeButtons}</div>` +
            `<div class="paletteBrandSlider ${brightnessFollowWrapClass}" data-palette-brand-brightness-follow-wrap="${brandKey}">` +
              `<label>` +
                `<span>FOLLOW AMOUNT</span>` +
                `<span class="paletteBrandValue" data-palette-brand-brightness-follow-val="${brandKey}">${brightnessFollowAmount.toFixed(2)}x</span>` +
              `</label>` +
              `<input type="range" min="0" max="200" step="1" value="${brightnessFollowPct}" data-palette-brand-brightness-follow="${brandKey}" ${brightnessMode === "test" ? "" : "disabled"} title="Strength of brightness-follow behavior in TEST mode.">` +
            `</div>` +
            `<div class="paletteControlWrap ${timedWrapClass}" data-palette-brand-timed-wrap="${brandKey}">` +
              `<div class="paletteBrandSlider">` +
                `<label>` +
                  `<span>CYCLE INTERVAL</span>` +
                  `<span class="paletteBrandValue" data-palette-brand-timed-val="${brandKey}">${timedIntervalSec}s</span>` +
                `</label>` +
                `<input type="range" min="${PALETTE_TIMED_INTERVAL_MIN_SEC}" max="${PALETTE_TIMED_INTERVAL_MAX_SEC}" step="1" value="${timedIntervalSec}" data-palette-brand-timed="${brandKey}" title="How often to advance in TIMED CYCLE mode.">` +
              `</div>` +
              `<p class="paletteBrandSubLabel">BEAT LOCK</p>` +
              `<div class="paletteBrandOrderGrid">${beatLockButtons}</div>` +
              `<div class="paletteBrandSlider">` +
                `<label>` +
                  `<span>BEAT LOCK GRACE</span>` +
                  `<span class="paletteBrandValue" data-palette-brand-beat-grace-val="${brandKey}">+${beatLockGraceSec}s</span>` +
                `</label>` +
                `<input type="range" min="${PALETTE_BEAT_LOCK_GRACE_MIN_SEC}" max="${PALETTE_BEAT_LOCK_GRACE_MAX_SEC}" step="1" value="${beatLockGraceSec}" data-palette-brand-beat-grace="${brandKey}" title="Maximum extra wait for next beat before forced advance.">` +
              `</div>` +
            `</div>` +
            `<div class="paletteControlWrap ${reactiveWrapClass}" data-palette-brand-reactive-wrap="${brandKey}">` +
              `<div class="paletteBrandSlider">` +
                `<label>` +
                  `<span>CHANGE MARGIN</span>` +
                  `<span class="paletteBrandValue" data-palette-brand-reactive-margin-val="${brandKey}">${reactiveMargin}</span>` +
                `</label>` +
                `<input type="range" min="${PALETTE_REACTIVE_MARGIN_MIN}" max="${PALETTE_REACTIVE_MARGIN_MAX}" step="1" value="${reactiveMargin}" data-palette-brand-reactive-margin="${brandKey}" title="Higher margin requires stronger tempo/progression change before advancing.">` +
              `</div>` +
            `</div>` +
            `<div class="paletteControlWrap ${spectrumWrapClass}" data-palette-brand-spectrum-wrap="${brandKey}">` +
              `<p class="hint">Spectrum Mapper picks the active palette group from audio features. Color motion inside that group still follows ORDER/DISORDER.</p>` +
              `<p class="paletteBrandSubLabel">MAP MODE</p>` +
              `<div class="paletteBrandOrderGrid">${spectrumModeButtons}</div>` +
              `<div class="paletteSpectrumGrid">${spectrumSelectors}</div>` +
            `</div>` +
          `</div>` +
        `</details>` +
        `<details class="paletteBrandSection" open>` +
          `<summary>SONG METRIC</summary>` +
          `<div class="paletteBrandSectionBody">` +
            `<p class="paletteBrandSubLabel">SONG METRIC MODE</p>` +
            `<div class="paletteBrandOrderGrid">${metricModeButtons}</div>` +
            `<p class="paletteBrandSubLabel">MANUAL METRIC</p>` +
            `<div class="paletteBrandMetricGrid">${metricButtons}</div>` +
          `</div>` +
        `</details>` +
        `<details class="paletteBrandSection" open>` +
          `<summary>META AUTO ROTATION</summary>` +
          `<div class="paletteBrandSectionBody">` +
            `<p class="paletteBrandSubLabel">FIXTURE ROTATION</p>` +
            `<div class="paletteBrandOrderGrid">` +
              `<button type="button" data-fixture-metric-flip="${brandKey}" data-enabled="false" class="${!metricFlip ? "active" : ""}" title="Keep fixture-to-metric assignment order stable.">KEEP ORDER</button>` +
              `<button type="button" data-fixture-metric-flip="${brandKey}" data-enabled="true" class="${metricFlip ? "active" : ""}" title="Rotate fixture-to-metric assignment over time in meta auto mode.">FLIP FIXTURES</button>` +
            `</div>` +
            `<div class="paletteBrandSlider">` +
              `<label>` +
                `<span>HARMONY GROUP SIZE</span>` +
                `<span class="paletteBrandValue" data-fixture-metric-harmony-val="${brandKey}">${harmonySize}</span>` +
              `</label>` +
              `<input type="range" min="${FIXTURE_METRIC_HARMONY_MIN}" max="${FIXTURE_METRIC_HARMONY_MAX}" step="1" value="${harmonySize}" data-fixture-metric-harmony="${brandKey}" title="How many fixtures share the same assigned metric before rotating to the next metric.">` +
            `</div>` +
          `</div>` +
        `</details>` +
        `<details class="paletteBrandSection" open>` +
          `<summary>UPDATE RATE CLAMP</summary>` +
          `<div class="paletteBrandSectionBody">` +
            `<p class="paletteBrandSubLabel">MAX UPDATE RATE</p>` +
            `<div class="paletteBrandOrderGrid">` +
              `<button type="button" data-fixture-metric-maxhz-mode="${brandKey}" data-unclamped="true" class="${!maxHzClamped ? "active" : ""}" title="No fixture-level rate cap. Uses engine-driven rate only.">UNCLAMPED</button>` +
              `<button type="button" data-fixture-metric-maxhz-mode="${brandKey}" data-unclamped="false" class="${maxHzClamped ? "active" : ""}" title="Enable fixture-level max update rate cap using the MAX HZ slider.">CLAMPED</button>` +
            `</div>` +
            `<div class="paletteBrandSlider">` +
              `<label>` +
                `<span>MAX HZ</span>` +
                `<span class="paletteBrandValue" data-fixture-metric-maxhz-val="${brandKey}">${maxHzLabel}</span>` +
              `</label>` +
              `<input type="range" min="${FIXTURE_METRIC_MAX_HZ_MIN}" max="${FIXTURE_METRIC_MAX_HZ_MAX}" step="${FIXTURE_METRIC_MAX_HZ_STEP}" value="${maxHzSliderValue}" data-fixture-metric-maxhz="${brandKey}" ${maxHzClamped ? "" : "disabled"} title="Ceiling for fixture update rate. Lower values calm output and reduce command load.">` +
            `</div>` +
          `</div>` +
        `</details>` +
      `</div>` +
    `</div>`
  );
}

function markPaletteBrandMenusInteraction(holdMs = 1200) {
  const nextUntil = Date.now() + Math.max(250, Number(holdMs) || 1200);
  if (nextUntil > paletteBrandMenusInteractionUntil) {
    paletteBrandMenusInteractionUntil = nextUntil;
  }
}

function isPaletteBrandMenusInteractionActive() {
  return Date.now() < Number(paletteBrandMenusInteractionUntil || 0);
}

function schedulePaletteBrandMenusDeferredRender(options = {}) {
  if (paletteBrandMenusDeferredRenderTimer) return;
  paletteBrandMenusDeferredRenderTimer = setTimeout(() => {
    paletteBrandMenusDeferredRenderTimer = null;
    renderPaletteBrandMenus(options);
  }, 200);
}

function renderPaletteBrandMenus(options = {}) {
  if (!el.paletteBrandMenus) return;
  const opts = options && typeof options === "object" ? options : {};
  const force = opts.force === true;
  if (!force && isPaletteBrandMenusInteractionActive()) {
    schedulePaletteBrandMenusDeferredRender(opts);
    return;
  }
  if (paletteBrandMenusDeferredRenderTimer) {
    clearTimeout(paletteBrandMenusDeferredRenderTimer);
    paletteBrandMenusDeferredRenderTimer = null;
  }
  const fixturesByBrand = {};
  const availableBrands = [];
  for (const brand of PALETTE_SUPPORTED_BRANDS) {
    const fixtures = getPaletteBrandFixturesUi(brand);
    if (!fixtures.length) continue;
    fixturesByBrand[brand] = fixtures;
    availableBrands.push(brand);
  }
  if (!availableBrands.length) {
    el.paletteBrandMenus.innerHTML = `<div class="hint">No engine-routed Hue/WiZ fixtures detected for per-brand menus.</div>`;
    return;
  }

  const customScopeActive = normalizePaletteControlScopeUi(ui.paletteControlScope, "global") === "custom";
  if (!availableBrands.includes(ui.paletteCustomBrand)) {
    ui.paletteCustomBrand = availableBrands[0];
  }

  if (customScopeActive) {
    const activeBrand = normalizePaletteCustomBrandMemoryUi(ui.paletteCustomBrand, availableBrands[0]);
    const fixtures = fixturesByBrand[activeBrand] || fixturesByBrand[availableBrands[0]] || [];
    el.paletteBrandMenus.innerHTML = buildPaletteBrandCardUi(activeBrand, fixtures);
    return;
  }

  const cards = availableBrands.map(brand => buildPaletteBrandCardUi(brand, fixturesByBrand[brand] || []));
  el.paletteBrandMenus.innerHTML = cards.join("");
}

function applyPaletteRuntimeSnapshotToUi(snapshot = {}, options = {}) {
  const data = snapshot && typeof snapshot === "object" ? snapshot : {};
  const opts = options && typeof options === "object" ? options : {};
  if (Array.isArray(data.catalog) && data.catalog.length) {
    renderPaletteFamilyButtons(data.catalog);
  }
  applyPaletteSnapshotToUi(data.config || {}, {
    fixtureOverrides: data.fixtureOverrides || {},
    brandFixtures: data.brandFixtures || {}
  });
  applyFixtureMetricRoutingSnapshotToUi(data.metricRouting || {});
  renderPaletteBrandMenus({
    reason: "palette_runtime_snapshot",
    force: opts.forceRender === true
  });
}

function normalizeHexColor(value, fallback = "#8b001f") {
  const raw = String(value || "").trim().toLowerCase();
  if (/^#[0-9a-f]{6}$/.test(raw)) return raw;
  return String(fallback || "#8b001f").toLowerCase();
}

function hexToRgba(hex, alpha = 0.67) {
  const safe = normalizeHexColor(hex, "#8b001f");
  const r = parseInt(safe.slice(1, 3), 16);
  const g = parseInt(safe.slice(3, 5), 16);
  const b = parseInt(safe.slice(5, 7), 16);
  const a = Math.max(0, Math.min(1, Number(alpha) || 0));
  return `rgba(${r}, ${g}, ${b}, ${a.toFixed(3)})`;
}

function getThemePreset(name) {
  const key = String(name || "").trim().toLowerCase();
  if (THEME_PRESETS[key]) return { ...THEME_PRESETS[key] };
  return { ...THEME_PRESETS[DEFAULT_THEME_NAME] };
}

function normalizeThemeCustomConfig(customConfig = {}, fallbackPreset = {}) {
  const custom = customConfig && typeof customConfig === "object" ? customConfig : {};
  const fallback = fallbackPreset && typeof fallbackPreset === "object"
    ? fallbackPreset
    : getThemePreset(DEFAULT_THEME_NAME);
  return {
    bg: normalizeHexColor(custom.bg, fallback.bg),
    panel: normalizeHexColor(custom.panel, fallback.panel),
    panel2: normalizeHexColor(custom.panel2, fallback.panel2),
    accent: normalizeHexColor(custom.accent, fallback.accent),
    edge: normalizeHexColor(custom.edge, fallback.edge),
    btnBg: normalizeHexColor(custom.btnBg, fallback.btnBg),
    text: normalizeHexColor(custom.text, fallback.text)
  };
}

function applyThemeConfig(config = {}, options = {}) {
  const preset = getThemePreset(ui.themeName);
  const next = {
    ...preset,
    ...(config && typeof config === "object" ? config : {})
  };

  next.bg = normalizeHexColor(next.bg, preset.bg);
  next.panel = normalizeHexColor(next.panel, preset.panel);
  next.panel2 = normalizeHexColor(next.panel2, preset.panel2);
  next.accent = normalizeHexColor(next.accent, preset.accent);
  next.edge = normalizeHexColor(next.edge, preset.edge);
  next.btnBg = normalizeHexColor(next.btnBg, preset.btnBg);
  next.text = normalizeHexColor(next.text, preset.text);

  const root = document.documentElement;
  root.style.setProperty("--bg", next.bg);
  root.style.setProperty("--panel", next.panel);
  root.style.setProperty("--panel2", next.panel2);
  root.style.setProperty("--accent", next.accent);
  root.style.setProperty("--accentGlow", hexToRgba(next.accent, 0.67));
  root.style.setProperty("--edge", next.edge);
  root.style.setProperty("--btn-bg", next.btnBg);
  root.style.setProperty("--text", next.text);

  ui.themeConfig = next;

  if (options.persist !== false) {
    localStorage.setItem(
      THEME_STORAGE_KEY,
      JSON.stringify({
        name: ui.themeName,
        custom: normalizeThemeCustomConfig(next, preset)
      })
    );
  }
}

function setDevDebugMode(enabled, options = {}) {
  ui.devDebugMode = Boolean(enabled);

  if (el.ocDevCluster) {
    el.ocDevCluster.classList.toggle("hidden", !ui.devDebugMode);
  }
  if (el.devToolsPanel) {
    el.devToolsPanel.classList.toggle("hidden", !ui.devDebugMode);
  }
  if (el.devDebugToggleBtn) {
    el.devDebugToggleBtn.textContent = ui.devDebugMode ? "DEV DEBUG ON" : "DEV DEBUG OFF";
    el.devDebugToggleBtn.classList.toggle("active", ui.devDebugMode);
  }
  if (el.devDebugStatus) {
    el.devDebugStatus.textContent = ui.devDebugMode
      ? "DEV mode is ON. Unsafe 20-60Hz controls are unlocked. First destructive arm uses a one-time joke gate; later arms show warning-only."
      : "Unlocks destructive 20-60Hz overclock controls. Use only for controlled testing.";
  }

  if (options.persist !== false) {
    localStorage.setItem(DEV_DEBUG_KEY, ui.devDebugMode ? "1" : "0");
  }
}

function setDevToolsStatus(text) {
  if (!el.devToolsStatus) return;
  el.devToolsStatus.value = String(text || "").trim() || "DEV tools idle.";
}

function normalizeMidiAction(action) {
  return String(action || "").trim().toLowerCase();
}

function formatMidiActionLabel(action) {
  const key = normalizeMidiAction(action);
  return MIDI_ACTION_LABELS[key] || key.replace(/_/g, " ").toUpperCase();
}

function resolveMidiActionsList(snapshot = null) {
  const raw = Array.isArray(snapshot?.actions) ? snapshot.actions : [];
  const actions = raw
    .map(item => normalizeMidiAction(item))
    .filter(Boolean);
  if (actions.length) return Array.from(new Set(actions));
  return [...MIDI_FALLBACK_ACTIONS];
}

function parseMidiPortIndex(value) {
  const raw = String(value ?? "").trim();
  if (!raw) return null;
  const parsed = Number(raw);
  if (!Number.isInteger(parsed) || parsed < 0) return null;
  return parsed;
}

function formatMidiBinding(binding = null) {
  if (!binding || typeof binding !== "object") return "unbound";
  const type = String(binding.type || "").trim().toLowerCase() || "?";
  const number = Number(binding.number);
  const channel = Number(binding.channel);
  const minValue = Number(binding.minValue);
  const channelLabel = Number.isInteger(channel) && channel >= 0
    ? `ch${channel + 1}`
    : "any";
  const minLabel = Number.isFinite(minValue) ? `min${Math.round(minValue)}` : "min?";
  return `${type.toUpperCase()} #${Number.isFinite(number) ? Math.round(number) : "?"} ${channelLabel} ${minLabel}`;
}

function setMidiTabForced(next, options = {}) {
  ui.midiTabForced = Boolean(next);
  if (options.persist !== false) {
    if (ui.midiTabForced) localStorage.setItem(MIDI_TAB_FORCE_KEY, "1");
    else localStorage.removeItem(MIDI_TAB_FORCE_KEY);
  }
}

function applyMidiTabVisibility(options = {}) {
  const preserveTab = options.preserveTab !== false;
  const showMidiTab = Boolean(ui.midiDetected || ui.midiTabForced);

  if (el.midiTabBtn) {
    el.midiTabBtn.classList.toggle("hidden", !showMidiTab);
  }
  if (el.midiTabPage) {
    el.midiTabPage.classList.toggle("hidden", !showMidiTab);
  }
  if (el.systemStartTab) {
    const midiStartOption = el.systemStartTab.querySelector('option[value="midi"]');
    if (midiStartOption) midiStartOption.disabled = !showMidiTab;
    if (!showMidiTab && normalizeStartTabPreference(ui.startTabPreference) === "midi") {
      ui.startTabPreference = "live";
      localStorage.setItem(UI_START_TAB_KEY, ui.startTabPreference);
      if (el.systemStartTab.value === "midi") el.systemStartTab.value = "live";
      renderSystemSettingsStatus();
    }
  }

  if (el.midiTabToggleBtn) {
    const detected = Boolean(ui.midiDetected);
    const forced = Boolean(ui.midiTabForced);
    if (detected) {
      el.midiTabToggleBtn.textContent = "MIDI TAB AUTO (DEVICE DETECTED)";
      el.midiTabToggleBtn.disabled = true;
    } else {
      el.midiTabToggleBtn.disabled = false;
      el.midiTabToggleBtn.textContent = forced ? "MIDI TAB ON (NO DEVICE)" : "MIDI TAB OFF (NO DEVICE)";
    }
  }

  if (el.midiCogStatus) {
    if (ui.midiDetected) {
      el.midiCogStatus.value = "MIDI input detected. MIDI tab is always visible.";
    } else if (ui.midiTabForced) {
      el.midiCogStatus.value = "No MIDI input detected. MIDI tab forced ON from settings.";
    } else {
      el.midiCogStatus.value = "No MIDI input detected. MIDI tab hidden until detected.";
    }
  }

  if (!showMidiTab && ui.activeTab === "midi" && preserveTab) {
    showTab("live");
  }
}

function renderMidiActionsOptions(actions = []) {
  const list = Array.isArray(actions) && actions.length ? actions : [...MIDI_FALLBACK_ACTIONS];
  const normalizedList = Array.from(new Set(list.map(item => normalizeMidiAction(item)).filter(Boolean)));
  const targets = [el.midiLearnAction, el.midiBindingAction];

  targets.forEach(select => {
    if (!select) return;
    const current = normalizeMidiAction(select.value);
    select.innerHTML = "";
    normalizedList.forEach(action => {
      const option = document.createElement("option");
      option.value = action;
      option.textContent = formatMidiActionLabel(action);
      select.appendChild(option);
    });
    if (current && normalizedList.includes(current)) select.value = current;
    else if (normalizedList.length) select.value = normalizedList[0];
  });

  ui.midiActions = normalizedList;
}

function buildMidiBindingsDump(snapshot = null) {
  if (!snapshot || typeof snapshot !== "object") return "MIDI snapshot unavailable.";
  const config = snapshot.config && typeof snapshot.config === "object" ? snapshot.config : {};
  const bindings = config.bindings && typeof config.bindings === "object" ? config.bindings : {};
  const actions = resolveMidiActionsList(snapshot);

  const lines = [];
  lines.push(`moduleAvailable: ${Boolean(snapshot.moduleAvailable)}`);
  lines.push(`connected: ${Boolean(snapshot.connected)}`);
  lines.push(`portCount: ${Number(snapshot.portCount || 0)}`);
  lines.push(`activePort: ${String(snapshot.activePortName || "none")}`);
  lines.push(`enabled: ${Boolean(config.enabled)}`);
  lines.push(`deviceIndex: ${config.deviceIndex === null || config.deviceIndex === undefined ? "auto" : config.deviceIndex}`);
  lines.push(`deviceMatch: ${String(config.deviceMatch || "") || "<empty>"}`);
  lines.push(`velocityThreshold: ${Number(config.velocityThreshold || 0)}`);
  lines.push("");
  lines.push("bindings:");
  actions.forEach(action => {
    lines.push(`- ${action}: ${formatMidiBinding(bindings[action])}`);
  });
  return lines.join("\n");
}

function formatMidiEvent(snapshot = null) {
  const msg = snapshot?.lastMessage;
  if (!msg || typeof msg !== "object") return "none";
  const type = String(msg.type || "?").toUpperCase();
  const channel = Number(msg.channel);
  const number = Number(msg.number);
  const value = Number(msg.value);
  const stamp = msg.at ? new Date(msg.at).toLocaleTimeString() : "";
  const channelLabel = Number.isInteger(channel) && channel >= 0 ? `ch${channel + 1}` : "any";
  return `${type} #${Number.isFinite(number) ? Math.round(number) : "?"} ${channelLabel} v${Number.isFinite(value) ? Math.round(value) : "?"}${stamp ? ` @ ${stamp}` : ""}`;
}

function populateMidiPorts(snapshot = null) {
  if (!el.midiPortSelect) return;
  const ports = Array.isArray(snapshot?.ports) ? snapshot.ports : [];
  const config = snapshot?.config && typeof snapshot.config === "object" ? snapshot.config : {};
  const selectedIndex = parseMidiPortIndex(config.deviceIndex);

  el.midiPortSelect.innerHTML = "";
  const autoOption = document.createElement("option");
  autoOption.value = "";
  autoOption.textContent = "AUTO SELECT";
  el.midiPortSelect.appendChild(autoOption);

  ports.forEach(port => {
    const idx = parseMidiPortIndex(port?.index);
    if (idx === null) return;
    const option = document.createElement("option");
    option.value = String(idx);
    option.textContent = `${idx} | ${String(port?.name || `port ${idx}`)}`;
    el.midiPortSelect.appendChild(option);
  });

  el.midiPortSelect.value = selectedIndex === null ? "" : String(selectedIndex);
}

function applyMidiBindingEditor(snapshot = null) {
  const config = snapshot?.config && typeof snapshot.config === "object" ? snapshot.config : {};
  const bindings = config.bindings && typeof config.bindings === "object" ? config.bindings : {};
  const action = normalizeMidiAction(el.midiBindingAction?.value || el.midiLearnAction?.value || "");
  const binding = bindings[action];
  const suggestedCc =
    action.includes("overclock") ||
    action.includes("meta_auto") ||
    action.includes("flow_intensity");
  const fallbackType = suggestedCc ? "cc" : "note";
  const fallbackNumber = suggestedCc ? 64 : 36;
  const fallbackMin = suggestedCc ? 64 : 1;

  if (el.midiBindingType) el.midiBindingType.value = String(binding?.type || fallbackType).toLowerCase() === "cc" ? "cc" : "note";
  if (el.midiBindingNumber) el.midiBindingNumber.value = Number.isFinite(Number(binding?.number)) ? String(Number(binding.number)) : String(fallbackNumber);
  if (el.midiBindingChannel) {
    el.midiBindingChannel.value = Number.isInteger(Number(binding?.channel))
      ? String(Number(binding.channel) + 1)
      : "";
  }
  if (el.midiBindingMinValue) {
    const defaultMin = (String(el.midiBindingType?.value || fallbackType).toLowerCase() === "cc") ? 64 : fallbackMin;
    el.midiBindingMinValue.value = Number.isFinite(Number(binding?.minValue))
      ? String(Number(binding.minValue))
      : String(defaultMin);
  }
}

function applyMidiSnapshot(snapshot = null) {
  if (!snapshot || typeof snapshot !== "object") return;
  ui.midiSnapshot = snapshot;
  ui.midiConfigLoaded = true;

  const hasPorts = Number(snapshot.portCount || 0) > 0;
  ui.midiDetected = Boolean(snapshot.moduleAvailable && (snapshot.connected || hasPorts));

  if (el.midiModuleStatus) {
    el.midiModuleStatus.value = snapshot.moduleAvailable
      ? "module ready"
      : `module unavailable${snapshot.moduleError ? `: ${snapshot.moduleError}` : ""}`;
  }
  if (el.midiRuntimeStatus) {
    el.midiRuntimeStatus.value = snapshot.connected
      ? "listening"
      : (snapshot.config?.enabled === false ? "disabled" : "not connected");
  }
  if (el.midiActivePort) {
    const portLabel = snapshot.connected
      ? `${snapshot.activePortIndex ?? "-"} | ${snapshot.activePortName || "unknown"}`
      : "none";
    el.midiActivePort.value = portLabel;
  }
  if (el.midiLearnStatus) {
    const learnTarget = normalizeMidiAction(snapshot.learn?.target);
    if (learnTarget) {
      const expire = Number(snapshot.learn?.expiresAt || 0);
      const ttlSec = expire > Date.now() ? Math.max(1, Math.round((expire - Date.now()) / 1000)) : 0;
      el.midiLearnStatus.value = `learning ${formatMidiActionLabel(learnTarget)} (${ttlSec}s)`;
    } else {
      el.midiLearnStatus.value = "idle";
    }
  }
  if (el.midiLastEvent) {
    el.midiLastEvent.value = formatMidiEvent(snapshot);
  }
  if (el.midiLastAction) {
    el.midiLastAction.value = String(snapshot.lastAction || "none");
  }
  if (el.midiEnabled) {
    el.midiEnabled.value = snapshot.config?.enabled === false ? "false" : "true";
  }
  if (el.midiVelocityThreshold) {
    const threshold = Number(snapshot.config?.velocityThreshold);
    el.midiVelocityThreshold.value = Number.isFinite(threshold)
      ? String(Math.max(0, Math.min(127, Math.round(threshold))))
      : "1";
  }
  if (el.midiDeviceMatch) {
    el.midiDeviceMatch.value = String(snapshot.config?.deviceMatch || "");
  }

  populateMidiPorts(snapshot);
  renderMidiActionsOptions(resolveMidiActionsList(snapshot));
  applyMidiBindingEditor(snapshot);
  if (el.midiBindingsDump) {
    el.midiBindingsDump.value = buildMidiBindingsDump(snapshot);
  }
  applyMidiTabVisibility();
}

function collectMidiConfigPatch() {
  return {
    enabled: String(el.midiEnabled?.value || "true").toLowerCase() !== "false",
    deviceIndex: parseMidiPortIndex(el.midiPortSelect?.value),
    deviceMatch: String(el.midiDeviceMatch?.value || "").trim(),
    velocityThreshold: Math.max(0, Math.min(127, Number(el.midiVelocityThreshold?.value || 1) || 1))
  };
}

function collectMidiBindingPatch() {
  const type = String(el.midiBindingType?.value || "note").trim().toLowerCase() === "cc" ? "cc" : "note";
  const number = Math.max(0, Math.min(127, Math.round(Number(el.midiBindingNumber?.value || 0) || 0)));
  const channelRaw = String(el.midiBindingChannel?.value || "").trim();
  const channel = channelRaw
    ? Math.max(0, Math.min(15, Math.round(Number(channelRaw) || 1) - 1))
    : null;
  const minFallback = type === "cc" ? 64 : 1;
  const minValue = Math.max(0, Math.min(127, Math.round(Number(el.midiBindingMinValue?.value || minFallback) || minFallback)));

  return { type, number, channel, minValue };
}

async function loadMidiStatus(options = {}) {
  const refresh = options.refresh === true;
  if (refresh) {
    const response = await postJson("/midi/refresh", {});
    if (!response.ok || !response.data) return false;
    applyMidiSnapshot(response.data);
    return true;
  }

  const snapshot = await getJson("/midi/status");
  if (!snapshot || snapshot.ok === false) return false;
  applyMidiSnapshot(snapshot);
  return true;
}

function toSafeJsonString(payload, fallback = "") {
  try {
    const seen = new WeakSet();
    return JSON.stringify(payload, (key, value) => {
      if (value && typeof value === "object") {
        if (seen.has(value)) return "[Circular]";
        seen.add(value);
      }
      return value;
    }, 2);
  } catch {
    return String(fallback || "");
  }
}

function setDevToolsDump(payload, label = "") {
  if (!el.devToolsDump) return;
  const header = String(label || "").trim();
  const body = typeof payload === "string"
    ? payload
    : toSafeJsonString(payload, "[unserializable payload]");
  const full = header ? `${header}\n${body}` : body;
  el.devToolsDump.value = full.length > 50000 ? `${full.slice(0, 50000)}\n...[truncated]` : full;
}

async function runDevToolsProbe(label, path) {
  const name = String(label || "DEV TOOL").trim();
  setDevToolsStatus(`${name}: querying...`);
  const snapshot = await getJson(path);
  if (!snapshot) {
    setDevToolsStatus(`${name}: failed`);
    setBadge(el.health, "bad", `${name} FAIL`);
    return false;
  }
  setDevToolsStatus(`${name}: ok @ ${new Date().toLocaleTimeString()}`);
  setDevToolsDump(snapshot, `${name} ${path}`);
  setBadge(el.health, "ok", `${name} OK`);
  return true;
}

function closeDevOverclockAckGate(confirmed) {
  if (devOcAckKeydownHandler) {
    document.removeEventListener("keydown", devOcAckKeydownHandler);
    devOcAckKeydownHandler = null;
  }
  if (el.devOcAckGate) {
    el.devOcAckGate.classList.add("hidden");
    el.devOcAckGate.setAttribute("aria-hidden", "true");
  }
  if (el.devOcAckInput) el.devOcAckInput.value = "";
  if (devOcAckResolver) {
    const resolve = devOcAckResolver;
    devOcAckResolver = null;
    resolve(Boolean(confirmed));
  }
}

function openDevOverclockAckGate(hz) {
  if (!el.devOcAckGate || !el.devOcAckInput || !el.devOcAckPhrase) {
    return Promise.resolve(false);
  }
  if (devOcAckResolver) {
    devOcAckResolver(false);
    devOcAckResolver = null;
  }

  el.devOcAckPhrase.value = DEV_OVERCLOCK_COMICAL_TEXT;
  el.devOcAckInput.value = "";
  el.devOcAckGate.classList.remove("hidden");
  el.devOcAckGate.setAttribute("aria-hidden", "false");

  return new Promise(resolve => {
    devOcAckResolver = resolve;
    devOcAckKeydownHandler = ev => {
      if (!el.devOcAckGate || el.devOcAckGate.classList.contains("hidden")) {
        if (devOcAckKeydownHandler) {
          document.removeEventListener("keydown", devOcAckKeydownHandler);
          devOcAckKeydownHandler = null;
        }
        return;
      }
      if (ev.key === "Escape") {
        ev.preventDefault();
        closeDevOverclockAckGate(false);
        return;
      }
      if (ev.key === "Enter") {
        ev.preventDefault();
        const typed = String(el.devOcAckInput.value || "").trim();
        if (!typed) {
          closeDevOverclockAckGate(false);
          return;
        }
        closeDevOverclockAckGate(typed.toUpperCase() === DEV_OVERCLOCK_COMICAL_TEXT);
      }
    };
    document.addEventListener("keydown", devOcAckKeydownHandler);

    setTimeout(() => {
      if (el.devOcAckInput) el.devOcAckInput.focus();
    }, 0);
  });
}

function confirmDevDebugEnableOnce() {
  if (ui.devDebugWarned) return true;
  const proceed = window.confirm(
    "DEV/DEBUG MODE unlocks destructive 20-60Hz overclock.\n\n" +
    "This warning appears once. Continue?"
  );
  if (!proceed) return false;
  ui.devDebugWarned = true;
  localStorage.setItem(DEV_DEBUG_WARN_ONCE_KEY, "1");
  return true;
}

function confirmUnsafeSensitiveLogEnable() {
  const proceed = window.confirm(
    "DANGER: This will disable server log redaction and expose sensitive values in plain text logs.\n\n" +
    "Exposed data may include Hue usernames/client keys, bridge ids, entertainment area ids, bearer/access tokens, auth headers/cookies, and private IP/host data.\n\n" +
    "Logs can be copied, indexed, uploaded, or retained by other tools.\n\n" +
    "Continue?"
  );
  if (!proceed) return { ok: false, ack: "" };

  const typed = String(
    window.prompt(
      `Type exactly ${UNSAFE_LOG_ACK_PHRASE} to confirm you understand the risk:`,
      ""
    ) || ""
  ).trim();

  if (typed !== UNSAFE_LOG_ACK_PHRASE) {
    return { ok: false, ack: "" };
  }

  return { ok: true, ack: typed };
}

function normalizeModUiId(value) {
  return String(value || "").trim();
}

function normalizeModUiCatalogEntries(entries = []) {
  const seen = new Set();
  const out = [];
  for (const item of (Array.isArray(entries) ? entries : [])) {
    const id = normalizeModUiId(item?.id);
    if (!id || seen.has(id)) continue;
    seen.add(id);

    const title = String(item?.title || item?.name || id).trim() || id;
    const loaded = Boolean(item?.loaded);
    const enabled = Boolean(item?.enabled);
    const entry = String(item?.entry || "").trim();
    const url = loaded ? (String(item?.url || `/mods-ui/${encodeURIComponent(id)}/`).trim()) : "";

    out.push({
      id,
      name: String(item?.name || id).trim() || id,
      version: String(item?.version || "").trim(),
      title,
      entry,
      enabled,
      loaded,
      url
    });
  }
  return out;
}

function formatModUiTabLabel(item = {}) {
  const raw = String(item?.title || item?.name || item?.id || "MOD UI").trim();
  if (raw.length <= 20) return raw.toUpperCase();
  return `${raw.slice(0, 17).trimEnd()}...`.toUpperCase();
}

function syncDynamicModUiTabButtons() {
  if (!el.tabsBar) return;
  const selectedId = normalizeModUiId(ui.modUiSelectedId);
  const modsTabActive = ui.activeTab === "mods";
  const dynamicTabs = Array.from(el.tabsBar.querySelectorAll(".modUiDynamicTab"));
  dynamicTabs.forEach(btn => {
    const id = normalizeModUiId(btn.dataset.modUiTabId);
    btn.classList.toggle("active", modsTabActive && id === selectedId);
  });
}

function rebuildDynamicModUiTabs() {
  if (!el.tabsBar) return;
  Array.from(el.tabsBar.querySelectorAll(".modUiDynamicTab")).forEach(node => node.remove());

  for (const item of ui.modUiCatalog) {
    const id = normalizeModUiId(item?.id);
    if (!id || !item.loaded) continue;
    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = "tabBtn modUiDynamicTab";
    btn.dataset.modUiTabId = id;
    btn.textContent = formatModUiTabLabel(item);
    const route = `/mods-ui/${encodeURIComponent(id)}/`;
    btn.title = `Open ${item.title || id} UI (${route})`;
    el.tabsBar.appendChild(btn);
  }

  syncDynamicModUiTabButtons();
}

function buildModUiCatalogFromModsSnapshot(snapshot) {
  const mods = Array.isArray(snapshot?.mods) ? snapshot.mods : [];
  return normalizeModUiCatalogEntries(mods
    .filter(mod => mod && mod.ui)
    .map(mod => ({
      id: mod.id,
      name: mod.name,
      version: mod.version,
      enabled: Boolean(mod.enabled),
      loaded: Boolean(mod.loaded),
      title: mod.ui?.title || mod.name || mod.id,
      entry: mod.ui?.entry || "",
      url: mod.loaded ? `/mods-ui/${encodeURIComponent(String(mod.id || "").trim())}/` : ""
    })));
}

function getSelectedModUiDescriptor() {
  const selectedId = normalizeModUiId(ui.modUiSelectedId);
  if (!selectedId) return null;
  return ui.modUiCatalog.find(item => item.id === selectedId) || null;
}

function syncModUiSelectionToHotswapTarget(options = {}) {
  if (!el.modEnableId) return;
  const explicitId = normalizeModUiId(options.modId);
  const selectedId = explicitId || normalizeModUiId(ui.modUiSelectedId);
  if (!selectedId) return;
  const current = String(el.modEnableId.value || "").trim();
  const force = options.force === true;
  if (!current || force) {
    el.modEnableId.value = selectedId;
  }
}

function buildModUiFrameUrl(descriptor, options = {}) {
  const baseUrl = String(descriptor?.url || "").trim();
  if (!baseUrl) return "";
  const descriptorId = normalizeModUiId(descriptor?.id);
  const forceReload = options.forceReload === true;
  if (!forceReload && ui.modUiLastUrl && ui.modUiLastId === descriptorId) {
    return ui.modUiLastUrl;
  }
  const ts = Date.now();
  const joiner = baseUrl.includes("?") ? "&" : "?";
  return `${baseUrl}${joiner}host=modui&ts=${ts}`;
}

function renderModUiFrame(options = {}) {
  const frame = el.modUiFrame;
  const frameWrap = el.modUiFrameWrap;
  const empty = el.modUiEmpty;
  const status = el.modUiStatus;

  const descriptor = getSelectedModUiDescriptor();
  if (!descriptor) {
    if (frame) frame.src = "about:blank";
    if (frameWrap) frameWrap.classList.add("hidden");
    if (empty) {
      empty.classList.remove("hidden");
      empty.textContent = "No mod UI packages discovered. Add a UI HTML file in a mod folder and reload mods.";
    }
    if (status) status.value = "No mod UI packages discovered.";
    if (el.modUiOpenBtn) el.modUiOpenBtn.disabled = true;
    if (el.modUiReloadBtn) el.modUiReloadBtn.disabled = true;
    ui.modUiLastId = "";
    ui.modUiLastUrl = "";
    syncDynamicModUiTabButtons();
    return;
  }

  if (!descriptor.loaded || !descriptor.url) {
    syncModUiSelectionToHotswapTarget({ modId: descriptor.id });
    if (frame) frame.src = "about:blank";
    if (frameWrap) frameWrap.classList.add("hidden");
    if (empty) {
      empty.classList.remove("hidden");
      empty.textContent = `Selected mod UI (${descriptor.id}) is offline. Enable the mod and click APPLY HOTSWAP to mount its UI.`;
    }
    if (status) status.value = `${descriptor.id} UI is offline (mod not loaded).`;
    if (el.modUiOpenBtn) el.modUiOpenBtn.disabled = true;
    if (el.modUiReloadBtn) el.modUiReloadBtn.disabled = true;
    ui.modUiLastId = "";
    ui.modUiLastUrl = "";
    syncDynamicModUiTabButtons();
    return;
  }

  const nextUrl = buildModUiFrameUrl(descriptor, options);
  if (frame && nextUrl && (
    options.forceReload === true ||
    ui.modUiLastId !== normalizeModUiId(descriptor.id) ||
    ui.modUiLastUrl !== nextUrl
  )) {
    frame.src = withBase(nextUrl);
    ui.modUiLastId = normalizeModUiId(descriptor.id);
    ui.modUiLastUrl = nextUrl;
    ui.modUiLoadedAt = Date.now();
  }

  if (frameWrap) frameWrap.classList.remove("hidden");
  if (empty) empty.classList.add("hidden");
  if (status) status.value = `${descriptor.title} (${descriptor.id}) loaded`;
  if (el.modUiOpenBtn) el.modUiOpenBtn.disabled = false;
  if (el.modUiReloadBtn) el.modUiReloadBtn.disabled = false;
  syncDynamicModUiTabButtons();
}

function applyModUiCatalog(catalog = [], options = {}) {
  ui.modUiCatalog = normalizeModUiCatalogEntries(catalog);

  const previousSelectedId = normalizeModUiId(
    options.selectedId !== undefined ? options.selectedId : ui.modUiSelectedId
  );
  const hasPrevious = previousSelectedId && ui.modUiCatalog.some(item => item.id === previousSelectedId);
  const firstLoaded = ui.modUiCatalog.find(item => item.loaded);
  const nextSelectedId = hasPrevious
    ? previousSelectedId
    : normalizeModUiId(firstLoaded?.id || ui.modUiCatalog[0]?.id || "");

  ui.modUiSelectedId = nextSelectedId;
  if (options.persist !== false) {
    if (nextSelectedId) localStorage.setItem(MOD_UI_SELECTED_KEY, nextSelectedId);
    else localStorage.removeItem(MOD_UI_SELECTED_KEY);
  }

  if (el.modUiSelect) {
    el.modUiSelect.replaceChildren();
    const placeholder = document.createElement("option");
    placeholder.value = "";
    placeholder.textContent = ui.modUiCatalog.length
      ? "select mod UI"
      : "no mod UI packages discovered";
    el.modUiSelect.appendChild(placeholder);

    for (const item of ui.modUiCatalog) {
      const opt = document.createElement("option");
      opt.value = item.id;
      const stateWord = item.loaded ? "LIVE" : "OFFLINE";
      const enabledWord = item.enabled ? "ENABLED" : "DISABLED";
      opt.textContent = `${item.title} (${item.id}) [${stateWord} | ${enabledWord}]`;
      el.modUiSelect.appendChild(opt);
    }
    el.modUiSelect.value = nextSelectedId || "";
  }

  syncModUiSelectionToHotswapTarget();
  rebuildDynamicModUiTabs();
  renderModUiFrame({ forceReload: options.forceReload === true });
}

function syncModUiCatalogFromModsSnapshot(snapshot, options = {}) {
  const catalog = buildModUiCatalogFromModsSnapshot(snapshot);
  applyModUiCatalog(catalog, options);
}

async function refreshModUiCatalog(options = {}) {
  const preferRemote = options.preferRemote !== false;
  if (preferRemote) {
    const remote = await getJson("/mods/ui/catalog");
    if (remote?.ok && Array.isArray(remote.mods)) {
      applyModUiCatalog(remote.mods, options);
      return true;
    }
  }
  syncModUiCatalogFromModsSnapshot(ui.modsSnapshot || {}, options);
  return Array.isArray(ui.modUiCatalog);
}

function syncThemeUi() {
  const accent = normalizeHexColor(ui.themeConfig?.accent, THEME_PRESETS[DEFAULT_THEME_NAME].accent);
  const btnBg = normalizeHexColor(ui.themeConfig?.btnBg, THEME_PRESETS[DEFAULT_THEME_NAME].btnBg);
  if (el.themeLogoColor) el.themeLogoColor.value = accent;
  if (el.themeButtonColor) el.themeButtonColor.value = btnBg;

  themePresetButtons.forEach(btn => {
    const name = String(btn.dataset.themePreset || "").trim().toLowerCase();
    btn.classList.toggle("active", name === ui.themeName);
  });
}

function applyThemePreset(name, options = {}) {
  ui.themeName = String(name || DEFAULT_THEME_NAME).trim().toLowerCase();
  if (!THEME_PRESETS[ui.themeName]) ui.themeName = DEFAULT_THEME_NAME;
  applyThemeConfig(getThemePreset(ui.themeName), options);
  syncThemeUi();
}

function toggleThemePanel(open) {
  const nextOpen = open === undefined
    ? el.themePanel.classList.contains("hidden")
    : Boolean(open);
  el.themePanel.classList.toggle("hidden", !nextOpen);
}

function initThemeSettings() {
  let loaded = null;
  try {
    loaded = JSON.parse(localStorage.getItem(THEME_STORAGE_KEY) || "null");
  } catch {}

  const loadedNameRaw = String(loaded?.name || "").trim().toLowerCase();
  const hasStoredTheme = loaded && typeof loaded === "object";
  const hasValidStoredThemeName = Boolean(THEME_PRESETS[loadedNameRaw]);
  const loadedName = hasValidStoredThemeName ? loadedNameRaw : DEFAULT_THEME_NAME;
  ui.themeName = loadedName;
  const preset = getThemePreset(ui.themeName);
  const custom = normalizeThemeCustomConfig(loaded?.custom, preset);
  const shouldPersistTheme =
    !hasStoredTheme ||
    !hasValidStoredThemeName;

  applyThemeConfig(
    {
      ...preset,
      ...custom
    },
    { persist: shouldPersistTheme }
  );
  syncThemeUi();
  setDevDebugMode(ui.devDebugMode, { persist: false });
  setDevToolsStatus(ui.devDebugMode ? "DEV tools idle." : "DEV tools hidden. Enable DEV DEBUG to use probes.");
  applyMidiTabVisibility({ preserveTab: false });

  themePresetButtons.forEach(btn => {
    btn.onclick = () => {
      applyThemePreset(btn.dataset.themePreset || DEFAULT_THEME_NAME);
    };
  });

  if (el.themeLogoColor) {
    el.themeLogoColor.oninput = () => {
      applyThemeConfig({ ...ui.themeConfig, accent: el.themeLogoColor.value });
      syncThemeUi();
    };
  }
  if (el.themeButtonColor) {
    el.themeButtonColor.oninput = () => {
      applyThemeConfig({ ...ui.themeConfig, btnBg: el.themeButtonColor.value });
      syncThemeUi();
    };
  }
  if (el.themeResetBtn) {
    el.themeResetBtn.onclick = () => {
      applyThemePreset(DEFAULT_THEME_NAME);
    };
  }
  if (el.devDebugToggleBtn) {
    el.devDebugToggleBtn.onclick = () => {
      const next = !ui.devDebugMode;
      if (next) {
        if (!confirmDevDebugEnableOnce()) {
          setBadge(el.health, "warn", "DEV DEBUG ENABLE CANCELED");
          return;
        }
      }

      setDevDebugMode(next);
      setDevToolsStatus(next ? "DEV tools idle." : "DEV tools hidden. Enable DEV DEBUG to use probes.");
      setBadge(el.health, next ? "warn" : "ok", next ? "DEV DEBUG ON" : "DEV DEBUG OFF");
      sync();
    };
  }
  if (el.midiTabToggleBtn) {
    el.midiTabToggleBtn.onclick = () => {
      if (ui.midiDetected) {
        setBadge(el.health, "ok", "MIDI DETECTED: TAB AUTO-VISIBLE");
        return;
      }
      setMidiTabForced(!ui.midiTabForced);
      applyMidiTabVisibility();
      setBadge(el.health, "ok", ui.midiTabForced ? "MIDI TAB FORCED ON" : "MIDI TAB AUTO-HIDDEN");
    };
  }
  if (el.devToolRuntimeBtn) {
    el.devToolRuntimeBtn.onclick = () => runDevToolsProbe("RUNTIME", "/mods/runtime");
  }
  if (el.devToolConnectivityBtn) {
    el.devToolConnectivityBtn.onclick = () => runDevToolsProbe("CONNECTIVITY", "/fixtures/connectivity");
  }
  if (el.devToolHooksBtn) {
    el.devToolHooksBtn.onclick = () => runDevToolsProbe("MOD HOOKS", "/mods/hooks");
  }
  if (el.devToolTiersBtn) {
    el.devToolTiersBtn.onclick = () => runDevToolsProbe("OC TIERS", "/rave/overclock/tiers");
  }
  if (el.devOcAckCancelBtn) {
    el.devOcAckCancelBtn.onclick = () => closeDevOverclockAckGate(false);
  }
  if (el.devOcAckConfirmBtn) {
    el.devOcAckConfirmBtn.onclick = () => {
      const typed = String(el.devOcAckInput?.value || "").trim();
      if (!typed) {
        closeDevOverclockAckGate(false);
        return;
      }
      closeDevOverclockAckGate(typed.toUpperCase() === DEV_OVERCLOCK_COMICAL_TEXT);
    };
  }
  if (el.devOcAckGate) {
    el.devOcAckGate.onclick = ev => {
      if (ev.target === el.devOcAckGate) {
        closeDevOverclockAckGate(false);
      }
    };
  }
  if (el.themeCloseBtn) {
    el.themeCloseBtn.onclick = () => toggleThemePanel(false);
  }
  if (el.themeCogBtn) {
    el.themeCogBtn.onclick = () => toggleThemePanel();
  }

  document.addEventListener("click", ev => {
    if (!el.themePanel || el.themePanel.classList.contains("hidden")) return;
    const target = ev.target;
    const clickedInsidePanel = el.themePanel.contains(target);
    const clickedCog = el.themeCogBtn && (target === el.themeCogBtn || el.themeCogBtn.contains(target));
    if (!clickedInsidePanel && !clickedCog) {
      toggleThemePanel(false);
    }
  });
}

function setObsDockCompact(compact, options = {}) {
  ui.obsDockCompact = Boolean(compact);
  document.body.classList.toggle("obsDockCompact", ui.obsDockCompact);
  if (el.obsDockCompactBtn) {
    el.obsDockCompactBtn.textContent = ui.obsDockCompact ? "DK+" : "DK";
    el.obsDockCompactBtn.title = ui.obsDockCompact
      ? "Switch to expanded OBS dock layout"
      : "Switch to compact OBS dock layout";
  }
  if (options.persist !== false) {
    localStorage.setItem(OBS_DOCK_COMPACT_KEY, ui.obsDockCompact ? "1" : "0");
  }
}

function initObsDockMode() {
  if (!ui.obsDockMode) return;
  document.body.classList.add("obsDockMode");
  if (el.obsDockCompactBtn) {
    el.obsDockCompactBtn.classList.remove("hidden");
    el.obsDockCompactBtn.onclick = () => {
      setObsDockCompact(!ui.obsDockCompact);
    };
  }
  setObsDockCompact(ui.obsDockCompact, { persist: false });
}

async function api(path) {
  try {
    const res = await fetch(withBase(path), { method: "POST" });
    return res.ok;
  } catch {
    return false;
  }
}

async function getJson(path) {
  try {
    const res = await fetch(withBase(path), { cache: "no-store" });
    if (!res.ok) return null;
    return await res.json();
  } catch {
    return null;
  }
}

async function postJson(path, body) {
  try {
    const res = await fetch(withBase(path), {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body || {})
    });

    const text = await res.text();
    let json = null;
    try { json = text ? JSON.parse(text) : null; } catch {}

    return { ok: res.ok, status: res.status, data: json };
  } catch {
    return { ok: false, status: 0, data: null };
  }
}

async function deleteJson(path) {
  try {
    const res = await fetch(withBase(path), { method: "DELETE" });
    const text = await res.text();
    let json = null;
    try { json = text ? JSON.parse(text) : null; } catch {}
    return { ok: res.ok, status: res.status, data: json };
  } catch {
    return { ok: false, status: 0, data: null };
  }
}

function normalizeApiBaseInput(raw) {
  const value = String(raw || "").trim();
  if (!value) return "";
  let candidate = value;
  // Allow "host:port" shorthand by assuming http.
  if (!/^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(candidate)) {
    candidate = `http://${candidate}`;
  }
  let parsed = null;
  try {
    parsed = new URL(candidate);
  } catch {
    return "";
  }
  if (parsed.protocol !== "http:" && parsed.protocol !== "https:") {
    return "";
  }
  parsed.hash = "";
  parsed.search = "";
  return parsed.toString().replace(/\/+$/, "");
}

function applyApiBaseUi() {
  el.apiBaseInput.value = apiBase || "";
}

function setApiBase(nextBase, options = {}) {
  const normalized = normalizeApiBaseInput(nextBase);
  apiBase = normalized;

  if (options.persist !== false) {
    if (normalized) {
      localStorage.setItem("rave_api_base", normalized);
    } else {
      localStorage.removeItem("rave_api_base");
    }
  }

  applyApiBaseUi();
}

const START_TAB_VALUES = new Set(["live", "fixtures", "audio", "midi", "custom", "mods", "system"]);

function normalizeStartTabPreference(value) {
  const raw = String(value || "").trim().toLowerCase();
  return START_TAB_VALUES.has(raw) ? raw : "live";
}

function normalizeHueTransportPreference(value) {
  return String(value || "").trim().toLowerCase() === "rest" ? "rest" : "auto";
}

function shouldConfirmDangerousAction() {
  return ui.confirmDangerousActions !== false;
}

function updatePollIndicator() {
  if (!el.pollMs) return;
  el.pollMs.textContent = ui.pollPaused ? "PAUSED" : String(pollIntervalMs);
}

function renderSystemSettingsStatus() {
  if (!el.systemSettingsStatus) return;
  const startTab = normalizeStartTabPreference(ui.startTabPreference).toUpperCase();
  const confirms = ui.confirmDangerousActions ? "CONFIRM ON" : "CONFIRM OFF";
  const polling = ui.pollPaused ? "POLL PAUSED" : "POLL LIVE";
  const browserLaunch = ui.serverAutoLaunchBrowser ? "BROWSER AUTO ON" : "BROWSER AUTO OFF";
  const hueTransport = normalizeHueTransportPreference(ui.serverHueTransportPreference) === "rest"
    ? "HUE REST ONLY"
    : "HUE AUTO";
  const logsMode = ui.serverUnsafeSensitiveLogs ? "LOG REDACTION OFF (DEV RISK)" : "LOG REDACTION ON";
  el.systemSettingsStatus.value = `${startTab} | ${confirms} | ${polling} | ${browserLaunch} | ${hueTransport} | ${logsMode}`;
}

function applySystemSettingsUi() {
  if (el.systemStartTab) {
    el.systemStartTab.value = normalizeStartTabPreference(ui.startTabPreference);
  }
  if (el.systemConfirmActions) {
    el.systemConfirmActions.value = ui.confirmDangerousActions ? "true" : "false";
  }
  if (el.systemPollingMode) {
    el.systemPollingMode.value = ui.pollPaused ? "paused" : "live";
  }
  if (el.systemAutoLaunchBrowser) {
    el.systemAutoLaunchBrowser.value = ui.serverAutoLaunchBrowser ? "true" : "false";
  }
  if (el.systemHueTransportPreference) {
    el.systemHueTransportPreference.value = normalizeHueTransportPreference(ui.serverHueTransportPreference);
  }
  if (el.systemUnsafeSensitiveLogs) {
    el.systemUnsafeSensitiveLogs.value = ui.serverUnsafeSensitiveLogs ? "true" : "false";
  }
  updatePollIndicator();
  if (ui.pollPaused && el.netBadge) {
    setBadge(el.netBadge, "warn", "POLL PAUSED");
  }
  renderSystemSettingsStatus();
  applyModeUiPolicy();
}

function saveSystemSettingsFromUi() {
  const previousPaused = ui.pollPaused;
  ui.startTabPreference = normalizeStartTabPreference(el.systemStartTab?.value || ui.startTabPreference);
  ui.confirmDangerousActions = String(el.systemConfirmActions?.value || "true").trim().toLowerCase() !== "false";
  ui.pollPaused = String(el.systemPollingMode?.value || "live").trim().toLowerCase() === "paused";
  ui.serverAutoLaunchBrowser = String(el.systemAutoLaunchBrowser?.value || "true").trim().toLowerCase() !== "false";
  ui.serverHueTransportPreference = normalizeHueTransportPreference(el.systemHueTransportPreference?.value || "auto");
  ui.serverUnsafeSensitiveLogs = String(el.systemUnsafeSensitiveLogs?.value || "false").trim().toLowerCase() === "true";

  localStorage.setItem(UI_START_TAB_KEY, ui.startTabPreference);
  localStorage.setItem(UI_CONFIRM_DANGER_KEY, ui.confirmDangerousActions ? "1" : "0");
  localStorage.setItem(UI_POLL_PAUSED_KEY, ui.pollPaused ? "1" : "0");
  applySystemSettingsUi();
  return { pollingChanged: previousPaused !== ui.pollPaused };
}

function resetSystemSettingsToDefaults() {
  ui.startTabPreference = "live";
  ui.confirmDangerousActions = true;
  ui.pollPaused = false;
  ui.serverAutoLaunchBrowser = true;
  ui.serverHueTransportPreference = "auto";
  ui.serverUnsafeSensitiveLogs = false;
  ui.serverUnsafeSensitiveLogsBaseline = false;
  localStorage.removeItem(UI_START_TAB_KEY);
  localStorage.removeItem(UI_CONFIRM_DANGER_KEY);
  localStorage.removeItem(UI_POLL_PAUSED_KEY);
  applySystemSettingsUi();
}

async function loadSystemServerConfig() {
  const response = await getJson("/system/config");
  if (!response || response.ok !== true || !response.config) return false;
  ui.serverAutoLaunchBrowser = response.config.autoLaunchBrowser !== false;
  ui.serverHueTransportPreference = normalizeHueTransportPreference(response.config.hueTransportPreference);
  ui.serverUnsafeSensitiveLogs = response.config.unsafeExposeSensitiveLogs === true;
  ui.serverUnsafeSensitiveLogsBaseline = ui.serverUnsafeSensitiveLogs;
  applySystemSettingsUi();
  return true;
}

async function saveSystemServerSettingsFromUi() {
  const enablingUnsafeLogs = ui.serverUnsafeSensitiveLogs === true && ui.serverUnsafeSensitiveLogsBaseline !== true;
  let unsafeAck = "";
  if (enablingUnsafeLogs) {
    const ack = confirmUnsafeSensitiveLogEnable();
    if (!ack.ok) {
      ui.serverUnsafeSensitiveLogs = ui.serverUnsafeSensitiveLogsBaseline === true;
      applySystemSettingsUi();
      return { ok: false, error: "unsafe sensitive log mode enable cancelled" };
    }
    unsafeAck = ack.ack;
  }

  const payload = {
    autoLaunchBrowser: ui.serverAutoLaunchBrowser,
    hueTransportPreference: normalizeHueTransportPreference(ui.serverHueTransportPreference),
    unsafeExposeSensitiveLogs: ui.serverUnsafeSensitiveLogs
  };
  if (unsafeAck) payload.unsafeExposeSensitiveLogsAck = unsafeAck;
  const response = await postJson("/system/config", payload);
  if (!response.ok || response.data?.ok !== true) {
    ui.serverUnsafeSensitiveLogs = ui.serverUnsafeSensitiveLogsBaseline === true;
    applySystemSettingsUi();
    return {
      ok: false,
      error: response.data?.error || "server settings save failed"
    };
  }

  ui.serverAutoLaunchBrowser = response.data?.config?.autoLaunchBrowser !== false;
  ui.serverHueTransportPreference = normalizeHueTransportPreference(response.data?.config?.hueTransportPreference);
  ui.serverUnsafeSensitiveLogs = response.data?.config?.unsafeExposeSensitiveLogs === true;
  ui.serverUnsafeSensitiveLogsBaseline = ui.serverUnsafeSensitiveLogs;
  applySystemSettingsUi();
  return { ok: true };
}

function clearUiLocalCache() {
  return wipeUiBrowserMemory({ includeCacheStorage: true });
}

function tryParseJson(text) {
  try {
    return JSON.parse(text);
  } catch {
    return null;
  }
}

function clampFlowIntensity(value) {
  const n = Number(value);
  if (!Number.isFinite(n)) return 1;
  return Math.min(2.5, Math.max(0.35, n));
}

function applyFlowIntensityUi() {
  const value = clampFlowIntensity(ui.flowIntensity);
  ui.flowIntensity = value;
  el.flowIntensity.value = String(Math.round(value * 100));
  const text = `${value.toFixed(2)}x`;
  el.flowIntensityVal.textContent = text;
  el.flowStat.textContent = text;
}

let flowIntensityCommitTimer = null;
async function commitFlowIntensity(options = {}) {
  const silent = options.silent !== false;
  const value = clampFlowIntensity(ui.flowIntensity);
  const r = await postJson(`/rave/flow/intensity?value=${encodeURIComponent(value.toFixed(3))}`, {});
  if (!r.ok || !r.data || !r.data.ok) {
    if (!silent) setBadge(el.health, "bad", "FLOW INTENSITY FAIL");
    return false;
  }

  ui.flowIntensity = clampFlowIntensity(Number(r.data.value ?? value));
  applyFlowIntensityUi();
  if (!silent) setBadge(el.health, "ok", `FLOW X ${ui.flowIntensity.toFixed(2)}x`);
  return true;
}

async function resetFlowIntensity(options = {}) {
  if (flowIntensityCommitTimer) {
    clearTimeout(flowIntensityCommitTimer);
    flowIntensityCommitTimer = null;
  }
  ui.flowIntensity = 1;
  ui.flowIntensityInputUntil = Date.now() + 900;
  applyFlowIntensityUi();
  const ok = await commitFlowIntensity({ silent: options.silent !== false ? true : false });
  if (ok && options.silent === false) {
    setBadge(el.health, "ok", "FLOW RESET TO 1.00x");
  }
  return ok;
}

function normalizeModIdList(value) {
  if (!Array.isArray(value)) return [];
  const seen = new Set();
  const out = [];
  for (const raw of value) {
    const id = String(raw || "").trim();
    if (!id || seen.has(id)) continue;
    seen.add(id);
    out.push(id);
  }
  return out;
}

function normalizeModConfig(config = {}) {
  const source = config && typeof config === "object" ? config : {};
  return {
    enabled: normalizeModIdList(source.enabled),
    order: normalizeModIdList(source.order),
    disabled: normalizeModIdList(source.disabled)
  };
}

function cloneModConfig(config = {}) {
  const normalized = normalizeModConfig(config);
  return {
    enabled: [...normalized.enabled],
    order: [...normalized.order],
    disabled: [...normalized.disabled]
  };
}

function resolveQueuedModEnabled(modId, runtimeEnabled, draftConfig) {
  const id = String(modId || "").trim();
  if (!id) return Boolean(runtimeEnabled);
  const draft = normalizeModConfig(draftConfig);
  if (draft.disabled.includes(id)) return false;
  if (draft.enabled.includes(id)) return true;
  return Boolean(runtimeEnabled);
}

function getEffectiveModConfig() {
  return ui.modsDraftDirty
    ? cloneModConfig(ui.modsDraftConfig)
    : cloneModConfig(ui.modsRuntimeConfig);
}

function updateModHotswapUi(mods = []) {
  const effective = getEffectiveModConfig();
  let pendingCount = 0;
  for (const mod of (Array.isArray(mods) ? mods : [])) {
    const runtimeEnabled = Boolean(mod?.enabled);
    const queuedEnabled = resolveQueuedModEnabled(mod?.id, runtimeEnabled, effective);
    if (queuedEnabled !== runtimeEnabled) pendingCount += 1;
  }
  ui.modsDraftDirty = pendingCount > 0;

  const runtimeStatus = `${ui.modsActive}/${ui.modsTotal} loaded`;
  const updatedAtText = ui.modsSnapshot?.loadedAt
    ? ` | updated ${new Date(ui.modsSnapshot.loadedAt).toLocaleTimeString()}`
    : "";
  const pendingText = pendingCount > 0 ? ` | ${pendingCount} pending apply` : "";
  el.modsStatus.value = `${runtimeStatus}${updatedAtText}${pendingText}`;

  if (pendingCount > 0) {
    el.modHotswapStatus.value = `${pendingCount} queued change(s). Click APPLY HOTSWAP to load/unload mods live.`;
  } else {
    el.modHotswapStatus.value = "No pending mod changes.";
  }

  el.modApplyBtn.disabled = pendingCount <= 0;
  el.modDiscardBtn.disabled = pendingCount <= 0;
}

function setModsDebugUi(debugSnapshot = null) {
  const snapshot = debugSnapshot && typeof debugSnapshot === "object"
    ? debugSnapshot
    : { enabled: false };
  const enabled = snapshot.enabled === true;
  const sampleMs = Math.max(0, Number(snapshot.telemetryDebugSampleMs) || 0);
  const noHandlerMs = Math.max(0, Number(snapshot.telemetryNoHandlerDebugMs) || 0);

  ui.modsDebugEnabled = enabled;
  ui.modsDebugLoaded = true;

  if (el.modsDebugStatus) {
    if (enabled) {
      el.modsDebugStatus.value = `MOD DEBUG ON | sampled telemetry: ${sampleMs}ms | no-handler: ${noHandlerMs}ms`;
    } else {
      el.modsDebugStatus.value = "MOD DEBUG OFF | concise logs for normal use";
    }
  }
  if (el.modsDebugToggleBtn) {
    el.modsDebugToggleBtn.textContent = enabled ? "MOD DEBUG ON" : "MOD DEBUG OFF";
    el.modsDebugToggleBtn.classList.toggle("warn", enabled);
  }
}

async function setModsDebugEnabled(enabled) {
  if (!el.modsDebugToggleBtn) return false;
  const desired = Boolean(enabled);
  el.modsDebugToggleBtn.disabled = true;
  try {
    const response = await postJson("/mods/debug", { enabled: desired });
    if (!response.ok || !response.data?.ok || !response.data?.debug) {
      return false;
    }
    setModsDebugUi(response.data.debug);
    return true;
  } finally {
    el.modsDebugToggleBtn.disabled = false;
  }
}

async function clearModsDebugBuffer() {
  if (!el.modsDebugClearBtn) return false;
  el.modsDebugClearBtn.disabled = true;
  try {
    const response = await postJson("/mods/debug/clear", {});
    if (!response.ok || !response.data?.ok || !response.data?.debug) {
      return false;
    }
    setModsDebugUi(response.data.debug);
    return true;
  } finally {
    el.modsDebugClearBtn.disabled = false;
  }
}

function getModTooltipText(mod) {
  const primary = String(mod?.tooltip || "").trim();
  const fallback = String(mod?.description || "").trim();
  const combined = (primary || fallback).replace(/\s+/g, " ").trim();
  if (!combined) return "";
  if (combined.length <= 320) return combined;
  return `${combined.slice(0, 317).trimEnd()}...`;
}

function createStatusPill(className, label) {
  const pill = document.createElement("span");
  pill.className = `statusPill ${className}`;
  pill.textContent = String(label || "");
  return pill;
}

function renderMods(modSnapshot) {
  ui.modsSnapshot = modSnapshot && typeof modSnapshot === "object"
    ? modSnapshot
    : null;

  const mods = Array.isArray(modSnapshot?.mods) ? modSnapshot.mods : [];
  ui.modsTotal = Number(modSnapshot?.total || mods.length || 0);
  ui.modsActive = Number(modSnapshot?.loaded || 0);
  ui.modsLoadedAt = Date.now();
  syncFixtureBrandOptions();
  ui.modsRuntimeConfig = normalizeModConfig(modSnapshot?.config || {});
  if (modSnapshot?.debug && typeof modSnapshot.debug === "object") {
    setModsDebugUi(modSnapshot.debug);
  } else if (!ui.modsDebugLoaded) {
    setModsDebugUi({ enabled: false });
  }
  if (!ui.modsDraftDirty) {
    ui.modsDraftConfig = cloneModConfig(ui.modsRuntimeConfig);
  }

  const effectiveConfig = getEffectiveModConfig();

  el.modsRows.innerHTML = "";
  if (!mods.length) {
    const tr = document.createElement("tr");
    const td = document.createElement("td");
    td.colSpan = 7;
    td.textContent = "No mods discovered. Add folders under /mods with mod.json.";
    tr.appendChild(td);
    el.modsRows.appendChild(tr);
    updateModHotswapUi(mods);
    syncModUiCatalogFromModsSnapshot(modSnapshot, { forceReload: false, persist: true });
    return;
  }

  for (const mod of mods) {
    const tr = document.createElement("tr");
    const modId = String(mod.id || "").trim();
    const runtimeEnabled = Boolean(mod.enabled);
    const queuedEnabled = resolveQueuedModEnabled(modId, runtimeEnabled, effectiveConfig);
    const hasPending = queuedEnabled !== runtimeEnabled;
    const tooltipText = getModTooltipText(mod);

    const tdId = document.createElement("td");
    tdId.className = "mono";
    tdId.textContent = String(mod.id || "-");
    if (tooltipText) {
      tdId.title = tooltipText;
      tr.title = tooltipText;
    }

    const tdVersion = document.createElement("td");
    tdVersion.className = "mono";
    tdVersion.textContent = String(mod.version || "-");

    const tdEnabled = document.createElement("td");
    tdEnabled.appendChild(
      createStatusPill(runtimeEnabled ? "ok" : "bad", runtimeEnabled ? "YES" : "NO")
    );

    const tdPending = document.createElement("td");
    if (hasPending) {
      tdPending.appendChild(
        createStatusPill("warn", queuedEnabled ? "ENABLE" : "DISABLE")
      );
    } else {
      tdPending.textContent = "-";
    }

    const tdLoaded = document.createElement("td");
    tdLoaded.appendChild(
      createStatusPill(mod.loaded ? "ok" : "bad", mod.loaded ? "LOADED" : "OFFLINE")
    );

    const tdHooks = document.createElement("td");
    tdHooks.className = "mono";
    tdHooks.textContent = Array.isArray(mod.hooks) && mod.hooks.length
      ? mod.hooks.join(", ")
      : "-";

    const tdError = document.createElement("td");
    tdError.className = "mono";
    tdError.textContent = mod.error ? String(mod.error) : "-";

    tr.appendChild(tdId);
    tr.appendChild(tdVersion);
    tr.appendChild(tdEnabled);
    tr.appendChild(tdPending);
    tr.appendChild(tdLoaded);
    tr.appendChild(tdHooks);
    tr.appendChild(tdError);
    el.modsRows.appendChild(tr);
  }

  const currentEnableDraft = String(el.modEnableId.value || "").trim();
  if (!currentEnableDraft && mods.length) {
    const firstDisabled = mods.find(mod => !resolveQueuedModEnabled(mod.id, Boolean(mod.enabled), effectiveConfig));
    el.modEnableId.value = String(firstDisabled?.id || mods[0]?.id || "");
  }

  updateModHotswapUi(mods);
  syncModUiCatalogFromModsSnapshot(modSnapshot, { forceReload: false, persist: true });
}

async function loadMods() {
  const snapshot = await getJson("/mods");
  if (!snapshot || !snapshot.ok) return false;
  renderMods(snapshot);
  return true;
}

function normalizeImportRelativePath(rawPath) {
  const raw = String(rawPath || "").replace(/\\/g, "/").trim();
  if (!raw) return "";
  const cleaned = raw.replace(/^\/+/, "");
  const parts = cleaned.split("/").filter(Boolean);
  if (!parts.length) return "";
  if (parts.some(part => part === "." || part === "..")) return "";
  return parts.join("/");
}

function setModImportStatus(text) {
  if (!el.modImportStatus) return;
  el.modImportStatus.value = String(text || "").trim() || "Ready.";
}

function setModImportBusy(busy) {
  const isBusy = Boolean(busy);
  if (el.modImportBrowseBtn) el.modImportBrowseBtn.disabled = isBusy;
  if (el.modImportPicker) el.modImportPicker.disabled = isBusy;
  if (el.modImportOverwrite) el.modImportOverwrite.disabled = isBusy;
  if (el.modImportEnable) el.modImportEnable.disabled = isBusy;
}

function filesToImportDescriptors(fileList) {
  const deduped = new Map();
  for (const file of Array.from(fileList || [])) {
    const rel = normalizeImportRelativePath(file?.webkitRelativePath || file?.name || "");
    if (!rel) continue;
    deduped.set(rel, { file, relativePath: rel });
  }
  return Array.from(deduped.values());
}

async function readImportFileAsBase64(file) {
  if (!file || typeof file.arrayBuffer !== "function") return "";
  const buf = await file.arrayBuffer();
  const bytes = new Uint8Array(buf);
  let binary = "";
  const chunkSize = 0x8000;
  for (let i = 0; i < bytes.length; i += chunkSize) {
    const chunk = bytes.subarray(i, i + chunkSize);
    binary += String.fromCharCode(...chunk);
  }
  return btoa(binary);
}

async function buildImportPayloadFromDescriptors(descriptors) {
  const files = [];
  for (const descriptor of (Array.isArray(descriptors) ? descriptors : [])) {
    const rel = normalizeImportRelativePath(descriptor?.relativePath || descriptor?.file?.name || "");
    if (!rel) continue;
    const contentBase64 = await readImportFileAsBase64(descriptor.file);
    if (!contentBase64) continue;
    files.push({
      path: rel,
      contentBase64
    });
  }
  return files;
}

async function readDroppedEntriesRecursively(entry, prefix = "") {
  if (!entry) return [];

  if (entry.isFile) {
    const file = await new Promise(resolve => {
      entry.file(resolve, () => resolve(null));
    });
    if (!file) return [];
    const rel = normalizeImportRelativePath(prefix ? `${prefix}/${file.name}` : file.name);
    return rel ? [{ file, relativePath: rel }] : [];
  }

  if (entry.isDirectory) {
    const reader = entry.createReader();
    const entries = [];

    while (true) {
      const batch = await new Promise(resolve => {
        reader.readEntries(resolve, () => resolve([]));
      });
      if (!Array.isArray(batch) || !batch.length) break;
      entries.push(...batch);
    }

    const nested = [];
    const base = normalizeImportRelativePath(prefix ? `${prefix}/${entry.name}` : entry.name);
    for (const child of entries) {
      const childItems = await readDroppedEntriesRecursively(child, base);
      nested.push(...childItems);
    }
    return nested;
  }

  return [];
}

async function descriptorsFromDropEvent(event) {
  const dataTransfer = event?.dataTransfer;
  if (!dataTransfer) return [];

  const items = Array.from(dataTransfer.items || []);
  const collected = [];
  for (const item of items) {
    const entry = item?.webkitGetAsEntry?.();
    if (!entry) continue;
    const nested = await readDroppedEntriesRecursively(entry, "");
    collected.push(...nested);
  }

  if (collected.length) {
    const deduped = new Map();
    for (const item of collected) {
      const rel = normalizeImportRelativePath(item.relativePath || item.file?.name || "");
      if (!rel) continue;
      deduped.set(rel, { file: item.file, relativePath: rel });
    }
    return Array.from(deduped.values());
  }

  return filesToImportDescriptors(dataTransfer.files || []);
}

async function importModFromDescriptors(descriptors, sourceLabel = "drop") {
  const records = Array.isArray(descriptors) ? descriptors : [];
  if (!records.length) {
    setModImportStatus("No files found. Drop a folder that contains mod.json.");
    setBadge(el.health, "warn", "MOD IMPORT: NO FILES");
    return false;
  }

  setModImportBusy(true);
  setModImportStatus(`Preparing ${records.length} file(s) from ${sourceLabel}...`);

  try {
    const files = await buildImportPayloadFromDescriptors(records);
    if (!files.length) {
      setModImportStatus("No readable files found for import.");
      setBadge(el.health, "warn", "MOD IMPORT EMPTY");
      return false;
    }

    setModImportStatus(`Uploading ${files.length} file(s)...`);
    const payload = {
      files,
      overwrite: el.modImportOverwrite?.checked === true,
      enableAfterImport: el.modImportEnable?.checked !== false,
      reload: true
    };

    const response = await postJson("/mods/import", payload);
    if (!response.ok || !response.data?.ok) {
      const errorText = String(response.data?.error || `status ${response.status || 0}`);
      setModImportStatus(`Import failed: ${errorText}`);
      setBadge(el.health, "bad", "MOD IMPORT FAIL");
      return false;
    }

    const snapshot = response.data?.snapshot;
    if (snapshot?.ok) {
      ui.modsDraftDirty = false;
      ui.modsDraftConfig = cloneModConfig(snapshot.config || {});
      renderMods(snapshot);
    } else {
      await loadMods();
    }

    const modId = String(response.data?.modId || "mod").trim();
    setModImportStatus(`Imported ${modId} (${response.data?.importedFiles || files.length} files).`);
    setBadge(el.health, "ok", `MOD IMPORTED ${modId}`);
    return true;
  } catch (err) {
    setModImportStatus(`Import error: ${err?.message || err}`);
    setBadge(el.health, "bad", "MOD IMPORT ERROR");
    return false;
  } finally {
    setModImportBusy(false);
  }
}

function normalizeColorPrefixToken(value) {
  const raw = String(value || "").trim().toLowerCase();
  if (!raw) return "";
  return /^[a-z][a-z0-9_-]{0,31}$/.test(raw) ? raw : "";
}

function normalizeColorPrefixDefaultTarget(value, fallback = "both") {
  const raw = String(value || "").trim().toLowerCase();
  if (raw === "hue" || raw === "wiz" || raw === "both") return raw;
  return String(fallback || "both").trim().toLowerCase() || "both";
}

function normalizeColorCommandText(value, fallback = "") {
  const source = String(value || "").replace(/\s+/g, " ").trim();
  if (!source) return String(fallback || "").replace(/\s+/g, " ").trim();
  return source.slice(0, 96);
}

function normalizeColorRaveOffGroupKey(value) {
  const source = String(value || "").trim().toLowerCase();
  if (!source) return "";
  const [brandRaw, zoneRaw = ""] = source.split(":", 2);
  const brand = brandRaw === "hue" || brandRaw === "wiz" ? brandRaw : "";
  if (!brand) return "";
  const zone = String(zoneRaw || "").trim().toLowerCase();
  if (!zone) return brand;
  if (zone === "*" || zone === "all") return `${brand}:all`;
  if (!/^[a-z0-9_-]{1,48}$/.test(zone)) return "";
  return `${brand}:${zone}`;
}

function normalizeColorRaveOffGroupMap(rawMap = {}) {
  const source = rawMap && typeof rawMap === "object" ? rawMap : {};
  const safe = {};
  const entries = Object.entries(source)
    .map(([groupKey, command]) => [normalizeColorRaveOffGroupKey(groupKey), normalizeColorCommandText(command, "")])
    .filter(([groupKey, command]) => groupKey && command)
    .sort((a, b) => a[0].localeCompare(b[0]));
  for (const [groupKey, command] of entries) {
    safe[groupKey] = command;
  }
  return safe;
}

function normalizeColorRaveOffFixtureMap(rawMap = {}) {
  const source = rawMap && typeof rawMap === "object" ? rawMap : {};
  const safe = {};
  const entries = Object.entries(source)
    .map(([fixtureId, command]) => [String(fixtureId || "").trim(), normalizeColorCommandText(command, "")])
    .filter(([fixtureId, command]) => fixtureId && command)
    .sort((a, b) => a[0].localeCompare(b[0]));
  for (const [fixtureId, command] of entries) {
    safe[fixtureId] = command;
  }
  return safe;
}

function normalizeColorFixturePrefixMap(rawMap = {}) {
  const source = rawMap && typeof rawMap === "object" ? rawMap : {};
  const safe = {};
  const usedPrefixes = new Set();
  const entries = Object.entries(source)
    .map(([fixtureId, prefix]) => [String(fixtureId || "").trim(), normalizeColorPrefixToken(prefix)])
    .filter(([fixtureId, prefix]) => fixtureId && prefix)
    .sort((a, b) => a[0].localeCompare(b[0]));

  for (const [fixtureId, prefix] of entries) {
    if (usedPrefixes.has(prefix)) continue;
    safe[fixtureId] = prefix;
    usedPrefixes.add(prefix);
  }

  return safe;
}

function parseColorFixturePrefixMapText(value) {
  const lines = String(value || "").split(/\r?\n/);
  const map = {};
  const usedPrefixes = new Set();
  const errors = [];

  for (let i = 0; i < lines.length; i += 1) {
    const rawLine = String(lines[i] || "").trim();
    if (!rawLine || rawLine.startsWith("#")) continue;
    const eqIndex = rawLine.indexOf("=");
    if (eqIndex <= 0 || eqIndex >= (rawLine.length - 1)) {
      errors.push(`line ${i + 1}: use fixtureId=prefix`);
      continue;
    }
    const fixtureId = rawLine.slice(0, eqIndex).trim();
    const prefixTokenRaw = rawLine.slice(eqIndex + 1).trim();
    const prefix = normalizeColorPrefixToken(prefixTokenRaw);
    if (!fixtureId) {
      errors.push(`line ${i + 1}: missing fixture id`);
      continue;
    }
    if (!prefix) {
      errors.push(`line ${i + 1}: invalid prefix '${prefixTokenRaw}'`);
      continue;
    }
    if (Object.prototype.hasOwnProperty.call(map, fixtureId)) {
      errors.push(`line ${i + 1}: duplicate fixture id '${fixtureId}'`);
      continue;
    }
    if (usedPrefixes.has(prefix)) {
      errors.push(`line ${i + 1}: duplicate prefix '${prefix}'`);
      continue;
    }
    map[fixtureId] = prefix;
    usedPrefixes.add(prefix);
  }

  return {
    ok: errors.length === 0,
    map,
    errors
  };
}

function formatColorFixturePrefixMapText(rawMap = {}) {
  const safe = normalizeColorFixturePrefixMap(rawMap);
  return Object.entries(safe)
    .sort((a, b) => a[0].localeCompare(b[0]))
    .map(([fixtureId, prefix]) => `${fixtureId}=${prefix}`)
    .join("\n");
}

function parseColorRaveOffGroupMapText(value) {
  const lines = String(value || "").split(/\r?\n/);
  const map = {};
  const errors = [];

  for (let i = 0; i < lines.length; i += 1) {
    const rawLine = String(lines[i] || "").trim();
    if (!rawLine || rawLine.startsWith("#")) continue;
    const eqIndex = rawLine.indexOf("=");
    if (eqIndex <= 0 || eqIndex >= (rawLine.length - 1)) {
      errors.push(`line ${i + 1}: use group=command`);
      continue;
    }
    const groupRaw = rawLine.slice(0, eqIndex).trim();
    const groupKey = normalizeColorRaveOffGroupKey(groupRaw);
    const commandRaw = rawLine.slice(eqIndex + 1).trim();
    const command = normalizeColorCommandText(commandRaw, "");
    if (!groupKey) {
      errors.push(`line ${i + 1}: invalid group key '${groupRaw}'`);
      continue;
    }
    if (!command) {
      errors.push(`line ${i + 1}: missing command`);
      continue;
    }
    if (Object.prototype.hasOwnProperty.call(map, groupKey)) {
      errors.push(`line ${i + 1}: duplicate group key '${groupKey}'`);
      continue;
    }
    map[groupKey] = command;
  }

  return {
    ok: errors.length === 0,
    map,
    errors
  };
}

function formatColorRaveOffGroupMapText(rawMap = {}) {
  const safe = normalizeColorRaveOffGroupMap(rawMap);
  return Object.entries(safe)
    .sort((a, b) => a[0].localeCompare(b[0]))
    .map(([groupKey, command]) => `${groupKey}=${command}`)
    .join("\n");
}

function parseColorRaveOffFixtureMapText(value) {
  const lines = String(value || "").split(/\r?\n/);
  const map = {};
  const errors = [];

  for (let i = 0; i < lines.length; i += 1) {
    const rawLine = String(lines[i] || "").trim();
    if (!rawLine || rawLine.startsWith("#")) continue;
    const eqIndex = rawLine.indexOf("=");
    if (eqIndex <= 0 || eqIndex >= (rawLine.length - 1)) {
      errors.push(`line ${i + 1}: use fixtureId=command`);
      continue;
    }
    const fixtureId = rawLine.slice(0, eqIndex).trim();
    const commandRaw = rawLine.slice(eqIndex + 1).trim();
    const command = normalizeColorCommandText(commandRaw, "");
    if (!fixtureId) {
      errors.push(`line ${i + 1}: missing fixture id`);
      continue;
    }
    if (!command) {
      errors.push(`line ${i + 1}: missing command`);
      continue;
    }
    if (Object.prototype.hasOwnProperty.call(map, fixtureId)) {
      errors.push(`line ${i + 1}: duplicate fixture id '${fixtureId}'`);
      continue;
    }
    map[fixtureId] = command;
  }

  return {
    ok: errors.length === 0,
    map,
    errors
  };
}

function formatColorRaveOffFixtureMapText(rawMap = {}) {
  const safe = normalizeColorRaveOffFixtureMap(rawMap);
  return Object.entries(safe)
    .sort((a, b) => a[0].localeCompare(b[0]))
    .map(([fixtureId, command]) => `${fixtureId}=${command}`)
    .join("\n");
}

function applyColorPrefixSnapshot(snapshot = {}) {
  const config = snapshot?.config && typeof snapshot.config === "object"
    ? snapshot.config
    : snapshot;
  const prefixes = config?.prefixes && typeof config.prefixes === "object"
    ? config.prefixes
    : {};
  const fixturePrefixes = normalizeColorFixturePrefixMap(config?.fixturePrefixes);
  const raveOffRaw = config?.raveOff && typeof config.raveOff === "object"
    ? config.raveOff
    : {};
  const raveOffEnabled = raveOffRaw.enabled !== false;
  const raveOffDefaultText = normalizeColorCommandText(raveOffRaw.defaultText, "random");
  const raveOffGroups = normalizeColorRaveOffGroupMap(raveOffRaw.groups);
  const raveOffFixtures = normalizeColorRaveOffFixtureMap(raveOffRaw.fixtures);
  const capabilities = snapshot?.capabilities && typeof snapshot.capabilities === "object"
    ? snapshot.capabilities
    : {};

  const huePrefix = normalizeColorPrefixToken(prefixes.hue);
  const wizPrefix = normalizeColorPrefixToken(prefixes.wiz);
  const otherPrefix = normalizeColorPrefixToken(prefixes.other);
  const defaultTarget = normalizeColorPrefixDefaultTarget(config?.defaultTarget, "both");
  const otherEnabled = capabilities.other === true;

  ui.colorPrefixes = {
    hue: huePrefix,
    wiz: wizPrefix,
    other: otherPrefix
  };
  ui.colorFixturePrefixes = fixturePrefixes;
  ui.colorRaveOffEnabled = raveOffEnabled;
  ui.colorRaveOffDefaultText = raveOffDefaultText;
  ui.colorRaveOffGroups = raveOffGroups;
  ui.colorRaveOffFixtures = raveOffFixtures;
  ui.colorPrefixDefaultTarget = defaultTarget;
  ui.colorPrefixOtherEnabled = otherEnabled;

  if (el.colorPrefixHue) el.colorPrefixHue.value = huePrefix;
  if (el.colorPrefixWiz) el.colorPrefixWiz.value = wizPrefix;
  if (el.colorPrefixDefaultTarget) el.colorPrefixDefaultTarget.value = defaultTarget;
  if (el.colorPrefixOther) el.colorPrefixOther.value = otherPrefix;
  if (el.colorPrefixFixtureMap) el.colorPrefixFixtureMap.value = formatColorFixturePrefixMapText(fixturePrefixes);
  if (el.colorRaveOffEnabled) el.colorRaveOffEnabled.value = raveOffEnabled ? "1" : "0";
  if (el.colorRaveOffDefault) el.colorRaveOffDefault.value = raveOffDefaultText;
  if (el.colorRaveOffGroupMap) el.colorRaveOffGroupMap.value = formatColorRaveOffGroupMapText(raveOffGroups);
  if (el.colorRaveOffFixtureMap) el.colorRaveOffFixtureMap.value = formatColorRaveOffFixtureMapText(raveOffFixtures);
  if (el.colorPrefixOtherWrap) {
    el.colorPrefixOtherWrap.classList.toggle("prefixDisabled", !otherEnabled);
  }
  if (el.colorPrefixOther) el.colorPrefixOther.disabled = !otherEnabled;
  if (el.colorPrefixSaveBtn) el.colorPrefixSaveBtn.disabled = false;
  if (el.colorPrefixResetBtn) el.colorPrefixResetBtn.disabled = false;

  if (el.colorPrefixStatus) {
    const hueWord = huePrefix ? huePrefix : "off";
    const wizWord = wizPrefix ? wizPrefix : "off";
    const otherWord = otherEnabled
      ? (otherPrefix ? otherPrefix : "off")
      : "locked";
    const defaultWord = defaultTarget.toUpperCase();
    const fixtureCount = Object.keys(fixturePrefixes).length;
    const groupCount = Object.keys(raveOffGroups).length;
    const raveFixtureCount = Object.keys(raveOffFixtures).length;
    const modHint = otherEnabled
      ? ""
      : " Mod-brand prefix unlocks when mod-brand Twitch fixtures are detected.";
    el.colorPrefixStatus.textContent =
      `Unprefixed /color -> ${defaultWord}. Prefixes: HUE=${hueWord}, WIZ=${wizWord}, MOD=${otherWord}. ` +
      `Per-fixture prefix rules: ${fixtureCount}. RAVE OFF profile: ${raveOffEnabled ? "ON" : "OFF"} ` +
      `(group rules ${groupCount}, fixture rules ${raveFixtureCount}).${modHint}`;
  }
}

async function loadColorPrefixConfig() {
  const snapshot = await getJson("/color/prefixes");
  if (!snapshot || !snapshot.ok) return false;
  applyColorPrefixSnapshot(snapshot);
  ui.colorPrefixConfigLoaded = true;
  return true;
}

async function saveColorPrefixConfigFromUi(options = {}) {
  const reset = options.reset === true;

  let huePrefix = normalizeColorPrefixToken(el.colorPrefixHue?.value || "");
  let wizPrefix = normalizeColorPrefixToken(el.colorPrefixWiz?.value || "");
  let defaultTarget = normalizeColorPrefixDefaultTarget(el.colorPrefixDefaultTarget?.value || "both", "both");
  let otherPrefix = normalizeColorPrefixToken(el.colorPrefixOther?.value || "");
  let fixturePrefixMap = parseColorFixturePrefixMapText(el.colorPrefixFixtureMap?.value || "");
  let raveOffEnabled = String(el.colorRaveOffEnabled?.value || "1") !== "0";
  let raveOffDefaultText = normalizeColorCommandText(el.colorRaveOffDefault?.value || "", "random");
  let raveOffGroupMap = parseColorRaveOffGroupMapText(el.colorRaveOffGroupMap?.value || "");
  let raveOffFixtureMap = parseColorRaveOffFixtureMapText(el.colorRaveOffFixtureMap?.value || "");

  if (reset) {
    huePrefix = "hue";
    wizPrefix = "wiz";
    defaultTarget = "hue";
    otherPrefix = "";
    fixturePrefixMap = { ok: true, map: {}, errors: [] };
    raveOffEnabled = true;
    raveOffDefaultText = "random";
    raveOffGroupMap = { ok: true, map: {}, errors: [] };
    raveOffFixtureMap = { ok: true, map: {}, errors: [] };
  }

  const rawHue = String(el.colorPrefixHue?.value || "").trim();
  const rawWiz = String(el.colorPrefixWiz?.value || "").trim();
  const rawOther = String(el.colorPrefixOther?.value || "").trim();
  if (!reset && rawHue && !huePrefix) {
    setBadge(el.health, "bad", "INVALID HUE PREFIX (USE a-z 0-9 _ -)");
    return false;
  }
  if (!reset && rawWiz && !wizPrefix) {
    setBadge(el.health, "bad", "INVALID WIZ PREFIX (USE a-z 0-9 _ -)");
    return false;
  }
  if (!reset && rawOther && !otherPrefix) {
    setBadge(el.health, "bad", "INVALID MOD PREFIX (USE a-z 0-9 _ -)");
    return false;
  }
  if (!reset && !fixturePrefixMap.ok) {
    const firstError = fixturePrefixMap.errors[0] || "invalid fixture prefix map";
    setBadge(el.health, "bad", `INVALID FIXTURE PREFIX MAP (${firstError})`);
    return false;
  }
  if (!reset && !raveOffGroupMap.ok) {
    const firstError = raveOffGroupMap.errors[0] || "invalid rave-off group map";
    setBadge(el.health, "bad", `INVALID RAVE-OFF GROUP MAP (${firstError})`);
    return false;
  }
  if (!reset && !raveOffFixtureMap.ok) {
    const firstError = raveOffFixtureMap.errors[0] || "invalid rave-off fixture map";
    setBadge(el.health, "bad", `INVALID RAVE-OFF FIXTURE MAP (${firstError})`);
    return false;
  }

  const payload = {
    defaultTarget,
    prefixes: {
      hue: huePrefix,
      wiz: wizPrefix,
      other: otherPrefix
    },
    fixturePrefixes: reset ? {} : fixturePrefixMap.map,
    raveOff: {
      enabled: raveOffEnabled,
      defaultText: raveOffDefaultText,
      groups: reset ? {} : raveOffGroupMap.map,
      fixtures: reset ? {} : raveOffFixtureMap.map
    }
  };

  if (!ui.colorPrefixOtherEnabled) {
    payload.prefixes.other = "";
  }

  const r = await postJson("/color/prefixes", payload);
  if (!r.ok || !r.data?.ok) {
    setBadge(el.health, "bad", "PREFIX CONFIG SAVE FAIL");
    return false;
  }

  applyColorPrefixSnapshot(r.data);
  setBadge(el.health, "ok", reset ? "PREFIXES RESET TO DEFAULTS" : "PREFIX CONFIG SAVED");
  return true;
}

async function runModAction() {
  const modId = String(el.modActionModId.value || "").trim();
  if (!modId) {
    setBadge(el.health, "warn", "MOD ID REQUIRED");
    return;
  }

  const action = String(el.modActionName.value || "").trim();
  const method = String(el.modActionMethod.value || "GET").toUpperCase() === "POST" ? "POST" : "GET";
  const path = action
    ? `/mods/${encodeURIComponent(modId)}/${encodeURIComponent(action)}`
    : `/mods/${encodeURIComponent(modId)}`;

  try {
    const res = await fetch(withBase(path), { method });
    const text = await res.text();
    const json = tryParseJson(text);
    const pretty = json ? JSON.stringify(json, null, 2) : (text || `(status ${res.status})`);
    el.modActionOutput.value = pretty;

    if (!res.ok) {
      setBadge(el.health, "warn", `MOD ACTION ${res.status}`);
      return;
    }

    setBadge(el.health, "ok", "MOD ACTION OK");
  } catch (err) {
    el.modActionOutput.value = String(err?.message || err || "request failed");
    setBadge(el.health, "bad", "MOD ACTION FAIL");
  }
}

async function queueModStateFromUi(shouldEnable = true) {
  let modId = String(el.modEnableId.value || "").trim();
  if (!modId) {
    modId = normalizeModUiId(ui.modUiSelectedId);
    if (modId && el.modEnableId) {
      el.modEnableId.value = modId;
    }
  }
  if (!modId) {
    setBadge(el.health, "warn", "MOD ID REQUIRED");
    return;
  }

  if (!ui.modsSnapshot?.ok || !Array.isArray(ui.modsSnapshot.mods)) {
    const loaded = await loadMods();
    if (!loaded) {
      setBadge(el.health, "bad", "MOD SNAPSHOT FAIL");
      return;
    }
  }

  const snapshot = ui.modsSnapshot;
  if (!snapshot?.ok || !Array.isArray(snapshot.mods)) {
    setBadge(el.health, "bad", "MOD SNAPSHOT FAIL");
    return;
  }

  let exists = snapshot.mods.some(mod => String(mod?.id || "") === modId);
  if (!exists) {
    const selectedId = normalizeModUiId(ui.modUiSelectedId);
    if (selectedId && selectedId !== modId) {
      const selectedExists = snapshot.mods.some(mod => String(mod?.id || "") === selectedId);
      if (selectedExists) {
        modId = selectedId;
        if (el.modEnableId) el.modEnableId.value = modId;
        exists = true;
      }
    }
  }
  if (!exists) {
    setBadge(el.health, "warn", "MOD ID NOT FOUND");
    return;
  }

  const nextDraft = cloneModConfig(ui.modsDraftDirty ? ui.modsDraftConfig : ui.modsRuntimeConfig);
  const enabledSet = new Set(nextDraft.enabled);
  const disabledSet = new Set(nextDraft.disabled);
  const order = Array.isArray(nextDraft.order) ? [...nextDraft.order] : [];

  if (shouldEnable) {
    enabledSet.add(modId);
    disabledSet.delete(modId);
    if (!order.includes(modId)) order.push(modId);
  } else {
    enabledSet.delete(modId);
    disabledSet.add(modId);
  }

  nextDraft.enabled = Array.from(enabledSet);
  nextDraft.disabled = Array.from(disabledSet);
  nextDraft.order = normalizeModIdList(order);

  const hasChange = Array.isArray(snapshot.mods) && snapshot.mods.some(mod => {
    const runtimeEnabled = Boolean(mod?.enabled);
    const queuedEnabled = resolveQueuedModEnabled(mod?.id, runtimeEnabled, nextDraft);
    return queuedEnabled !== runtimeEnabled;
  });
  ui.modsDraftConfig = nextDraft;
  ui.modsDraftDirty = hasChange;
  renderMods(snapshot);

  if (!hasChange) {
    setBadge(el.health, "warn", "NO MOD HOTSWAP CHANGE");
    return;
  }

  const actionWord = shouldEnable ? "ENABLE" : "DISABLE";
  setBadge(el.health, "warn", `QUEUED ${actionWord} ${modId} (APPLY HOTSWAP)`);
}

async function enableModFromUi() {
  await queueModStateFromUi(true);
}

async function disableModFromUi() {
  await queueModStateFromUi(false);
}

async function applyModHotswapFromUi() {
  if (!ui.modsDraftDirty) {
    setBadge(el.health, "warn", "NO HOTSWAP CHANGES");
    return;
  }

  const draft = cloneModConfig(ui.modsDraftConfig);
  const update = await postJson("/mods/config", {
    enabled: draft.enabled,
    order: draft.order,
    disabled: draft.disabled,
    reload: true
  });

  if (!update.ok || !update.data?.ok) {
    setBadge(el.health, "bad", "HOTSWAP APPLY FAIL");
    return;
  }

  ui.modsDraftDirty = false;
  ui.modsDraftConfig = cloneModConfig(update.data?.config || draft);

  const nextSnapshot = update.data.snapshot;
  if (nextSnapshot?.ok) {
    renderMods(nextSnapshot);
  } else {
    await loadMods();
  }
  setBadge(el.health, "ok", "HOTSWAP APPLIED");
}

function discardModDraftFromUi() {
  if (!ui.modsDraftDirty) {
    setBadge(el.health, "warn", "NO HOTSWAP CHANGES");
    return;
  }
  ui.modsDraftDirty = false;
  ui.modsDraftConfig = cloneModConfig(ui.modsRuntimeConfig);
  if (ui.modsSnapshot?.ok) {
    renderMods(ui.modsSnapshot);
  }
  setBadge(el.health, "ok", "HOTSWAP CHANGES DISCARDED");
}

function getCanonicalZoneForBrand(brand, fallback = "custom") {
  const key = String(brand || "").trim().toLowerCase();
  if (key === "hue") return "hue";
  if (key === "wiz") return "wiz";
  return String(fallback || "custom").trim().toLowerCase() || "custom";
}

function normalizeZoneKey(value, fallback = "custom") {
  const zone = String(value || "").trim().toLowerCase();
  return zone || fallback;
}

function isBuiltinFixtureBrand(value) {
  const brand = String(value || "").trim().toLowerCase();
  return brand === "hue" || brand === "wiz";
}

function normalizeFixtureModBrandToken(value) {
  const brand = String(value || "").trim().toLowerCase();
  if (!brand || isBuiltinFixtureBrand(brand)) return "";
  return MOD_BRAND_RE.test(brand) ? brand : "";
}

function normalizeFixtureModBrandList(value) {
  if (!Array.isArray(value)) return [];
  const set = new Set();
  value.forEach(item => {
    const brand = normalizeFixtureModBrandToken(item);
    if (brand) set.add(brand);
  });
  return [...set].sort();
}

function collectFixtureModBrandsFromSnapshot(summary = {}, fixtures = []) {
  const set = new Set(normalizeFixtureModBrandList(summary?.modBrands));
  if (Array.isArray(fixtures)) {
    fixtures.forEach(fixture => {
      const brand = normalizeFixtureModBrandToken(fixture?.brand);
      if (brand) set.add(brand);
    });
  }
  return [...set].sort();
}

function formatFixtureBrandForUi(value) {
  const brand = String(value || "").trim().toLowerCase();
  if (!brand) return "";
  if (brand === "hue") return "HUE";
  if (brand === "wiz") return "WIZ";
  return brand.toUpperCase();
}

function collectActiveSceneSyncBrands(fixtures = []) {
  const set = new Set();
  const list = Array.isArray(fixtures) ? fixtures : [];
  list.forEach(fixture => {
    const brand = String(fixture?.brand || "").trim().toLowerCase();
    if (!isValidFixtureBrand(brand)) return;
    const enabled = fixture?.enabled !== false;
    const mode = String(fixture?.controlMode || "").trim().toLowerCase();
    const engineEnabled = fixture?.engineEnabled === false
      ? false
      : (fixture?.engineEnabled === true || mode === "engine" || mode === "");
    if (!enabled || !engineEnabled) return;
    set.add(brand);
  });
  const builtinOrder = { hue: 0, wiz: 1 };
  return [...set].sort((a, b) => {
    const rankA = Object.prototype.hasOwnProperty.call(builtinOrder, a) ? builtinOrder[a] : 99;
    const rankB = Object.prototype.hasOwnProperty.call(builtinOrder, b) ? builtinOrder[b] : 99;
    if (rankA !== rankB) return rankA - rankB;
    return a.localeCompare(b);
  });
}

function getSceneSyncLabelContext() {
  return {
    syncButton: "SYNC HUE + WIZ",
    desyncButton: "WIZ STANDALONE",
    statusSynced: "SCENE LINK: HUE + WIZ SYNCED",
    statusDesynced: "SCENE LINK: WIZ STANDALONE",
    badgeSynced: "SCENE LINKED",
    badgeDesynced: "WIZ STANDALONE"
  };
}

function resolveFixtureFormBrand(fallback = "") {
  const fallbackBrand = isBuiltinFixtureBrand(fallback)
    ? String(fallback).trim().toLowerCase()
    : normalizeFixtureModBrandToken(fallback);
  const selectedBrand = String(el.fxBrand?.value || "").trim().toLowerCase();
  if (selectedBrand === FIXTURE_MOD_CUSTOM_BRAND_VALUE) {
    const customBrand = normalizeFixtureModBrandToken(el.fxModBrandId?.value || "");
    return customBrand || fallbackBrand;
  }
  if (isBuiltinFixtureBrand(selectedBrand)) return selectedBrand;
  return normalizeFixtureModBrandToken(selectedBrand) || fallbackBrand;
}

function syncFixtureBrandOptions(options = {}) {
  if (!el.fxBrand || !el.fxModBrandGroup) return;

  const requestedSelect = String(options.selectValue || "").trim().toLowerCase();
  const requestedCustomBrand = normalizeFixtureModBrandToken(options.customBrand || "");
  const previousSelect = String(el.fxBrand.value || "").trim().toLowerCase();
  const previousCustomBrand = normalizeFixtureModBrandToken(el.fxModBrandId?.value || "");
  const modsPresent = Number(ui.modsTotal || 0) > 0;

  const knownSet = new Set(normalizeFixtureModBrandList(ui.fixtureModBrands));
  const selectedKnownBrand = normalizeFixtureModBrandToken(requestedSelect || previousSelect);
  if (selectedKnownBrand) knownSet.add(selectedKnownBrand);
  if (requestedCustomBrand) knownSet.add(requestedCustomBrand);
  if (previousSelect === FIXTURE_MOD_CUSTOM_BRAND_VALUE && previousCustomBrand) {
    knownSet.add(previousCustomBrand);
  }

  const knownBrands = [...knownSet].sort();
  ui.fixtureModBrands = knownBrands;

  const allowCustomBrand = modsPresent;
  const locked = !allowCustomBrand && knownBrands.length === 0;
  el.fxModBrandGroup.innerHTML = "";
  el.fxModBrandGroup.label = locked ? "Mod Brands (locked)" : "Mod Brands";

  if (knownBrands.length > 0) {
    knownBrands.forEach(brand => {
      const option = document.createElement("option");
      option.value = brand;
      option.textContent = brand.toUpperCase();
      el.fxModBrandGroup.appendChild(option);
    });
  }

  if (allowCustomBrand) {
    const customOption = document.createElement("option");
    customOption.value = FIXTURE_MOD_CUSTOM_BRAND_VALUE;
    customOption.textContent = "CUSTOM MOD BRAND...";
    el.fxModBrandGroup.appendChild(customOption);
  }

  if (!knownBrands.length && !allowCustomBrand) {
    const placeholder = document.createElement("option");
    placeholder.value = "";
    placeholder.textContent = "No mod brands detected";
    placeholder.disabled = true;
    el.fxModBrandGroup.appendChild(placeholder);
  }

  el.fxModBrandGroup.disabled = locked;

  if (el.fxModBrandStatus) {
    if (knownBrands.length > 0 && allowCustomBrand) {
      el.fxModBrandStatus.textContent = `Detected mod brands: ${knownBrands.join(", ")}.`;
      el.fxModBrandStatus.classList.remove("prefixDisabled");
    } else if (knownBrands.length > 0) {
      el.fxModBrandStatus.textContent = `Configured mod brands: ${knownBrands.join(", ")}.`;
      el.fxModBrandStatus.classList.remove("prefixDisabled");
    } else if (allowCustomBrand) {
      el.fxModBrandStatus.textContent = "Mods detected. Select CUSTOM MOD BRAND... to add fixture brand ids.";
      el.fxModBrandStatus.classList.remove("prefixDisabled");
    } else {
      el.fxModBrandStatus.textContent = "Mod fixture brands unlock when mods are discovered.";
      el.fxModBrandStatus.classList.add("prefixDisabled");
    }
  }

  let nextSelect = requestedSelect || previousSelect || "hue";
  if (!isBuiltinFixtureBrand(nextSelect) && nextSelect !== FIXTURE_MOD_CUSTOM_BRAND_VALUE) {
    nextSelect = normalizeFixtureModBrandToken(nextSelect);
  }

  if (nextSelect === FIXTURE_MOD_CUSTOM_BRAND_VALUE && !allowCustomBrand) {
    nextSelect = knownBrands[0] || "hue";
  } else if (!isBuiltinFixtureBrand(nextSelect) && nextSelect !== FIXTURE_MOD_CUSTOM_BRAND_VALUE) {
    if (!nextSelect || !knownBrands.includes(nextSelect)) {
      nextSelect = knownBrands[0] || "hue";
    }
  }

  el.fxBrand.value = nextSelect;
  if (!el.fxBrand.value) {
    el.fxBrand.value = knownBrands[0] || "hue";
  }

  if (el.fxModBrandId) {
    if (el.fxBrand.value === FIXTURE_MOD_CUSTOM_BRAND_VALUE && allowCustomBrand) {
      el.fxModBrandId.value = requestedCustomBrand || previousCustomBrand || "";
    } else {
      el.fxModBrandId.value = "";
    }
  }

  if (options.applyVisibility !== false) applyFixtureBrandVisibility();
}

function isValidFixtureBrand(brandValue) {
  const brand = String(brandValue || "").trim().toLowerCase();
  if (!brand) return false;
  if (brand === "hue" || brand === "wiz") return true;
  return MOD_BRAND_RE.test(brand);
}

function parseLooseBoolean(value, fallback = false) {
  if (typeof value === "boolean") return value;
  if (value === 1 || value === "1") return true;
  if (value === 0 || value === "0") return false;
  if (typeof value === "string") {
    const raw = value.trim().toLowerCase();
    if (raw === "true" || raw === "on" || raw === "yes") return true;
    if (raw === "false" || raw === "off" || raw === "no") return false;
  }
  return fallback;
}

function isLikelyPlaceholderConfigValue(value) {
  const raw = String(value || "").trim().toLowerCase();
  if (!raw) return true;
  if (raw.includes("replace_with")) return true;
  if (raw.includes("192.168.x.x")) return true;
  if (raw.includes("x.x.x.x")) return true;
  if (raw.includes("example")) return true;
  return false;
}

function isFixtureConfiguredForOutput(fixture = {}) {
  const brand = String(fixture?.brand || "").trim().toLowerCase();
  if (brand === "hue") {
    const bridgeIp = String(fixture?.bridgeIp || "").trim();
    const username = String(fixture?.username || "").trim();
    const lightId = Number(fixture?.lightId || 0);
    return (
      !isLikelyPlaceholderConfigValue(bridgeIp) &&
      !isLikelyPlaceholderConfigValue(username) &&
      Number.isFinite(lightId) &&
      lightId > 0
    );
  }
  if (brand === "wiz") {
    const ip = String(fixture?.ip || "").trim();
    return !isLikelyPlaceholderConfigValue(ip);
  }
  return true;
}

function isFixtureEngineEnabled(fixture = {}) {
  return parseLooseBoolean(fixture?.engineEnabled, false);
}

function isFixtureTwitchEnabled(fixture = {}) {
  if (Object.prototype.hasOwnProperty.call(fixture, "twitchEnabled")) {
    return parseLooseBoolean(fixture.twitchEnabled, true);
  }
  return true;
}

function isFixtureCustomEnabled(fixture = {}) {
  return parseLooseBoolean(fixture?.customEnabled, false);
}

function readFixtureModeFields() {
  const brand = resolveFixtureFormBrand("");
  const zone = normalizeZoneKey(el.fxZone.value, getCanonicalZoneForBrand(brand, "custom"));
  const engineEnabled = el.fxEngineEnabled.value === "true";
  const twitchEnabled = el.fxTwitchEnabled.value === "true";
  let customEnabled = el.fxCustomEnabled.value === "true";

  if (engineEnabled && customEnabled) {
    customEnabled = false;
    el.fxCustomEnabled.value = "false";
  }

  if (!engineEnabled && !twitchEnabled && !customEnabled) {
    customEnabled = true;
    el.fxCustomEnabled.value = "true";
  }

  const engineBinding = engineEnabled ? brand : "standalone";
  const controlMode = engineEnabled ? "engine" : "standalone";
  el.fxEngineBinding.value = engineBinding;
  el.fxControlMode.value = controlMode;

  return {
    zone,
    engineEnabled,
    twitchEnabled,
    customEnabled,
    engineBinding,
    controlMode
  };
}

function validateFixtureCoupling(brand, modeState) {
  const b = String(brand || "").trim().toLowerCase();
  const zone = normalizeZoneKey(modeState?.zone || "", getCanonicalZoneForBrand(b, "custom"));
  void zone;
  const engineEnabled = modeState?.engineEnabled === true;
  const twitchEnabled = modeState?.twitchEnabled === true;
  const customEnabled = modeState?.customEnabled === true;
  const binding = String(modeState?.engineBinding || "").trim().toLowerCase();

  if (!isValidFixtureBrand(b)) {
    return { ok: false, message: "Fixture brand must be hue, wiz, or a valid lowercase mod brand id." };
  }

  if (!engineEnabled && !twitchEnabled && !customEnabled) {
    return { ok: false, message: "Enable at least one mode: engine, twitch, or custom." };
  }

  if (engineEnabled && customEnabled) {
    return { ok: false, message: "Custom mode cannot be enabled while Engine mode is enabled." };
  }

  if (engineEnabled && binding !== b) {
    return {
      ok: false,
      message: `${b.toUpperCase()} fixtures can only bind to ${b.toUpperCase()} engine path.`
    };
  }

  const active = [];
  if (engineEnabled) active.push("engine");
  if (twitchEnabled) active.push("twitch");
  if (customEnabled) active.push("custom");
  return { ok: true, message: `Modes: ${active.join(" + ")}` };
}

function updateFixtureCompatibilityHint() {
  const modeState = readFixtureModeFields();
  const check = validateFixtureCoupling(resolveFixtureFormBrand(""), modeState);
  el.fxCompatHint.textContent = check.message;
  el.fxCompatHint.style.color = check.ok ? "#90e8b3" : "#ff8b8b";
  return check;
}

function syncFixtureCouplingDefaults(reason = "") {
  void reason;
  readFixtureModeFields();
  updateFixtureCompatibilityHint();
}

async function loadFixturesSnapshot(attempts = 1) {
  const maxAttempts = Math.max(1, Math.min(5, Number(attempts) || 1));
  for (let i = 0; i < maxAttempts; i += 1) {
    const snapshot = await getJson("/fixtures");
    if (snapshot && Array.isArray(snapshot.fixtures)) {
      return snapshot;
    }
    if (i < (maxAttempts - 1)) {
      await new Promise(resolve => setTimeout(resolve, 140));
    }
  }

  const configSnapshot = await getJson("/fixtures/config");
  if (configSnapshot?.ok && Array.isArray(configSnapshot?.config?.fixtures)) {
    return {
      fixtures: configSnapshot.config.fixtures,
      routes: configSnapshot.config.intentRoutes || {},
      summary: {},
      standalone: Array.isArray(ui.standaloneFixtures) ? ui.standaloneFixtures.slice() : [],
      connectivity: [],
      connectivitySummary: null
    };
  }
  return null;
}

async function refreshFixturesFromServer(options = {}) {
  const attempts = Math.max(1, Math.min(5, Number(options.attempts) || 1));
  const clearOnFail = options.clearOnFail === true;
  const snapshot = await loadFixturesSnapshot(attempts);
  if (snapshot) {
    updateFixtures(snapshot);
    return { ok: true, snapshot };
  }

  if (clearOnFail) {
    updateFixtures({
      fixtures: [],
      routes: {},
      summary: {},
      standalone: [],
      connectivity: [],
      connectivitySummary: null
    });
  }

  return { ok: false, snapshot: null };
}

async function getKnownFixtureCatalog() {
  const localCatalog = Array.isArray(ui.fixturesCatalog) ? ui.fixturesCatalog.slice() : [];
  if (localCatalog.length) return localCatalog;

  const snapshot = await loadFixturesSnapshot(2);
  if (snapshot && Array.isArray(snapshot.fixtures)) {
    return snapshot.fixtures.slice();
  }
  return localCatalog;
}

async function saveFixtureFromForm(options = {}) {

  const resetAfter = options.resetAfter !== false;
  const areaCheck = ensureHueEntertainmentAreaSelection({
    forcePrompt: false,
    promptIfMissing: true,
    forceWhenBridgeConfigured: true
  });
  if (!areaCheck.ok) {
    return {
      ok: false,
      error: areaCheck.message || "Hue Entertainment area is required.",
      savedFixture: null,
      routeSync: null
    };
  }

  const fixture = collectFixtureForm();
  const replaceId = String(fixture?.replaceId || "").trim();
  fixture.zone = normalizeZoneKey(fixture.zone, getCanonicalZoneForBrand(fixture.brand, "custom"));
  const coupling = validateFixtureCoupling(fixture.brand, fixture);
  if (!coupling.ok) {
    return {
      ok: false,
      error: coupling.message,
      savedFixture: null,
      routeSync: null
    };
  }

  const r = await postJson("/fixtures/fixture", fixture);
  if (!r.ok) {
    return {
      ok: false,
      error: r.data?.error || "fixture save failed",
      savedFixture: null,
      routeSync: null
    };
  }

  const savedFixture = r.data?.fixture || fixture;
  const catalogSeed = await getKnownFixtureCatalog();
  const localCatalog = upsertFixtureCatalogEntry(savedFixture, { replaceId, catalogSeed });
  applyFixtureCatalogToUi(localCatalog);
  let refreshOk = localCatalog.length > 0;
  if (savedFixture?.id && el.fxOriginalId && !resetAfter) {
    el.fxOriginalId.value = String(savedFixture.id).trim();
  }

  let fixtureSnapshot = await loadFixturesSnapshot(3);
  if (!fixtureSnapshot) {
    await api("/fixtures/reload");
    fixtureSnapshot = await loadFixturesSnapshot(2);
  }
  if (fixtureSnapshot) {
    updateFixtures(fixtureSnapshot);
    refreshOk = true;
  }

  if (!refreshOk && localCatalog.length > 0) {
    refreshOk = true;
  }

  if (resetAfter) resetFixtureForm();

  return {
    ok: true,
    savedFixture,
    refreshOk,
    routeSync: { ok: true, changed: false }
  };
}

async function discoverHueBridgeAndFill(preferredIp = "") {
  const discovered = await getJson("/hue/discover");
  const bridges = Array.isArray(discovered?.bridges) ? discovered.bridges : [];
  if (!bridges.length) {
    return { ok: false, error: discovered?.error || "No Hue bridge found on local network" };
  }

  const prefer = String(preferredIp || el.fxBridgeIp.value || "").trim();
  const selected =
    bridges.find(b => String(b?.ip || "").trim() === prefer) ||
    bridges[0];

  const ip = String(selected?.ip || "").trim();
  const id = String(selected?.id || "").trim().toUpperCase();
  if (ip) el.fxBridgeIp.value = ip;
  if (id) el.fxBridgeId.value = id;

  return {
    ok: true,
    bridge: {
      ip,
      id
    },
    total: bridges.length
  };
}

function ensureHueEntertainmentAreaSelection(options = {}) {
  const forcePrompt = options.forcePrompt === true;
  const promptIfMissing = options.promptIfMissing !== false;
  const forceWhenBridgeConfigured = options.forceWhenBridgeConfigured !== false;
  const brand = resolveFixtureFormBrand("");
  if (brand !== "hue") return { ok: true, areaId: "" };

  const bridgeIp = String(el.fxBridgeIp?.value || "").trim();
  const username = String(el.fxUsername?.value || "").trim();
  const bridgeId = String(el.fxBridgeId?.value || "").trim();
  const clientKey = String(el.fxClientKey?.value || "").trim();
  let areaId = String(el.fxEntertainmentAreaId?.value || "").trim();

  const bridgeConfigured = Boolean((bridgeIp && username) || (bridgeId && clientKey));
  const mustRequireArea = forcePrompt || (forceWhenBridgeConfigured && bridgeConfigured);
  if (!mustRequireArea) return { ok: true, areaId };

  if (forcePrompt || (!areaId && promptIfMissing)) {
    const prompted = window.prompt(
      "Hue Entertainment Area is required for reliable Hue streaming.\n\nEnter the exact Entertainment Area name or id:",
      areaId
    );
    if (prompted === null) {
      return {
        ok: false,
        cancelled: true,
        message: "Hue setup cancelled (entertainment area is required)."
      };
    }
    areaId = String(prompted || "").trim();
  }

  if (!areaId) {
    return {
      ok: false,
      cancelled: false,
      message: "Set ENT AREA before pairing or saving Hue bridge edits."
    };
  }

  el.fxEntertainmentAreaId.value = areaId;
  return { ok: true, areaId };
}

function toFixedSafe(v, digits, fallback = "0") {
  const n = Number(v);
  return Number.isFinite(n) ? n.toFixed(digits) : fallback;
}

function boolFromSelect(value) {
  const raw = String(value || "").toLowerCase().trim();
  return raw === "true" || raw === "1" || raw === "on" || raw === "yes";
}

function clampInt(value, min, max, fallback) {
  const n = Math.round(Number(value));
  if (!Number.isFinite(n)) return fallback;
  return Math.min(max, Math.max(min, n));
}

function clampNumber(value, min, max, fallback) {
  const n = Number(value);
  if (!Number.isFinite(n)) return fallback;
  return Math.min(max, Math.max(min, n));
}

function syncAutomationPercentLabels() {
  const startPercent = clampInt(el.autoStartPercent.value, 1, 100, 80);
  const stopPercent = clampInt(el.autoStopPercent.value, 1, 100, 100);
  el.autoStartPercentVal.textContent = `${startPercent}%`;
  el.autoStopPercentVal.textContent = `${stopPercent}%`;
}

function syncAutomationControlAccessibility() {
  const enabled = boolFromSelect(el.autoRulesEnabled.value);
  [
    el.autoRulesEnabled,
    el.autoRulesTargetZone,
    el.autoRulesTransitionMs,
    el.autoStartEnabled,
    el.autoStartPercent,
    el.autoStartDelayMs,
    el.autoStopEnabled,
    el.autoStopPercent,
    el.autoStopDelayMs,
    el.autoRulesSaveBtn,
    el.autoRulesReloadBtn,
    el.autoRulesTestStartBtn,
    el.autoRulesTestStopBtn
  ].forEach(node => {
    if (!node) return;
    const requiresAutomationOn =
      node === el.autoRulesTargetZone ||
      node === el.autoRulesTransitionMs ||
      node === el.autoStartEnabled ||
      node === el.autoStartPercent ||
      node === el.autoStartDelayMs ||
      node === el.autoStopEnabled ||
      node === el.autoStopPercent ||
      node === el.autoStopDelayMs ||
      node === el.autoRulesTestStartBtn ||
      node === el.autoRulesTestStopBtn;
    node.disabled = requiresAutomationOn ? !enabled : false;
  });
}

function refreshAutomationZoneOptions(fixtures = []) {
  const current = String(el.autoRulesTargetZone.value || "all");
  const hueZones = [...new Set(
    (Array.isArray(fixtures) ? fixtures : [])
      .filter(f => String(f?.brand || "").toLowerCase() === "hue")
      .map(f => String(f?.zone || "").trim())
      .filter(Boolean)
  )].sort((a, b) => a.localeCompare(b));

  const nextOptions = ["all", ...hueZones];
  el.autoRulesTargetZone.innerHTML = "";
  for (const value of nextOptions) {
    const option = document.createElement("option");
    option.value = value;
    option.textContent = value === "all" ? "all hue fixtures" : value;
    el.autoRulesTargetZone.appendChild(option);
  }

  if (!nextOptions.includes(current)) {
    const extra = document.createElement("option");
    extra.value = current;
    extra.textContent = current;
    el.autoRulesTargetZone.appendChild(extra);
  }
  el.autoRulesTargetZone.value = current;
}

function applyFixtureCatalogToUi(fixtures = []) {
  const catalog = Array.isArray(fixtures) ? fixtures.slice() : [];
  ui.fixturesCatalog = catalog;
  try {
    refreshAutomationZoneOptions(catalog);
  } catch (err) {
    console.warn("[FIXTURES][UI] automation zone refresh failed:", err?.message || err);
  }
  try {
    renderRouteFixtureOptions(catalog);
  } catch (err) {
    console.warn("[FIXTURES][UI] route selector render failed:", err?.message || err);
  }
  try {
    renderFixtureRows(catalog);
  } catch (err) {
    console.warn("[FIXTURES][UI] fixture table render failed:", err?.message || err);
  }
}

function upsertFixtureCatalogEntry(fixture, options = {}) {
  if (!fixture || typeof fixture !== "object") {
    return Array.isArray(ui.fixturesCatalog) ? ui.fixturesCatalog.slice() : [];
  }

  const replaceId = String(options?.replaceId || "").trim();
  const nextId = String(fixture?.id || "").trim();
  const seedCatalog = Array.isArray(options?.catalogSeed)
    ? options.catalogSeed
    : ui.fixturesCatalog;
  const catalog = Array.isArray(seedCatalog) ? seedCatalog.slice() : [];

  if (replaceId && replaceId !== nextId) {
    for (let i = catalog.length - 1; i >= 0; i -= 1) {
      if (String(catalog[i]?.id || "").trim() === replaceId) {
        catalog.splice(i, 1);
      }
    }
  }

  if (!nextId) {
    catalog.push(fixture);
    return catalog;
  }

  const idx = catalog.findIndex(item => String(item?.id || "").trim() === nextId);
  if (idx >= 0) {
    catalog[idx] = {
      ...catalog[idx],
      ...fixture
    };
  } else {
    catalog.push(fixture);
  }
  return catalog;
}

function renderAutomationSummary(config = {}, meta = {}) {
  const start = config.start || {};
  const stop = config.stop || {};

  el.autoRulesState.textContent = config.enabled === false ? "DISABLED" : "ENABLED";
  el.autoRulesZone.textContent = String(config.targetZone || "all");
  el.autoRulesTransition.textContent = `${clampInt(config.transitionMs, 0, 10000, 400)}ms`;
  el.autoRulesStart.textContent = start.enabled === false
    ? "OFF"
    : `${clampInt(start.brightnessPercent, 1, 100, 80)}% @ ${clampInt(start.delayMs, 0, 60000, 0)}ms`;
  el.autoRulesStop.textContent = stop.enabled === false
    ? "OFF"
    : `${clampInt(stop.brightnessPercent, 1, 100, 100)}% @ ${clampInt(stop.delayMs, 0, 60000, 0)}ms`;
  el.autoRulesVersion.textContent = String(meta.version ?? 0);
  el.autoRulesLoadedAt.textContent = meta.loadedAt
    ? new Date(meta.loadedAt).toLocaleTimeString()
    : "-";

  const backupPath = String(meta.lastBackupPath || "");
  el.autoRulesBackup.textContent = backupPath
    ? backupPath.split(/[/\\]/).pop()
    : "-";
}

function applyAutomationConfigToInputs(config = {}, meta = {}) {
  const start = config.start || {};
  const stop = config.stop || {};

  el.autoRulesEnabled.value = config.enabled === false ? "false" : "true";
  el.autoRulesTargetZone.value = String(config.targetZone || "all");
  if (!Array.from(el.autoRulesTargetZone.options).some(o => o.value === el.autoRulesTargetZone.value)) {
    const extra = document.createElement("option");
    extra.value = el.autoRulesTargetZone.value;
    extra.textContent = el.autoRulesTargetZone.value;
    el.autoRulesTargetZone.appendChild(extra);
  }

  el.autoRulesTransitionMs.value = String(clampInt(config.transitionMs, 0, 10000, 400));
  el.autoStartEnabled.value = start.enabled === false ? "false" : "true";
  el.autoStartPercent.value = String(clampInt(start.brightnessPercent, 1, 100, 80));
  el.autoStartDelayMs.value = String(clampInt(start.delayMs, 0, 60000, 0));
  el.autoStopEnabled.value = stop.enabled === false ? "false" : "true";
  el.autoStopPercent.value = String(clampInt(stop.brightnessPercent, 1, 100, 100));
  el.autoStopDelayMs.value = String(clampInt(stop.delayMs, 0, 60000, 0));
  syncAutomationPercentLabels();
  syncAutomationControlAccessibility();
  renderAutomationSummary(config, meta);
}

function collectAutomationConfigFromInputs() {
  return {
    enabled: boolFromSelect(el.autoRulesEnabled.value),
    targetZone: String(el.autoRulesTargetZone.value || "all").trim() || "all",
    transitionMs: clampInt(el.autoRulesTransitionMs.value, 0, 10000, 400),
    start: {
      enabled: boolFromSelect(el.autoStartEnabled.value),
      brightnessPercent: clampInt(el.autoStartPercent.value, 1, 100, 80),
      delayMs: clampInt(el.autoStartDelayMs.value, 0, 60000, 0)
    },
    stop: {
      enabled: boolFromSelect(el.autoStopEnabled.value),
      brightnessPercent: clampInt(el.autoStopPercent.value, 1, 100, 100),
      delayMs: clampInt(el.autoStopDelayMs.value, 0, 60000, 0)
    }
  };
}

async function loadAutomationConfig() {
  const r = await getJson("/automation/config");
  if (!r || !r.ok || !r.config) return false;
  applyAutomationConfigToInputs(r.config, r.meta || {});
  ui.automationConfigLoaded = true;
  return true;
}

function renderPaletteFamilyButtons(palettes = []) {
  if (!el.paletteFamilyGrid) return;
  if (!Array.isArray(palettes) || !palettes.length) return;

  el.paletteFamilyGrid.innerHTML = "";
  for (const palette of palettes) {
    if (!palette || !palette.id) continue;
    const btn = document.createElement("button");
    btn.type = "button";
    btn.dataset.paletteFamily = String(palette.id).toLowerCase();
    btn.textContent = String(palette.label || palette.id).toUpperCase();
    el.paletteFamilyGrid.appendChild(btn);
  }
}

async function loadPaletteConfig() {
  const r = await getJson("/rave/palette");
  if (!r || !r.ok) return false;
  applyPaletteRuntimeSnapshotToUi(r);
  return true;
}

function getCollapseStorageKey(panel) {
  const key = String(panel?.dataset?.collapsibleKey || panel?.id || "").trim();
  if (!key) return "";
  return `ravelink_ui_collapsed_${key}`;
}

function setCollapsibleState(panel, collapsed, options = {}) {
  if (!panel) return;
  const nextCollapsed = Boolean(collapsed);
  const body = panel.querySelector(".clusterBody");
  const btn = panel.querySelector("[data-collapse-btn]");
  const storageKey = getCollapseStorageKey(panel);

  panel.classList.toggle("collapsed", nextCollapsed);
  if (body) body.setAttribute("aria-hidden", nextCollapsed ? "true" : "false");
  if (btn) {
    btn.textContent = nextCollapsed ? "EXPAND" : "COLLAPSE";
    btn.setAttribute("aria-expanded", nextCollapsed ? "false" : "true");
    btn.title = nextCollapsed ? "Expand this section." : "Collapse this section.";
  }

  if (options.persist !== false && storageKey) {
    localStorage.setItem(storageKey, nextCollapsed ? "1" : "0");
  }
}

function initCollapsiblePanels() {
  const panels = Array.from(document.querySelectorAll(".cluster.collapsible, .subcluster.collapsible"));
  const compactViewport =
    window.matchMedia("(max-width: 980px), (max-height: 760px)").matches ||
    ui.obsDockMode ||
    ui.obsDockCompact;
  panels.forEach(panel => {
    const btn = panel.querySelector("[data-collapse-btn]");
    if (!btn) return;

    const storageKey = getCollapseStorageKey(panel);
    const defaultCollapsed = panel.dataset.collapsedDefault === "1" ||
      (compactViewport && panel.dataset.collapsedDefaultMobile === "1");
    const stored = storageKey ? localStorage.getItem(storageKey) : null;
    const startCollapsed = stored === "1"
      ? true
      : stored === "0"
        ? false
        : defaultCollapsed;

    setCollapsibleState(panel, startCollapsed, { persist: false });
    btn.onclick = () => {
      setCollapsibleState(panel, !panel.classList.contains("collapsed"));
    };
  });
}

function setOnboardingLock(locked) {
  const nextLocked = Boolean(locked);
  document.body.classList.toggle("onboardLock", nextLocked);
  if (el.onboardGate) {
    el.onboardGate.classList.toggle("hidden", !nextLocked);
  }

  if (nextLocked) {
    showTab("live");
  }
}

function initOnboardingGate() {
  if (ui.obsDockMode) {
    ui.onboardingAcknowledged = true;
    setOnboardingLock(false);
    return;
  }

  const acknowledged = localStorage.getItem(ONBOARD_ACK_KEY) === "1";
  ui.onboardingAcknowledged = acknowledged;
  setOnboardingLock(!acknowledged);

  if (el.onboardAckBtn) {
    el.onboardAckBtn.onclick = () => {
      localStorage.setItem(ONBOARD_ACK_KEY, "1");
      ui.onboardingAcknowledged = true;
      setOnboardingLock(false);
      setBadge(el.health, "ok", "SETUP CONFIRMED");
      maybeAutoStartGuidedOnboarding();
    };
  }
}

function setHueEntGuideLock(locked) {
  const nextLocked = Boolean(locked);
  document.body.classList.toggle("hueEntGuideLock", nextLocked);
  if (el.hueEntGuideGate) {
    el.hueEntGuideGate.classList.toggle("hidden", !nextLocked);
  }

  if (nextLocked) {
    showTab("fixtures");
    el.fxHueBridgeBlock?.scrollIntoView({ behavior: "smooth", block: "center" });
  }
}

function initHueEntGuideGate() {
  ui.hueEntGuideAcknowledged = localStorage.getItem(HUE_ENT_GUIDE_ACK_KEY) === "1";
  setHueEntGuideLock(false);

  if (el.hueEntGuideAckBtn) {
    el.hueEntGuideAckBtn.onclick = () => {
      localStorage.setItem(HUE_ENT_GUIDE_ACK_KEY, "1");
      ui.hueEntGuideAcknowledged = true;
      setHueEntGuideLock(false);
      const resolve = hueEntGuideAckResolver;
      hueEntGuideAckResolver = null;
      hueEntGuideAckPromise = null;
      if (typeof resolve === "function") resolve(true);
    };
  }
}

function ensureHueEntGuideAcknowledged() {
  if (ui.hueEntGuideAcknowledged) {
    return Promise.resolve(true);
  }
  if (hueEntGuideAckPromise) {
    return hueEntGuideAckPromise;
  }
  hueEntGuideAckPromise = new Promise(resolve => {
    hueEntGuideAckResolver = resolve;
    setHueEntGuideLock(true);
  });
  return hueEntGuideAckPromise;
}

function getGuidedOnboardingSteps() {
  return [
    {
      tab: "live",
      selector: ".liveMainCluster",
      title: "Power + Priority Controls",
      text: "Start with RAVE ON/OFF, then tune META AUTO and HZ in the priority block before deeper changes."
    },
    {
      tab: "fixtures",
      selector: "#fxHueBridgeBlock",
      title: "Pair Hue + Entertainment",
      text: "Use Discover -> Pair, then confirm ENT AREA is set. If you are not using Hue, skip this and continue with WiZ/mod-brand fixtures.",
      onBefore: () => {
        if (el.fxBrand?.value !== "hue") {
          el.fxBrand.value = "hue";
          applyFixtureBrandVisibility();
        }
      }
    },
    {
      tab: "audio",
      selector: "[data-collapsible-key=\"audioAdvancedTuning\"]",
      expandSelector: "[data-collapsible-key=\"audioAdvancedTuning\"]",
      title: "Audio Input + App Isolation",
      text: "Set backend/device, choose priority + fallback app targets, refresh running apps, then apply audio config."
    },
    {
      tab: "fixtures",
      selector: "[data-collapsible-key=\"deviceRouting\"]",
      expandSelector: "[data-collapsible-key=\"deviceRouting\"]",
      title: "Per-Fixture Routing",
      text: "Per fixture, toggle ENGINE/TWITCH/CUSTOM and apply routing. ENGINE + TWITCH can run together; CUSTOM is standalone."
    },
    {
      tab: "live",
      selector: "#paletteBrandMenus",
      expandSelector: "[data-collapsible-key=\"livePaletteRouting\"]",
      title: "Palette + Metric Menus",
      text: "Use per-brand/per-fixture target menus to assign palette order/chaos and song-metric behavior."
    },
    {
      tab: "mods",
      selector: "#modCenter",
      expandSelector: "#modCenter",
      title: "Mod Center",
      text: "Import mods, hotswap enable/disable changes, and verify runtime mod actions from one place."
    },
    {
      tab: "system",
      selector: "[data-collapsible-key=\"systemSettings\"]",
      expandSelector: "[data-collapsible-key=\"systemSettings\"]",
      title: "System Settings",
      text: "Set startup tab, safety confirmations, API base, and polling behavior for this browser session."
    },
    {
      tab: "live",
      selector: "#themeCogBtn",
      title: "Settings Cog",
      text: "Use the cog for themes and to replay onboarding later. Skipping this tour does not remove that option."
    }
  ];
}

function readGuidedOnboardingState() {
  const raw = String(localStorage.getItem(GUIDED_ONBOARDING_STATE_KEY) || "").trim().toLowerCase();
  if (raw === "completed" || raw === "skipped") return raw;
  return "";
}

function writeGuidedOnboardingState(nextState) {
  const value = String(nextState || "").trim().toLowerCase();
  if (!value) {
    localStorage.removeItem(GUIDED_ONBOARDING_STATE_KEY);
    ui.guidedOnboardingStatus = "";
    return;
  }
  ui.guidedOnboardingStatus = value;
  localStorage.setItem(GUIDED_ONBOARDING_STATE_KEY, value);
}

function updateOnboardingLauncherText() {
  if (!el.onboardStartBtn) return;
  const replay = ui.guidedOnboardingStatus === "completed" || ui.guidedOnboardingStatus === "skipped";
  el.onboardStartBtn.textContent = replay ? "REPLAY ONBOARDING" : "START ONBOARDING";
}

function clearGuidedTourFocus() {
  if (guidedTourFocusEl && guidedTourFocusEl.classList) {
    guidedTourFocusEl.classList.remove("guidedTourFocus");
  }
  guidedTourFocusEl = null;
}

function setGuidedTourFocus(target) {
  clearGuidedTourFocus();
  if (!target || !target.classList) return;
  guidedTourFocusEl = target;
  guidedTourFocusEl.classList.add("guidedTourFocus");
}

function setGuidedTourLock(locked) {
  const nextLocked = Boolean(locked);
  document.body.classList.toggle("guidedTourLock", nextLocked);
  if (el.guidedTourGate) {
    el.guidedTourGate.classList.toggle("hidden", !nextLocked);
  }
}

function resolveGuidedTourStepTarget(step = {}) {
  const expandSelector = String(step.expandSelector || "").trim();
  if (expandSelector) {
    const panel = document.querySelector(expandSelector);
    if (panel?.classList?.contains("collapsible")) {
      setCollapsibleState(panel, false);
    }
  }
  const selector = String(step.selector || "").trim();
  if (!selector) return null;
  return document.querySelector(selector);
}

function renderGuidedOnboardingStep() {
  const steps = getGuidedOnboardingSteps();
  const maxIndex = Math.max(0, steps.length - 1);
  ui.guidedOnboardingStep = Math.max(0, Math.min(maxIndex, Number(ui.guidedOnboardingStep) || 0));
  const step = steps[ui.guidedOnboardingStep];
  if (!step) return;

  if (step.tab) showTab(step.tab);
  if (typeof step.onBefore === "function") {
    step.onBefore();
  }

  const target = resolveGuidedTourStepTarget(step);
  if (target) {
    target.scrollIntoView({ behavior: "smooth", block: "center" });
    setGuidedTourFocus(target);
  } else {
    clearGuidedTourFocus();
  }

  const currentStep = ui.guidedOnboardingStep + 1;
  const totalSteps = steps.length;
  if (el.guidedTourStep) {
    el.guidedTourStep.textContent = `${currentStep} / ${totalSteps}`;
  }
  if (el.guidedTourTitle) {
    el.guidedTourTitle.textContent = step.title || "Onboarding";
  }
  if (el.guidedTourText) {
    el.guidedTourText.textContent = step.text || "";
  }
  if (el.guidedTourPrevBtn) {
    el.guidedTourPrevBtn.disabled = currentStep <= 1;
  }
  if (el.guidedTourNextBtn) {
    el.guidedTourNextBtn.textContent = currentStep >= totalSteps ? "FINISH" : "NEXT";
  }
}

function finishGuidedOnboarding(reason = "completed") {
  if (!ui.guidedOnboardingActive) return;

  ui.guidedOnboardingActive = false;
  clearGuidedTourFocus();
  setGuidedTourLock(false);

  if (reason === "completed") {
    writeGuidedOnboardingState("completed");
    setBadge(el.health, "ok", "ONBOARDING COMPLETE");
  } else if (reason === "skipped") {
    writeGuidedOnboardingState("skipped");
    setBadge(el.health, "warn", "ONBOARDING SKIPPED: SETTINGS COG -> START ONBOARDING");
  }

  updateOnboardingLauncherText();
}

function startGuidedOnboarding(options = {}) {
  if (ui.guidedOnboardingActive) return;
  const manual = options.manual === true;

  if (guidedTourAutoStartTimer) {
    clearTimeout(guidedTourAutoStartTimer);
    guidedTourAutoStartTimer = null;
  }

  ui.guidedOnboardingActive = true;
  ui.guidedOnboardingStep = 0;
  setGuidedTourLock(true);
  renderGuidedOnboardingStep();
  if (manual) {
    setBadge(el.health, "ok", "ONBOARDING STARTED");
  }
}

function maybeAutoStartGuidedOnboarding() {
  if (ui.obsDockMode) return;
  if (!ui.onboardingAcknowledged) return;
  if (ui.guidedOnboardingActive) return;
  if (ui.guidedOnboardingStatus === "completed" || ui.guidedOnboardingStatus === "skipped") return;
  if (guidedTourAutoStartTimer) return;

  guidedTourAutoStartTimer = setTimeout(() => {
    guidedTourAutoStartTimer = null;
    if (ui.guidedOnboardingActive) return;
    if (!ui.onboardingAcknowledged) return;
    if (ui.guidedOnboardingStatus === "completed" || ui.guidedOnboardingStatus === "skipped") return;
    startGuidedOnboarding({ manual: false });
  }, 260);
}

function initGuidedOnboarding() {
  ui.guidedOnboardingStatus = readGuidedOnboardingState();
  updateOnboardingLauncherText();
  setGuidedTourLock(false);

  if (el.onboardStartBtn) {
    el.onboardStartBtn.onclick = () => {
      startGuidedOnboarding({ manual: true });
      toggleThemePanel(false);
    };
  }

  if (el.onboardResetBtn) {
    el.onboardResetBtn.onclick = () => {
      writeGuidedOnboardingState("");
      updateOnboardingLauncherText();
      setBadge(el.health, "ok", "ONBOARDING RESET: WILL AUTO-START NEXT LOAD");
    };
  }

  if (el.guidedTourPrevBtn) {
    el.guidedTourPrevBtn.onclick = () => {
      if (!ui.guidedOnboardingActive) return;
      ui.guidedOnboardingStep = Math.max(0, ui.guidedOnboardingStep - 1);
      renderGuidedOnboardingStep();
    };
  }

  if (el.guidedTourNextBtn) {
    el.guidedTourNextBtn.onclick = () => {
      if (!ui.guidedOnboardingActive) return;
      const total = getGuidedOnboardingSteps().length;
      if (ui.guidedOnboardingStep >= total - 1) {
        finishGuidedOnboarding("completed");
        return;
      }
      ui.guidedOnboardingStep += 1;
      renderGuidedOnboardingStep();
    };
  }

  if (el.guidedTourSkipBtn) {
    el.guidedTourSkipBtn.onclick = () => {
      finishGuidedOnboarding("skipped");
    };
  }

  maybeAutoStartGuidedOnboarding();
}

function showTab(name) {
  const requested = String(name || "").trim().toLowerCase();
  const canUseRequested = tabButtons.some(btn =>
    btn.dataset.tabBtn === requested && !btn.classList.contains("hidden")
  ) && tabPages.some(page =>
    page.dataset.tab === requested && !page.classList.contains("hidden")
  );
  const fallback = tabButtons.find(btn => !btn.classList.contains("hidden"))?.dataset?.tabBtn || "live";
  const nextTab = canUseRequested ? requested : fallback;

  ui.activeTab = nextTab;
  tabButtons.forEach(btn => {
    btn.classList.toggle("active", btn.dataset.tabBtn === nextTab);
  });
  tabPages.forEach(page => {
    page.classList.toggle("active", page.dataset.tab === nextTab);
  });

  if (nextTab === "custom") {
    applyCustomFixtureSelectionFromTab({ notify: false });
  }
  if (nextTab === "mods") {
    renderModUiFrame({ forceReload: false });
  }

  updateMonitorRenderingState();
  syncDynamicModUiTabButtons();
}

function activateTabAndScroll(tabName, sectionId) {
  showTab(tabName);
  const section = document.getElementById(sectionId);
  if (!section) return;
  if (section.classList.contains("collapsible")) {
    setCollapsibleState(section, false);
  }
  section.scrollIntoView({ behavior: "smooth", block: "start" });
}

function applyFixtureBrandVisibility() {
  const selectedBrand = String(el.fxBrand.value || "hue").trim().toLowerCase();
  const effectiveBrand = resolveFixtureFormBrand("");
  const isHue = selectedBrand === "hue" || effectiveBrand === "hue";
  const isCustomModBrand = selectedBrand === FIXTURE_MOD_CUSTOM_BRAND_VALUE;
  el.fxHueBridgeBlock.classList.toggle("hidden", !isHue);
  el.fxHueBridgeWrap.classList.toggle("hidden", !isHue);
  el.fxHueUserWrap.classList.toggle("hidden", !isHue);
  el.fxHueLightWrap.classList.toggle("hidden", !isHue);
  el.fxHueBridgeIdWrap.classList.toggle("hidden", !isHue);
  el.fxHueClientKeyWrap.classList.toggle("hidden", !isHue);
  el.fxHueEntWrap.classList.toggle("hidden", !isHue);
  el.fxHuePairWrap.classList.toggle("hidden", !isHue);
  el.fxWizIpWrap.classList.toggle("hidden", isHue);
  if (el.fxModBrandWrap) {
    el.fxModBrandWrap.classList.toggle("hidden", !isCustomModBrand);
  }
  if (el.fxWizIpLabel) {
    const infoTipTitle = effectiveBrand === "wiz"
      ? "LAN IP of the WiZ fixture. One fixture per entry in this form."
      : "Adapter-defined target value for non-Hue fixtures. Keep empty if your mod brand adapter does not need this field.";
    const infoLabelText = effectiveBrand === "wiz" ? "WIZ IP" : "MOD TARGET / IP (OPTIONAL)";
    const infoTip = document.createElement("span");
    infoTip.className = "infoTip";
    infoTip.title = infoTipTitle;
    infoTip.textContent = "?";
    el.fxWizIpLabel.replaceChildren(document.createTextNode(`${infoLabelText} `), infoTip);
  }
  syncFixtureCouplingDefaults();
}

function resetFixtureForm() {
  syncFixtureBrandOptions({ selectValue: "hue", customBrand: "", applyVisibility: false });
  el.fxBrand.value = "hue";
  if (el.fxModBrandId) el.fxModBrandId.value = "";
  el.fxId.value = "";
  if (el.fxOriginalId) el.fxOriginalId.value = "";
  el.fxZone.value = "";
  el.fxEnabled.value = "true";
  el.fxEngineEnabled.value = "true";
  el.fxCustomEnabled.value = "false";
  el.fxTwitchEnabled.value = "true";
  el.fxControlMode.value = "engine";
  el.fxEngineBinding.value = "hue";
  el.fxBridgeIp.value = "";
  el.fxUsername.value = "";
  el.fxLightId.value = "1";
  el.fxBridgeId.value = "";
  el.fxClientKey.value = "";
  el.fxEntertainmentAreaId.value = "";
  el.fxWizIp.value = "";
  setSensitiveFieldVisibility(el.fxBridgeIp, el.fxBridgeIpShowBtn, false, "HUE BRIDGE IP");
  setSensitiveFieldVisibility(el.fxUsername, el.fxUsernameShowBtn, false, "HUE USERNAME");
  setSensitiveFieldVisibility(el.fxClientKey, el.fxClientKeyShowBtn, false, "HUE CLIENT KEY");
  setSensitiveFieldVisibility(el.fxWizIp, el.fxWizIpShowBtn, false, "WIZ IP / MOD TARGET");
  applyFixtureBrandVisibility();
}

function setSensitiveFieldVisibility(input, button, show, label = "sensitive field") {
  if (!input || !button) return;
  input.type = show ? "text" : "password";
  button.textContent = show ? "HIDE" : "SHOW";
  button.dataset.revealed = show ? "1" : "0";
  button.title = show
    ? `Hide ${label}.`
    : `Reveal ${label}.`;
}

function bindSensitiveFieldToggle(input, button, label = "this sensitive field") {
  if (!input || !button) return;
  setSensitiveFieldVisibility(input, button, false, label);
  button.onclick = () => {
    const revealed = button.dataset.revealed === "1";
    if (!revealed) {
      const ok = window.confirm(
        `Warning: revealing ${label} can expose sensitive data on stream/screen-share.\n\nShow now?`
      );
      if (!ok) return;
    }
    setSensitiveFieldVisibility(input, button, !revealed, label);
  };
}

function collectFixtureForm() {
  const brand = resolveFixtureFormBrand("");
  const modeState = readFixtureModeFields();
  const nextId = el.fxId.value.trim();
  const replaceIdRaw = String(el.fxOriginalId?.value || "").trim();
  // Only send replaceId when this save has an explicit target ID.
  const replaceId = replaceIdRaw && nextId ? replaceIdRaw : "";
  const base = {
    id: nextId || undefined,
    replaceId: replaceId || undefined,
    brand,
    zone: modeState.zone,
    enabled: el.fxEnabled.value === "true",
    controlMode: modeState.controlMode,
    engineBinding: modeState.engineBinding,
    engineEnabled: modeState.engineEnabled,
    twitchEnabled: modeState.twitchEnabled,
    customEnabled: modeState.customEnabled
  };

  if (brand === "hue") {
    return {
      ...base,
      bridgeIp: el.fxBridgeIp.value.trim(),
      username: el.fxUsername.value.trim(),
      lightId: Number(el.fxLightId.value || 1),
      bridgeId: el.fxBridgeId.value.trim(),
      clientKey: el.fxClientKey.value.trim(),
      entertainmentAreaId: el.fxEntertainmentAreaId.value.trim()
    };
  }

  return {
    ...base,
    ip: el.fxWizIp.value.trim()
  };
}

function fillFixtureForm(fixture) {
  if (!fixture) return;
  const rawBrand = String(fixture.brand || "hue").trim().toLowerCase();
  const brand = isBuiltinFixtureBrand(rawBrand)
    ? rawBrand
    : (normalizeFixtureModBrandToken(rawBrand) || "hue");
  if (!isBuiltinFixtureBrand(brand)) {
    const knownSet = new Set(normalizeFixtureModBrandList(ui.fixtureModBrands));
    knownSet.add(brand);
    ui.fixtureModBrands = [...knownSet].sort();
  }
  syncFixtureBrandOptions({ selectValue: brand, customBrand: brand, applyVisibility: false });
  const engineEnabled = isFixtureEngineEnabled(fixture);
  const twitchEnabled = isFixtureTwitchEnabled(fixture);
  const customEnabled = isFixtureCustomEnabled(fixture);
  const controlMode = engineEnabled ? "engine" : "standalone";
  const engineBinding = engineEnabled ? String(fixture.engineBinding || brand) : "standalone";

  el.fxBrand.value = brand;
  if (!isBuiltinFixtureBrand(brand) && el.fxBrand.value !== brand && el.fxModBrandId) {
    el.fxBrand.value = FIXTURE_MOD_CUSTOM_BRAND_VALUE;
    el.fxModBrandId.value = brand;
  } else if (isBuiltinFixtureBrand(brand) && el.fxModBrandId) {
    el.fxModBrandId.value = "";
  }
  el.fxId.value = fixture.id || "";
  if (el.fxOriginalId) el.fxOriginalId.value = fixture.id || "";
  el.fxZone.value = fixture.zone || getCanonicalZoneForBrand(brand, "custom");
  el.fxEnabled.value = fixture.enabled === false ? "false" : "true";
  el.fxEngineEnabled.value = engineEnabled ? "true" : "false";
  el.fxCustomEnabled.value = customEnabled ? "true" : "false";
  el.fxTwitchEnabled.value = twitchEnabled ? "true" : "false";
  el.fxControlMode.value = controlMode;
  el.fxEngineBinding.value = engineBinding;
  el.fxBridgeIp.value = fixture.bridgeIp || "";
  el.fxUsername.value = fixture.username || "";
  el.fxLightId.value = String(fixture.lightId || 1);
  el.fxBridgeId.value = fixture.bridgeId || "";
  el.fxClientKey.value = fixture.clientKey || "";
  el.fxEntertainmentAreaId.value = fixture.entertainmentAreaId || "";
  el.fxWizIp.value = fixture.ip || "";
  setSensitiveFieldVisibility(el.fxBridgeIp, el.fxBridgeIpShowBtn, false, "HUE BRIDGE IP");
  setSensitiveFieldVisibility(el.fxUsername, el.fxUsernameShowBtn, false, "HUE USERNAME");
  setSensitiveFieldVisibility(el.fxClientKey, el.fxClientKeyShowBtn, false, "HUE CLIENT KEY");
  setSensitiveFieldVisibility(el.fxWizIp, el.fxWizIpShowBtn, false, "WIZ IP / MOD TARGET");
  applyFixtureBrandVisibility();
  showTab("fixtures");
}

async function openFixtureEditor(id) {
  const fixtureId = String(id || "").trim();
  if (!fixtureId) return;
  const fx = await getJson("/fixtures");
  const catalog = Array.isArray(fx?.fixtures)
    ? fx.fixtures
    : (Array.isArray(ui.fixturesCatalog) ? ui.fixturesCatalog : []);
  const target = catalog.find(x => String(x.id) === fixtureId);
  if (target) fillFixtureForm(target);
}

async function requestFixtureDelete(id) {
  const fixtureId = String(id || "").trim();
  if (!fixtureId) return { ok: false, status: 0, data: { error: "missing id" } };

  // Prefer POST delete for maximum compatibility, then fallback to DELETE.
  const tryPostBody = await postJson("/fixtures/fixture/delete", { id: fixtureId });
  if (tryPostBody.ok) return tryPostBody;

  const tryPostQuery = await postJson(`/fixtures/fixture/delete?id=${encodeURIComponent(fixtureId)}`, {});
  if (tryPostQuery.ok) return tryPostQuery;

  const tryDelete = await deleteJson(`/fixtures/fixture?id=${encodeURIComponent(fixtureId)}`);
  if (tryDelete.ok) return tryDelete;

  return tryPostBody.status >= tryPostQuery.status ? tryPostBody : tryPostQuery;
}

async function deleteFixtureFromUi(id) {
  const fixtureId = String(id || "").trim();
  if (!fixtureId) return;
  if (!window.confirm(`Delete fixture ${fixtureId}?`)) return;

  const r = await requestFixtureDelete(fixtureId);
  if (!r.ok) {
    const reason = r?.data?.error || `status ${r.status || 0}`;
    setBadge(el.health, "bad", `FIXTURE DELETE FAIL: ${reason}`);
    return;
  }

  setBadge(el.health, "ok", "FIXTURE DELETED");
  const f = await getJson("/fixtures");
  if (f) {
    updateFixtures(f);
    return;
  }

  const nextCatalog = (Array.isArray(ui.fixturesCatalog) ? ui.fixturesCatalog : []).filter(
    item => String(item?.id || "").trim() !== fixtureId
  );
  applyFixtureCatalogToUi(nextCatalog);
}

function renderFixtureRows(fixtures = []) {
  el.fixtureRows.innerHTML = "";
  if (!fixtures.length) {
    const tr = document.createElement("tr");
    const td = document.createElement("td");
    td.colSpan = 8;
    td.textContent = "No fixtures configured.";
    tr.appendChild(td);
    el.fixtureRows.appendChild(tr);
    return;
  }

  for (const f of fixtures) {
    const tr = document.createElement("tr");
    const brandKey = String(f?.brand || "").trim().toLowerCase();
    const target = brandKey === "hue"
      ? `hue light ${f.lightId || "-"}`
      : brandKey === "wiz"
        ? (isFixtureConfiguredForOutput(f) ? "wiz device configured" : "wiz device pending")
        : `${String(f?.brand || "mod").toUpperCase()} target managed by adapter`;

    const rawId = f.id === undefined || f.id === null || f.id === "" ? null : String(f.id);
    const id = rawId || "-";
    const brand = String((f.brand || "-").toUpperCase());
    const zone = String(f.zone || "-");
    const enabled = f.enabled === false ? "false" : "true";
    const engineEnabled = isFixtureEngineEnabled(f);
    const twitchEnabled = isFixtureTwitchEnabled(f);
    const customEnabled = isFixtureCustomEnabled(f);
    const appliedModes = [
      `ENG ${engineEnabled ? "ON" : "OFF"}`,
      `TWITCH ${twitchEnabled ? "ON" : "OFF"}`,
      `CUSTOM ${customEnabled ? "ON" : "OFF"}`
    ].join(" | ");

    const routeParts = [];
    if (engineEnabled) routeParts.push(String(f.engineBinding || f.brand || "-"));
    if (twitchEnabled) routeParts.push("twitch");
    if (customEnabled) routeParts.push("custom");
    const routePath = routeParts.length ? routeParts.join(" + ") : "-";

    const tdId = document.createElement("td");
    tdId.className = "mono";
    tdId.textContent = id;

    const tdBrand = document.createElement("td");
    tdBrand.textContent = brand;

    const tdZone = document.createElement("td");
    tdZone.className = "mono";
    tdZone.textContent = zone;

    const tdMode = document.createElement("td");
    tdMode.className = "mono";
    tdMode.textContent = appliedModes;

    const tdBinding = document.createElement("td");
    tdBinding.className = "mono";
    tdBinding.textContent = routePath;

    const tdTarget = document.createElement("td");
    tdTarget.className = "mono";
    tdTarget.textContent = target;

    const tdEnabled = document.createElement("td");
    tdEnabled.textContent = enabled;

    const tdActions = document.createElement("td");
    tdActions.className = "grid2";

    const editBtn = document.createElement("button");
    editBtn.type = "button";
    editBtn.textContent = "EDIT";
    editBtn.title = "Open this fixture in the editor form above.";
    if (rawId) {
      editBtn.dataset.editId = rawId;
      editBtn.onclick = () => { openFixtureEditor(rawId); };
    } else editBtn.disabled = true;

    const delBtn = document.createElement("button");
    delBtn.type = "button";
    delBtn.className = "bad";
    delBtn.textContent = "DEL";
    delBtn.title = "Delete this fixture from fixtures.config.json.";
    if (rawId) {
      delBtn.dataset.delId = rawId;
      delBtn.onclick = () => { deleteFixtureFromUi(rawId); };
    } else delBtn.disabled = true;

    tdActions.appendChild(editBtn);
    tdActions.appendChild(delBtn);

    tr.appendChild(tdId);
    tr.appendChild(tdBrand);
    tr.appendChild(tdZone);
    tr.appendChild(tdMode);
    tr.appendChild(tdBinding);
    tr.appendChild(tdTarget);
    tr.appendChild(tdEnabled);
    tr.appendChild(tdActions);
    el.fixtureRows.appendChild(tr);
  }
}

function syncStandaloneValueLabels() {
  el.standBrightnessVal.textContent = String(clampInt(el.standBrightness.value, 1, 100, 70));
  el.standRaveStopBrightnessVal.textContent = String(clampInt(el.standRaveStopBrightness.value, 1, 100, 100));
  el.standHueVal.textContent = String(clampInt(el.standHue.value, 0, 359, 210));
  el.standSatVal.textContent = String(clampInt(el.standSat.value, 0, 100, 80));
  el.standHueMinVal.textContent = String(clampInt(el.standHueMin.value, 0, 359, 0));
  el.standHueMaxVal.textContent = String(clampInt(el.standHueMax.value, 0, 359, 359));
  el.standSatMinVal.textContent = String(clampInt(el.standSatMin.value, 0, 100, 45));
  el.standSatMaxVal.textContent = String(clampInt(el.standSatMax.value, 0, 100, 100));
  el.standCctKelvinVal.textContent = String(clampInt(el.standCctKelvin.value, 2200, 6500, 4000));
  el.standCctMinKelvinVal.textContent = String(clampInt(el.standCctMinKelvin.value, 2200, 6500, 2700));
  el.standCctMaxKelvinVal.textContent = String(clampInt(el.standCctMaxKelvin.value, 2200, 6500, 6500));
  el.standSpeedMinHzVal.textContent = clampNumber(el.standSpeedMinHz.value, 0.2, 12, 0.6).toFixed(1);
  el.standSpeedMaxHzVal.textContent = clampNumber(el.standSpeedMaxHz.value, 0.2, 12, 3.2).toFixed(1);
}

function getFixtureById(id) {
  const key = String(id || "").trim();
  if (!key) return null;
  return ui.fixturesCatalog.find(f => String(f.id) === key) || null;
}

function getFixtureRouteFlags(fixture) {
  return {
    engineEnabled: isFixtureEngineEnabled(fixture || {}),
    twitchEnabled: isFixtureTwitchEnabled(fixture || {}),
    customEnabled: isFixtureCustomEnabled(fixture || {})
  };
}

function summarizeRouteFlags(flags = {}) {
  const active = [];
  if (flags.engineEnabled) active.push("engine");
  if (flags.twitchEnabled) active.push("twitch");
  if (flags.customEnabled) active.push("custom");
  return active.length ? active.join("+") : "none";
}

function getFixtureConnectivityRecord(id) {
  const key = String(id || "").trim();
  if (!key) return null;
  return ui.fixtureConnectivityById[key] || null;
}

function getConnectivityStatusLabel(fixture, record) {
  const brand = String(fixture?.brand || "").trim().toLowerCase();
  if (!record) {
    if (brand !== "hue" && brand !== "wiz") return "MOD-BRAND (ADAPTER OWNED)";
    return "CHECK PENDING";
  }

  const status = String(record.status || "").trim().toLowerCase();
  if (status === "reachable") return "TARGET READY";
  if (status === "unreachable") return "TARGET UNREACHABLE";
  if (status === "not_configured") return "TARGET NOT CONFIGURED";
  if (status === "skipped") return "MOD-BRAND (ADAPTER OWNED)";
  if (status === "pending") return "CHECK PENDING";
  return "TARGET UNKNOWN";
}

function maskHostForDisplay(hostValue) {
  const raw = String(hostValue || "").trim();
  if (!raw) return "-";

  const bracketIpv6WithPort = raw.match(/^\[([^\]]+)\]:(\d{1,5})$/);
  if (bracketIpv6WithPort) {
    return `[${String(bracketIpv6WithPort[1] || "").slice(0, 2)}***]:${bracketIpv6WithPort[2]}`;
  }

  const ipv4WithPort = raw.match(/^(\d{1,3}(?:\.\d{1,3}){3}):(\d{1,5})$/);
  if (ipv4WithPort) {
    const parts = ipv4WithPort[1].split(".");
    return `${parts[0]}.***.***.${parts[3]}:${ipv4WithPort[2]}`;
  }

  const ipv4Only = raw.match(/^(\d{1,3})(?:\.(\d{1,3})){3}$/);
  if (ipv4Only) {
    const parts = raw.split(".");
    return `${parts[0]}.***.***.${parts[3]}`;
  }

  const hostWithPort = raw.match(/^([^:]+):(\d{1,5})$/);
  if (hostWithPort) {
    const host = String(hostWithPort[1] || "").trim();
    const maskedHost = host.length <= 2
      ? `${host.slice(0, 1)}*`
      : `${host.slice(0, 2)}***${host.slice(-1)}`;
    return `${maskedHost}:${hostWithPort[2]}`;
  }

  if (raw.startsWith("[") && raw.endsWith("]")) {
    const core = raw.slice(1, -1);
    return `[${core.slice(0, 2)}***]`;
  }

  if (raw.length <= 2) return `${raw.slice(0, 1)}*`;
  return `${raw.slice(0, 2)}***${raw.slice(-1)}`;
}

function renderSelectedFixtureConnectivityStatus(fixture) {
  if (!fixture) {
    el.standConnectivityStatus.value = "No fixture selected.";
    return;
  }

  const record = getFixtureConnectivityRecord(fixture.id);
  const host = String(record?.host || "").trim() || (fixture.brand === "hue"
    ? String(fixture.bridgeIp || "").trim()
    : String(fixture.ip || "").trim()) || "-";
  const maskedHost = maskHostForDisplay(host);
  const label = getConnectivityStatusLabel(fixture, record);
  const detail = String(record?.detail || "").trim();
  const checkedAt = Number(record?.checkedAt || 0) > 0
    ? new Date(Number(record.checkedAt)).toLocaleTimeString()
    : "-";
  el.standConnectivityStatus.value = `${fixture.id} | ${label} | host ${maskedHost} | ${detail || "no detail"} | checked ${checkedAt}`;
}

function updateConnectivityCache(entries, options = {}) {
  const merge = options && options.merge === true;
  const next = merge ? { ...ui.fixtureConnectivityById } : {};
  for (const entry of (Array.isArray(entries) ? entries : [])) {
    const id = String(entry?.id || "").trim();
    if (!id) continue;
    next[id] = entry;
  }
  ui.fixtureConnectivityById = next;
}

function normalizeStandaloneMode(value) {
  const mode = String(value || "").trim().toLowerCase();
  if (mode === "rgb" || mode === "scene" || mode === "auto") return mode;
  return "scene";
}

function normalizeStandaloneScene(value) {
  const scene = String(value || "").trim().toLowerCase();
  if (scene === "sweep" || scene === "bounce" || scene === "pulse" || scene === "spark") return scene;
  return "sweep";
}

function normalizeStandaloneSpeedMode(value) {
  const mode = String(value || "").trim().toLowerCase();
  if (mode === "fixed" || mode === "audio") return mode;
  return "fixed";
}

function normalizeStandaloneColorMode(value) {
  const mode = String(value || "").trim().toLowerCase();
  if (mode === "hsv" || mode === "cct") return mode;
  return "hsv";
}

function setStandaloneToggleState(node, enabled, labels = {}) {
  if (!node) return;
  const on = Boolean(enabled);
  const onLabel = String(labels.on || "ON");
  const offLabel = String(labels.off || "OFF");
  node.dataset.on = on ? "true" : "false";
  node.setAttribute("aria-pressed", on ? "true" : "false");
  node.classList.toggle("active", on);
  node.textContent = on ? onLabel : offLabel;
}

function getStandaloneToggleState(node) {
  return node?.dataset?.on === "true";
}

function resolveStandaloneModeForFixture(entry) {
  const id = String(entry?.id || ui.standaloneSelectedId || "").trim();
  const stored = id ? ui.standaloneModeByFixture[id] : "";
  if (stored === "rgb" || stored === "scene" || stored === "auto") return stored;
  const explicitRaw = String(entry?.state?.mode || "").trim().toLowerCase();
  const explicit = normalizeStandaloneMode(explicitRaw);
  if (explicitRaw && (explicit === "rgb" || explicit === "scene" || explicit === "auto")) return explicit;
  return entry?.state?.animate ? "scene" : "rgb";
}

function getAutoStandaloneHz() {
  const telemetry = ui.lastRaveTelemetry && typeof ui.lastRaveTelemetry === "object"
    ? ui.lastRaveTelemetry
    : {};
  const audioSnap = ui.lastAudioTelemetry && typeof ui.lastAudioTelemetry === "object"
    ? ui.lastAudioTelemetry
    : {};
  const bpm = Number(ui.lastBpm || telemetry.bpm || 0);
  const fallbackHz = 1.2;
  const bpmHz = Number.isFinite(bpm) && bpm > 0
    ? clampNumber(bpm / 96, 0.35, 12, fallbackHz)
    : fallbackHz;
  const rms = clampNumber(
    Number(telemetry.audioSourceLevel ?? telemetry.rms ?? audioSnap.level ?? audioSnap.rms),
    0,
    1,
    0
  );
  const beat = clampNumber(Number(telemetry.beatConfidence), 0, 1, 0);
  const transient = clampNumber(Number(telemetry.audioTransient ?? audioSnap.transient), 0, 1, 0);
  const flux = clampNumber(Number(telemetry.audioFlux ?? telemetry.flux ?? audioSnap.flux), 0, 1, 0);
  const energy = clampNumber(Number(telemetry.energy), 0, 1, 0);
  const motion = clampNumber(Math.max(beat, transient, flux), 0, 1, 0);
  const drive = clampNumber((energy * 0.58) + (motion * 0.42), 0, 1, 0);
  const dynamicHz = clampNumber(
    0.55 + (drive * 8.2) + (Math.max(0, motion - 0.58) * 4.6),
    0.35,
    12,
    fallbackHz
  );
  let autoHz = (bpmHz * 0.58) + (dynamicHz * 0.42);

  const calmTrack = rms < 0.09 && transient < 0.14 && flux < 0.14 && motion < 0.2;
  if (calmTrack) {
    autoHz = Math.min(autoHz, 2.4 + (drive * 1.4));
  }

  const intensePeak = drive > 0.72 || motion > 0.68;
  if (intensePeak) {
    autoHz = Math.max(autoHz, clampNumber(6.2 + (drive * 5.2), 6.2, 12, 8));
  }

  return clampNumber(autoHz, 0.35, 12, fallbackHz);
}

function syncStandaloneModeUi(options = {}) {
  const mode = normalizeStandaloneMode(el.standMode.value);
  const enabled = options.enabled !== false;
  const fixtureId = String(el.standFixtureSelect.value || "").trim();
  const isRgb = mode === "rgb";
  const isAuto = mode === "auto";
  const staticOn = getStandaloneToggleState(el.standStaticBtn);
  const speedMode = normalizeStandaloneSpeedMode(el.standSpeedMode.value);
  const colorMode = normalizeStandaloneColorMode(el.standColorMode.value);
  const useAudioSpeed = speedMode === "audio" && !staticOn;

  el.standMode.value = mode;
  el.standScene.value = normalizeStandaloneScene(el.standScene.value);
  el.standSpeedMode.value = speedMode;
  el.standColorMode.value = colorMode;
  el.standAnimate.value = isRgb ? "false" : "true";

  if (isAuto) {
    const autoHz = getAutoStandaloneHz();
    el.standSpeedHz.value = String(Number(autoHz.toFixed(2)));
  }

  el.standMode.disabled = !enabled;
  el.standScene.disabled = !enabled;
  el.standSpeedMode.disabled = !enabled || staticOn;
  el.standSpeedHz.disabled = !enabled || staticOn || useAudioSpeed;
  el.standSpeedMinHz.disabled = !enabled || staticOn || !useAudioSpeed;
  el.standSpeedMaxHz.disabled = !enabled || staticOn || !useAudioSpeed;
  el.standColorMode.disabled = !enabled;
  el.standStaticBtn.disabled = !enabled;
  el.standRaveStartBtn.disabled = !enabled;
  el.standRaveStopBtn.disabled = !enabled;
  el.standSpeedHz.title = isAuto
    ? "AUTO HZ follows live BPM + audio motion telemetry."
    : (staticOn
      ? "STATIC is on, so speed is frozen."
      : (useAudioSpeed
        ? "Audio-reactive speed uses MIN/MAX sliders."
        : "Scene speed in Hz."));

  if (Number(el.standSpeedMinHz.value) > Number(el.standSpeedMaxHz.value)) {
    el.standSpeedMaxHz.value = String(el.standSpeedMinHz.value);
  }
  if (Number(el.standHueMin.value) > Number(el.standHueMax.value)) {
    el.standHueMax.value = String(el.standHueMin.value);
  }
  if (Number(el.standSatMin.value) > Number(el.standSatMax.value)) {
    el.standSatMax.value = String(el.standSatMin.value);
  }
  if (Number(el.standCctMinKelvin.value) > Number(el.standCctMaxKelvin.value)) {
    el.standCctMaxKelvin.value = String(el.standCctMinKelvin.value);
  }

  const showCct = colorMode === "cct";
  el.standHsvSingleWrap.classList.toggle("hidden", showCct);
  el.standHsvRangeRow.classList.toggle("hidden", showCct);
  el.standCctRangeRow.classList.toggle("hidden", !showCct);
  el.standHue.disabled = !enabled || showCct;
  el.standSat.disabled = !enabled || showCct;
  el.standHueMin.disabled = !enabled || showCct;
  el.standHueMax.disabled = !enabled || showCct;
  el.standSatMin.disabled = !enabled || showCct;
  el.standSatMax.disabled = !enabled || showCct;
  el.standCctKelvin.disabled = !enabled || !showCct;
  el.standCctMinKelvin.disabled = !enabled || !showCct;
  el.standCctMaxKelvin.disabled = !enabled || !showCct;

  syncStandaloneValueLabels();

  if (fixtureId) {
    ui.standaloneModeByFixture[fixtureId] = mode;
  }
}

function setCustomClusterVisible(visible) {
  el.standCustomCluster.classList.toggle("hidden", !visible);
}

function setRouteChipState(node, enabled) {
  if (!node) return;
  const on = Boolean(enabled);
  node.dataset.on = on ? "true" : "false";
  node.classList.toggle("active", on);
  node.setAttribute("aria-pressed", on ? "true" : "false");
}

function getRouteChipState(node) {
  return node?.dataset?.on === "true";
}

function clearRouteDraftState() {
  ui.routeDraftDirty = false;
  ui.routeDraftFixtureId = "";
  ui.routeDraftFlags = null;
}

function clearStandaloneDraftState() {
  ui.standaloneDraftDirty = false;
  ui.standaloneDraftFixtureId = "";
  ui.standaloneDraftTouchedAt = 0;
}

function hasStandaloneDraftForFixture(id) {
  const fixtureId = String(id || "").trim();
  if (!fixtureId) return false;
  if (!ui.standaloneDraftDirty) return false;
  return String(ui.standaloneDraftFixtureId || "") === fixtureId;
}

function markStandaloneDraftDirty() {
  const fixtureId = String(el.standFixtureSelect?.value || ui.standaloneSelectedId || "").trim();
  if (!fixtureId) return;
  ui.standaloneDraftDirty = true;
  ui.standaloneDraftFixtureId = fixtureId;
  ui.standaloneDraftTouchedAt = Date.now();
  refreshStandaloneDraftStatus();
}

function setRouteDraftStateFromCurrentChips() {
  const id = String(el.standFixtureSelect.value || "").trim();
  if (!id) {
    clearRouteDraftState();
    return;
  }

  ui.routeDraftDirty = true;
  ui.routeDraftFixtureId = id;
  ui.routeDraftFlags = {
    engineEnabled: getRouteChipState(el.standRouteEngine),
    twitchEnabled: getRouteChipState(el.standRouteTwitch),
    customEnabled: getRouteChipState(el.standRouteCustom)
  };
}

function getRouteDraftFlagsForFixture(id) {
  const fixtureId = String(id || "").trim();
  if (!fixtureId || !ui.routeDraftDirty) return null;
  if (String(ui.routeDraftFixtureId || "") !== fixtureId) return null;
  const flags = ui.routeDraftFlags && typeof ui.routeDraftFlags === "object"
    ? ui.routeDraftFlags
    : null;
  if (!flags) return null;
  return {
    engineEnabled: flags.engineEnabled === true,
    twitchEnabled: flags.twitchEnabled === true,
    customEnabled: flags.customEnabled === true
  };
}

function toggleRouteChip(node) {
  if (!node) return;
  setRouteChipState(node, !getRouteChipState(node));
}

function enforceRouteToggleConstraints(options = {}) {
  const source = String(options.source || "").trim().toLowerCase();
  let engineOn = getRouteChipState(el.standRouteEngine);
  let customOn = getRouteChipState(el.standRouteCustom);

  if (engineOn && customOn) {
    if (source === "custom") {
      // Last user action wins: enabling CUSTOM turns ENGINE off.
      setRouteChipState(el.standRouteEngine, false);
      engineOn = false;
      setBadge(el.health, "warn", "ENGINE DISABLED (CUSTOM ENABLED)");
    } else {
      // Default/fallback behavior keeps ENGINE and turns CUSTOM off.
      setRouteChipState(el.standRouteCustom, false);
      customOn = false;
      if (source === "engine") {
        setBadge(el.health, "warn", "CUSTOM DISABLED (ENGINE ENABLED)");
      }
    }
  }

  el.standRouteCustom.disabled = false;
  el.standRouteTwitch.disabled = false;
  el.standRouteCustom.title = engineOn
    ? "Enable CUSTOM to take control and automatically disable ENGINE."
    : "Enable standalone custom control for this fixture.";

  setCustomClusterVisible(customOn);
}

function setStandaloneControlEnabled(enabled) {
  const isEnabled = Boolean(enabled);
  [
    el.standPower,
    el.standMode,
    el.standScene,
    el.standAnimate,
    el.standSpeedMode,
    el.standBrightness,
    el.standRaveStopBrightness,
    el.standHue,
    el.standHueMin,
    el.standHueMax,
    el.standSat,
    el.standSatMin,
    el.standSatMax,
    el.standCctKelvin,
    el.standCctMinKelvin,
    el.standCctMaxKelvin,
    el.standSpeedHz,
    el.standSpeedMinHz,
    el.standSpeedMaxHz,
    el.standColorMode,
    el.standStaticBtn,
    el.standRaveStartBtn,
    el.standRaveStopBtn,
    el.standTransitionMs,
    el.standApplyBtn
  ].forEach(node => {
    node.disabled = !isEnabled;
  });
  syncStandaloneModeUi({ enabled: isEnabled });
}

function initCustomControlTabMount() {
  if (!el.customStandaloneMount || !el.standCustomCluster) return;
  if (el.standCustomCluster.parentElement !== el.customStandaloneMount) {
    el.customStandaloneMount.appendChild(el.standCustomCluster);
  }
}

function renderCustomFixtureSelector(fixtures = []) {
  if (!el.customFixtureSelect) return;
  const standaloneCatalog = Array.isArray(ui.standaloneFixtures) ? ui.standaloneFixtures : [];
  const baseCatalog = standaloneCatalog.length
    ? standaloneCatalog
    : (Array.isArray(fixtures) ? fixtures : []);
  const catalog = baseCatalog
    .filter(fixture => fixture && isFixtureCustomEnabled(fixture));
  const previous = String(
    el.customFixtureSelect.value ||
    (isFixtureCustomEnabled(getFixtureById(ui.standaloneSelectedId)) ? ui.standaloneSelectedId : "")
  ).trim();

  el.customFixtureSelect.innerHTML = "";
  const placeholder = document.createElement("option");
  placeholder.value = "";
  placeholder.textContent = catalog.length
    ? "select custom fixture"
    : "no fixtures routed as CUSTOM";
  el.customFixtureSelect.appendChild(placeholder);

  for (const fixture of catalog) {
    const id = String(fixture?.id || "").trim();
    if (!id) continue;
    const option = document.createElement("option");
    const brand = String(fixture.brand || "").toUpperCase();
    const zone = String(
      fixture.zone ||
      (String(fixture.brand || "").trim().toLowerCase() === "hue" ? "hue" : "wiz")
    );
    option.value = id;
    option.textContent = `${id} | ${brand} | ${zone}`;
    el.customFixtureSelect.appendChild(option);
  }

  const hasPrevious = previous && catalog.some(fixture => String(fixture.id) === previous);
  el.customFixtureSelect.value = hasPrevious ? previous : String(catalog[0]?.id || "");
}

function syncCustomFixtureSelectorFromCurrentSelection() {
  if (!el.customFixtureSelect) return;
  const selectedId = String(ui.standaloneSelectedId || "").trim();
  if (!selectedId) return;
  const fixture = getFixtureById(selectedId);
  if (!fixture || !isFixtureCustomEnabled(fixture)) return;
  const option = Array.from(el.customFixtureSelect.options).find(opt => opt.value === selectedId);
  if (!option) return;
  el.customFixtureSelect.value = selectedId;
}

function applyCustomFixtureSelectionFromTab(options = {}) {
  const selectedId = String(el.customFixtureSelect?.value || "").trim();
  if (!selectedId) {
    clearStandaloneDraftState();
    setCustomClusterVisible(false);
    applyStandaloneEntryToControls(null);
    if (options.notify) {
      setBadge(el.health, "warn", "NO CUSTOM FIXTURE ROUTED");
    }
    return false;
  }

  el.standFixtureSelect.value = selectedId;
  syncRouteSelectionUi();
  if (options.notify) {
    setBadge(el.health, "ok", `CUSTOM FIXTURE ${selectedId}`);
  }
  return true;
}

function renderRouteFixtureOptions(fixtures = []) {
  const previous = String(ui.standaloneSelectedId || el.standFixtureSelect.value || "").trim();
  const optionsCatalog = Array.isArray(fixtures) ? fixtures.slice() : [];

  el.standFixtureSelect.innerHTML = "";
  const placeholder = document.createElement("option");
  placeholder.value = "";
  placeholder.textContent = "select fixture";
  el.standFixtureSelect.appendChild(placeholder);

  for (const fixture of optionsCatalog) {
    const id = String(fixture?.id || "").trim();
    if (!id) continue;
    const option = document.createElement("option");
    const brand = String(fixture.brand || "").toUpperCase();
    const brandKey = String(fixture.brand || "").trim().toLowerCase();
    const zone = String(
      fixture.zone ||
      (brandKey === "hue" ? "hue" : (brandKey === "wiz" ? "wiz" : "custom"))
    );
    const customWord = isFixtureCustomEnabled(fixture) ? "custom:on" : "custom:off";
    option.value = id;
    option.textContent = `${id} | ${brand} | ${zone} | ${customWord}`;
    el.standFixtureSelect.appendChild(option);
  }

  const hasPrevious = previous && optionsCatalog.some(f => String(f.id) === previous);
  ui.standaloneSelectedId = hasPrevious ? previous : "";
  el.standFixtureSelect.value = ui.standaloneSelectedId;
  renderCustomFixtureSelector(optionsCatalog);
  syncRouteSelectionUi();
  const hasSelectedFixture = Boolean(String(ui.standaloneSelectedId || "").trim());
  const selectedCustomId = String(el.customFixtureSelect?.value || "").trim();
  if (!hasSelectedFixture && selectedCustomId) {
    applyCustomFixtureSelectionFromTab({ notify: false });
  }
}

function getStandaloneEntryById(id) {
  const key = String(id || "").trim();
  if (!key) return null;
  return ui.standaloneFixtures.find(f => String(f.id) === key) || null;
}

function renderRouteDraftStatus(fixture) {
  if (!fixture) return;
  const currentFlags = {
    engineEnabled: getRouteChipState(el.standRouteEngine),
    twitchEnabled: getRouteChipState(el.standRouteTwitch),
    customEnabled: getRouteChipState(el.standRouteCustom)
  };
  const statusWord = getRouteDraftFlagsForFixture(fixture.id) ? "DRAFT" : "APPLIED";
  const connectivityRecord = getFixtureConnectivityRecord(fixture.id);
  const configuredWord = connectivityRecord
    ? getConnectivityStatusLabel(fixture, connectivityRecord)
    : (isFixtureConfiguredForOutput(fixture) ? "TARGET CONFIGURED" : "TARGET NOT CONFIGURED");
  const savedAtText = ui.routeLastSavedAt
    ? new Date(ui.routeLastSavedAt).toLocaleTimeString()
    : "-";
  const brandKey = String(fixture.brand || "").trim().toLowerCase();
  const zone = String(
    fixture.zone ||
    (brandKey === "hue" ? "hue" : (brandKey === "wiz" ? "wiz" : "custom"))
  );
  el.standRouteStatus.value =
    `${fixture.id} | zone ${zone} | ` +
    `modes ${summarizeRouteFlags(currentFlags).toUpperCase()} | ${statusWord} | ${configuredWord} | last save ${savedAtText}`;
  renderSelectedFixtureConnectivityStatus(fixture);
}

function applyStandaloneEntryToControls(entry) {
  if (!entry || !entry.state) {
    el.standPower.value = "true";
    el.standMode.value = "rgb";
    el.standScene.value = "sweep";
    el.standAnimate.value = "false";
    el.standSpeedMode.value = "fixed";
    el.standSpeedHz.value = "1.2";
    el.standSpeedMinHz.value = "0.6";
    el.standSpeedMaxHz.value = "3.2";
    el.standBrightness.value = "70";
    el.standRaveStopBrightness.value = "100";
    el.standHue.value = "210";
    el.standHueMin.value = "0";
    el.standHueMax.value = "359";
    el.standSat.value = "80";
    el.standSatMin.value = "45";
    el.standSatMax.value = "100";
    el.standColorMode.value = "hsv";
    el.standCctKelvin.value = "4000";
    el.standCctMinKelvin.value = "2700";
    el.standCctMaxKelvin.value = "6500";
    setStandaloneToggleState(el.standStaticBtn, false, { on: "STATIC ON", off: "STATIC OFF" });
    setStandaloneToggleState(el.standRaveStartBtn, false, { on: "RAVE-START UPDATE ON", off: "RAVE-START UPDATE OFF" });
    setStandaloneToggleState(el.standRaveStopBtn, false, { on: "RAVE-END UPDATE ON", off: "RAVE-END UPDATE OFF" });
    el.standTransitionMs.value = "350";
    syncStandaloneValueLabels();
    setStandaloneControlEnabled(false);
    el.standStatus.value = "No standalone fixture selected.";
    return;
  }

  const state = entry.state || {};
  const mode = resolveStandaloneModeForFixture(entry);
  el.standPower.value = state.on === false ? "false" : "true";
  el.standMode.value = mode;
  el.standScene.value = normalizeStandaloneScene(state.scene);
  el.standAnimate.value = mode === "rgb" ? "false" : "true";
  el.standSpeedMode.value = normalizeStandaloneSpeedMode(state.speedMode);
  el.standSpeedHz.value = String(clampNumber(state.speedHz, 0.2, 12, 1.2));
  el.standSpeedMinHz.value = String(clampNumber(state.speedHzMin, 0.2, 12, 0.6));
  el.standSpeedMaxHz.value = String(clampNumber(state.speedHzMax, 0.2, 12, 3.2));
  el.standBrightness.value = String(clampInt(state.bri, 1, 100, 70));
  el.standRaveStopBrightness.value = String(clampInt(state.raveStopBri, 1, 100, 100));
  el.standHue.value = String(clampInt(state.hue, 0, 359, 210));
  el.standHueMin.value = String(clampInt(state.hueMin, 0, 359, 0));
  el.standHueMax.value = String(clampInt(state.hueMax, 0, 359, 359));
  el.standSat.value = String(clampInt(state.sat, 0, 100, 80));
  el.standSatMin.value = String(clampInt(state.satMin, 0, 100, 45));
  el.standSatMax.value = String(clampInt(state.satMax, 0, 100, 100));
  el.standColorMode.value = normalizeStandaloneColorMode(state.colorMode);
  el.standCctKelvin.value = String(clampInt(state.cctKelvin, 2200, 6500, 4000));
  el.standCctMinKelvin.value = String(clampInt(state.cctMinKelvin, 2200, 6500, 2700));
  el.standCctMaxKelvin.value = String(clampInt(state.cctMaxKelvin, 2200, 6500, 6500));
  setStandaloneToggleState(el.standStaticBtn, state.static === true, { on: "STATIC ON", off: "STATIC OFF" });
  setStandaloneToggleState(el.standRaveStartBtn, state.updateOnRaveStart === true, { on: "RAVE-START UPDATE ON", off: "RAVE-START UPDATE OFF" });
  setStandaloneToggleState(el.standRaveStopBtn, state.updateOnRaveStop === true, { on: "RAVE-END UPDATE ON", off: "RAVE-END UPDATE OFF" });
  el.standTransitionMs.value = String(clampInt(state.transitionMs, 0, 10000, 350));
  syncStandaloneValueLabels();
  const supportsStandaloneUi = entry.brand === "hue" || entry.brand === "wiz";
  const controlsEnabled = entry.enabled !== false && supportsStandaloneUi;
  setStandaloneControlEnabled(controlsEnabled);
  syncStandaloneModeUi({ enabled: controlsEnabled });

  const brand = String(entry.brand || "").toUpperCase();
  const zone = String(entry.zone || "-");
  const sceneWord = normalizeStandaloneScene(state.scene).toUpperCase();
  const colorWord = normalizeStandaloneColorMode(state.colorMode).toUpperCase();
  const staticWord = state.static ? "static" : (entry.animating ? "animating" : "ready");
  const startWord = state.updateOnRaveStart ? "start:on" : "start:off";
  const stopWord = state.updateOnRaveStop ? "stop:on" : "stop:off";
  const stateWord = entry.enabled === false ? "disabled" : `${staticWord} | scene ${sceneWord} | ${colorWord} | ${startWord} | ${stopWord}`;
  if (!supportsStandaloneUi) {
    el.standStatus.value = `${entry.id} | ${brand} | zone ${zone} | mode ${mode.toUpperCase()} | standalone UI unsupported for this brand (use mod actions)`;
    return;
  }
  el.standStatus.value = `${entry.id} | ${brand} | zone ${zone} | mode ${mode.toUpperCase()} | ${stateWord}`;
}

function syncRouteSelectionUi() {
  const selectedId = String(el.standFixtureSelect.value || "").trim();
  const previousSelectedId = String(ui.standaloneSelectedId || "").trim();
  if (previousSelectedId && previousSelectedId !== selectedId) {
    clearStandaloneDraftState();
  }
  if (ui.routeDraftDirty && ui.routeDraftFixtureId && ui.routeDraftFixtureId !== selectedId) {
    clearRouteDraftState();
  }
  ui.standaloneSelectedId = selectedId;
  const fixture = getFixtureById(selectedId);
  if (!fixture) {
    clearRouteDraftState();
    clearStandaloneDraftState();
    el.standRouteStatus.value = "Select a fixture, choose ENGINE/TWITCH/CUSTOM, then click APPLY ROUTING.";
    el.standConnectivityStatus.value = "No fixture selected.";
    setRouteChipState(el.standRouteEngine, false);
    setRouteChipState(el.standRouteTwitch, false);
    setRouteChipState(el.standRouteCustom, false);
    enforceRouteToggleConstraints();
    setCustomClusterVisible(false);
    applyStandaloneEntryToControls(null);
    return;
  }

  const flags = getRouteDraftFlagsForFixture(fixture.id) || getFixtureRouteFlags(fixture);
  setRouteChipState(el.standRouteEngine, flags.engineEnabled);
  setRouteChipState(el.standRouteTwitch, flags.twitchEnabled);
  setRouteChipState(el.standRouteCustom, flags.customEnabled);
  enforceRouteToggleConstraints();

  const currentFlags = {
    engineEnabled: getRouteChipState(el.standRouteEngine),
    twitchEnabled: getRouteChipState(el.standRouteTwitch),
    customEnabled: getRouteChipState(el.standRouteCustom)
  };
  renderRouteDraftStatus(fixture);

  const showCustom = currentFlags.customEnabled;
  setCustomClusterVisible(showCustom);
  if (!showCustom) {
    clearStandaloneDraftState();
    applyStandaloneEntryToControls(null);
    syncCustomFixtureSelectorFromCurrentSelection();
    return;
  }

  const standaloneEntry = getStandaloneEntryById(fixture.id);
  if (hasStandaloneDraftForFixture(fixture.id)) {
    refreshStandaloneDraftStatus();
  } else {
    applyStandaloneEntryToControls(standaloneEntry);
  }
  syncCustomFixtureSelectorFromCurrentSelection();
}

function renderStandaloneFixtures(entries = [], options = {}) {
  const preserveDraft = options && options.preserveDraft === true;
  const safeEntries = Array.isArray(entries) ? entries : [];
  ui.standaloneFixtures = safeEntries.slice();
  renderCustomFixtureSelector(ui.standaloneFixtures);

  if (!preserveDraft) {
    syncRouteSelectionUi();
    return;
  }

  const fixture = getFixtureById(ui.standaloneSelectedId);
  const customEnabled = getRouteChipState(el.standRouteCustom);
  if (customEnabled && fixture) {
    const selected = getStandaloneEntryById(ui.standaloneSelectedId);
    if (selected && !hasStandaloneDraftForFixture(ui.standaloneSelectedId)) {
      applyStandaloneEntryToControls(selected);
    } else if (selected) {
      refreshStandaloneDraftStatus();
    }
  }
}

function collectStandaloneStateFromControls() {
  const fixtureId = String(el.standFixtureSelect.value || "").trim();
  const mode = normalizeStandaloneMode(el.standMode.value);
  const scene = normalizeStandaloneScene(el.standScene.value);
  const speedMode = normalizeStandaloneSpeedMode(el.standSpeedMode.value);
  const colorMode = normalizeStandaloneColorMode(el.standColorMode.value);
  const staticOn = getStandaloneToggleState(el.standStaticBtn);
  const updateOnRaveStart = getStandaloneToggleState(el.standRaveStartBtn);
  const updateOnRaveStop = getStandaloneToggleState(el.standRaveStopBtn);
  if (fixtureId) {
    ui.standaloneModeByFixture[fixtureId] = mode;
  }
  const sceneHz = clampNumber(el.standSpeedHz.value, 0.2, 12, 1.2);
  const autoHz = getAutoStandaloneHz();
  const animate = mode !== "rgb";
  const speedHz = mode === "auto" ? autoHz : sceneHz;

  return {
    on: el.standPower.value === "true",
    animate,
    static: staticOn,
    updateOnRaveStart,
    updateOnRaveStop,
    raveStopBri: clampInt(el.standRaveStopBrightness.value, 1, 100, 100),
    speedHz,
    speedMode,
    speedHzMin: clampNumber(el.standSpeedMinHz.value, 0.2, 12, 0.6),
    speedHzMax: clampNumber(el.standSpeedMaxHz.value, 0.2, 12, 3.2),
    mode,
    scene,
    bri: clampInt(el.standBrightness.value, 1, 100, 70),
    hue: clampInt(el.standHue.value, 0, 359, 210),
    hueMin: clampInt(el.standHueMin.value, 0, 359, 0),
    hueMax: clampInt(el.standHueMax.value, 0, 359, 359),
    sat: clampInt(el.standSat.value, 0, 100, 80),
    satMin: clampInt(el.standSatMin.value, 0, 100, 45),
    satMax: clampInt(el.standSatMax.value, 0, 100, 100),
    colorMode,
    cctKelvin: clampInt(el.standCctKelvin.value, 2200, 6500, 4000),
    cctMinKelvin: clampInt(el.standCctMinKelvin.value, 2200, 6500, 2700),
    cctMaxKelvin: clampInt(el.standCctMaxKelvin.value, 2200, 6500, 6500),
    transitionMs: clampInt(el.standTransitionMs.value, 0, 10000, 350)
  };
}

async function refreshStandaloneFixtures() {
  const snapshot = await getJson("/fixtures/standalone");
  if (!snapshot || !snapshot.ok || !Array.isArray(snapshot.fixtures)) {
    return false;
  }
  renderStandaloneFixtures(snapshot.fixtures, { preserveDraft: true });
  return true;
}

async function testFixtureConnectivity() {
  const fixtureId = String(el.standFixtureSelect.value || "").trim();
  const fixture = getFixtureById(fixtureId);
  if (!fixture) {
    setBadge(el.health, "warn", "SELECT FIXTURE");
    return false;
  }

  el.standConnectivityStatus.value = `${fixtureId} | CHECKING CONNECTIVITY...`;
  const response = await postJson("/fixtures/connectivity/test", { id: fixtureId, timeoutMs: 1200 });
  if (!response.ok || !response.data?.ok) {
    const reason = response.data?.error || "connectivity test failed";
    setBadge(el.health, "bad", `CONNECTIVITY FAIL: ${reason}`);
    el.standConnectivityStatus.value = `${fixtureId} | TARGET UNKNOWN | ${reason}`;
    return false;
  }

  updateConnectivityCache(response.data.results || [], { merge: true });
  ui.connectivitySummary = response.data.summary || null;
  const record = getFixtureConnectivityRecord(fixtureId);
  renderSelectedFixtureConnectivityStatus(fixture);
  renderRouteDraftStatus(fixture);

  const status = String(record?.status || "").trim().toLowerCase();
  if (status === "reachable") {
    setBadge(el.health, "ok", "CONNECTIVITY OK");
  } else if (status === "unreachable") {
    setBadge(el.health, "warn", "TARGET UNREACHABLE");
  } else if (status === "not_configured") {
    setBadge(el.health, "warn", "TARGET NOT CONFIGURED");
  } else if (status === "skipped") {
    setBadge(el.health, "ok", "MOD BRAND CONNECTIVITY BY ADAPTER");
  } else {
    setBadge(el.health, "warn", "CONNECTIVITY UNKNOWN");
  }
  return status === "reachable";
}

async function applyFixtureRouteMode() {
  const id = String(el.standFixtureSelect.value || "").trim();
  const fixture = getFixtureById(id);
  if (!fixture) {
    setBadge(el.health, "warn", "SELECT FIXTURE");
    return;
  }

  const engineEnabled = getRouteChipState(el.standRouteEngine);
  const twitchEnabled = getRouteChipState(el.standRouteTwitch);
  let customEnabled = getRouteChipState(el.standRouteCustom);
  if (engineEnabled && customEnabled) {
    customEnabled = false;
    setRouteChipState(el.standRouteCustom, false);
  }
  if (!engineEnabled && !twitchEnabled && !customEnabled) {
    setBadge(el.health, "warn", "ENABLE AT LEAST ONE MODE");
    return;
  }

  const brand = String(fixture.brand || "").trim().toLowerCase();
  if (!isValidFixtureBrand(brand)) {
    setBadge(el.health, "bad", "INVALID FIXTURE BRAND");
    return;
  }

  const next = {
    ...fixture,
    controlMode: engineEnabled ? "engine" : "standalone",
    engineBinding: engineEnabled ? brand : "standalone",
    engineEnabled,
    twitchEnabled,
    customEnabled
  };

  setRouteDraftStateFromCurrentChips();
  const save = await postJson("/fixtures/fixture", next);
  if (!save.ok || !save.data?.ok) {
    setBadge(el.health, "bad", `ROUTING SAVE FAIL: ${save.data?.error || "invalid payload"}`);
    return;
  }

  ui.routeLastSavedAt = Date.now();
  setBadge(el.health, "ok", "ROUTING SAVED");

  const f = await getJson("/fixtures");
  clearRouteDraftState();
  if (f) updateFixtures(f);
}

async function applyStandaloneState() {
  const id = String(el.standFixtureSelect.value || "").trim();
  if (!id) {
    setBadge(el.health, "warn", "SELECT FIXTURE");
    return;
  }

  if (!getRouteChipState(el.standRouteCustom)) {
    setBadge(el.health, "warn", "CUSTOM MODE MUST BE ON");
    return;
  }

  const payload = {
    id,
    state: collectStandaloneStateFromControls()
  };
  const r = await postJson("/fixtures/standalone/state", payload);
  if (!r.ok || !r.data?.ok) {
    const errText = r.data?.error || "apply failed";
    setBadge(el.health, "bad", `STANDALONE APPLY FAIL: ${errText}`);
    return;
  }

  const returned = r.data.fixture || null;
  if (returned && returned.id) {
    const idx = ui.standaloneFixtures.findIndex(f => String(f.id) === String(returned.id));
    if (idx >= 0) ui.standaloneFixtures[idx] = returned;
    else ui.standaloneFixtures.push(returned);
    clearStandaloneDraftState();
    renderStandaloneFixtures(ui.standaloneFixtures, { preserveDraft: true });
    ui.standaloneSelectedId = String(returned.id);
    el.standFixtureSelect.value = ui.standaloneSelectedId;
    applyStandaloneEntryToControls(returned);
  }

  setBadge(el.health, "ok", "STANDALONE APPLIED");
}

el.apiBaseSaveBtn.onclick = async () => {
  const nextBase = normalizeApiBaseInput(el.apiBaseInput.value);
  setApiBase(nextBase);
  setBadge(el.health, "ok", nextBase ? "API BASE SAVED" : "API BASE CLEARED");
  await poll({ force: true });
};

el.apiBaseResetBtn.onclick = async () => {
  setApiBase(inferredApiBase);
  setBadge(el.health, "ok", "API BASE RESET");
  await poll({ force: true });
};

if (el.systemSettingsSaveBtn) {
  el.systemSettingsSaveBtn.onclick = async () => {
    const { pollingChanged } = saveSystemSettingsFromUi();
    const savedServer = await saveSystemServerSettingsFromUi();
    if (!savedServer.ok) {
      setBadge(el.health, "warn", `SYSTEM SETTINGS SAVED (SERVER CONFIG FAIL: ${savedServer.error || "request failed"})`);
    } else {
      setBadge(el.health, "ok", "SYSTEM SETTINGS SAVED");
    }
    if (!ui.pollPaused) {
      await poll({ force: true });
    } else if (pollingChanged) {
      renderSystemSettingsStatus();
    }
  };
}

if (el.systemSettingsResetBtn) {
  el.systemSettingsResetBtn.onclick = async () => {
    resetSystemSettingsToDefaults();
    const savedServer = await saveSystemServerSettingsFromUi();
    setBadge(
      el.health,
      savedServer.ok ? "ok" : "warn",
      savedServer.ok ? "SYSTEM SETTINGS RESET" : `SYSTEM RESET (SERVER CONFIG FAIL: ${savedServer.error || "request failed"})`
    );
    await poll({ force: true });
  };
}

if (el.systemPollNowBtn) {
  el.systemPollNowBtn.onclick = async () => {
    await poll({ force: true });
    setBadge(el.health, "ok", "MANUAL POLL COMPLETE");
  };
}

if (el.systemClearCacheBtn) {
  el.systemClearCacheBtn.onclick = async () => {
    const proceed = window.confirm("Clear UI local/session/cache memory and reload now?");
    if (!proceed) return;
    try {
      await clearUiLocalCache();
    } finally {
      window.location.reload();
    }
  };
}

if (el.tabsBar) {
  el.tabsBar.onclick = event => {
    const target = event.target instanceof Element ? event.target : null;
    if (!target) return;

    const modTabBtn = target.closest(".modUiDynamicTab");
    if (modTabBtn && el.tabsBar.contains(modTabBtn)) {
      const modId = normalizeModUiId(modTabBtn.dataset.modUiTabId);
      if (!modId) return;

      ui.modUiSelectedId = modId;
      localStorage.setItem(MOD_UI_SELECTED_KEY, modId);
      if (el.modUiSelect) el.modUiSelect.value = modId;
      syncModUiSelectionToHotswapTarget({ modId, force: true });
      showTab("mods");
      renderModUiFrame({ forceReload: true });
      return;
    }

    const tabBtn = target.closest("[data-tab-btn]");
    if (tabBtn && el.tabsBar.contains(tabBtn)) {
      showTab(tabBtn.dataset.tabBtn);
    }
  };
}

if (el.modUiSelect) {
  el.modUiSelect.onchange = () => {
    ui.modUiSelectedId = normalizeModUiId(el.modUiSelect.value);
    syncModUiSelectionToHotswapTarget({ force: true });
    if (ui.modUiSelectedId) {
      localStorage.setItem(MOD_UI_SELECTED_KEY, ui.modUiSelectedId);
    } else {
      localStorage.removeItem(MOD_UI_SELECTED_KEY);
    }
    renderModUiFrame({ forceReload: true });
  };
}

if (el.modUiRefreshBtn) {
  el.modUiRefreshBtn.onclick = async () => {
    const ok = await refreshModUiCatalog({ preferRemote: true, forceReload: true, persist: true });
    setBadge(el.health, ok ? "ok" : "bad", ok ? "MOD UI CATALOG REFRESHED" : "MOD UI CATALOG FAIL");
  };
}

if (el.modUiReloadBtn) {
  el.modUiReloadBtn.onclick = () => {
    renderModUiFrame({ forceReload: true });
    setBadge(el.health, "ok", "MOD UI FRAME RELOADED");
  };
}

if (el.modUiOpenBtn) {
  el.modUiOpenBtn.onclick = () => {
    const descriptor = getSelectedModUiDescriptor();
    if (!descriptor || !descriptor.loaded || !descriptor.url) {
      setBadge(el.health, "warn", "SELECT A LOADED MOD UI FIRST");
      return;
    }
    window.open(withBase(descriptor.url), "_blank", "noopener");
  };
}

if (el.moddingReadmeBtn) {
  el.moddingReadmeBtn.onclick = () => {
    const proceed = window.confirm(
      "You are about to open developer modding documentation in a separate page.\n\nContinue?"
    );
    if (!proceed) return;
    window.open(withBase("/modding-readme.html"), "_blank", "noopener");
  };
}

if (el.jumpRoutingLink) {
  el.jumpRoutingLink.onclick = event => {
    event.preventDefault();
    activateTabAndScroll("fixtures", "deviceRouting");
  };
}

el.jumpModsLink.onclick = event => {
  event.preventDefault();
  activateTabAndScroll("mods", "modCenter");
};

el.fxBrand.onchange = () => {
  const selectedBrand = resolveFixtureFormBrand("");
  const originalId = String(el.fxOriginalId?.value || "").trim();
  if (originalId) {
    const originalFixture = getFixtureById(originalId);
    const originalBrand = String(originalFixture?.brand || "").trim().toLowerCase();
    if (originalBrand && originalBrand !== selectedBrand) {
      if (String(el.fxId?.value || "").trim() === originalId) {
        el.fxId.value = "";
      }
      if (el.fxOriginalId) el.fxOriginalId.value = "";
    }
  }

  if (!el.fxZone.value.trim()) {
    el.fxZone.value = getCanonicalZoneForBrand(selectedBrand, "custom");
  }
  syncFixtureCouplingDefaults("brand");
  applyFixtureBrandVisibility();
};

if (el.fxModBrandId) {
  el.fxModBrandId.oninput = () => {
    el.fxModBrandId.value = String(el.fxModBrandId.value || "").toLowerCase().trim();
    syncFixtureCouplingDefaults("mod-brand");
    applyFixtureBrandVisibility();
  };
}

el.fxControlMode.onchange = () => {
  syncFixtureCouplingDefaults("mode");
};

el.fxEngineBinding.onchange = () => {
  updateFixtureCompatibilityHint();
};

el.fxResetBtn.onclick = () => {
  resetFixtureForm();
};

bindSensitiveFieldToggle(el.fxBridgeIp, el.fxBridgeIpShowBtn, "HUE BRIDGE IP");
bindSensitiveFieldToggle(el.fxUsername, el.fxUsernameShowBtn, "HUE USERNAME");
bindSensitiveFieldToggle(el.fxClientKey, el.fxClientKeyShowBtn, "HUE CLIENT KEY");
bindSensitiveFieldToggle(el.fxWizIp, el.fxWizIpShowBtn, "WIZ IP / MOD TARGET");

el.fxHueDiscoverBtn.onclick = async () => {
  if (el.fxBrand.value !== "hue") {
    el.fxBrand.value = "hue";
    applyFixtureBrandVisibility();
  }

  const areaCheck = ensureHueEntertainmentAreaSelection({
    forcePrompt: false,
    promptIfMissing: false,
    forceWhenBridgeConfigured: true
  });
  if (!areaCheck.ok) {
    setBadge(el.health, "warn", areaCheck.message || "ENT AREA REQUIRED");
    return;
  }

  await ensureHueEntGuideAcknowledged();

  const found = await discoverHueBridgeAndFill();
  if (!found.ok) {
    setBadge(el.health, "bad", "HUE DISCOVERY FAIL");
    return;
  }

  setBadge(
    el.health,
    "ok",
    found.bridge.id
      ? `HUE BRIDGE FOUND (${found.bridge.id})`
      : "HUE BRIDGE FOUND"
  );
};

el.fxHuePairBtn.onclick = async () => {
  if (el.fxBrand.value !== "hue") {
    el.fxBrand.value = "hue";
    applyFixtureBrandVisibility();
  }

  let bridgeIp = el.fxBridgeIp.value.trim();
  if (!bridgeIp) {
    const found = await discoverHueBridgeAndFill();
    if (!found.ok) {
      setBadge(el.health, "bad", "PAIR FAIL: NO BRIDGE");
      return;
    }
    bridgeIp = found.bridge.ip;
  }

  const areaCheck = ensureHueEntertainmentAreaSelection({
    forcePrompt: true,
    promptIfMissing: true,
    forceWhenBridgeConfigured: true
  });
  if (!areaCheck.ok) {
    setBadge(el.health, "warn", areaCheck.message || "ENT AREA REQUIRED");
    return;
  }

  if (!window.confirm(
    "Press the LINK button on your Hue Bridge now, then click OK to start pairing (about 30s timeout)."
  )) {
    return;
  }

  el.fxHueDiscoverBtn.disabled = true;
  el.fxHuePairBtn.disabled = true;
  if (el.fxHueSaveBridgeBtn) el.fxHueSaveBridgeBtn.disabled = true;
  setBadge(el.health, "warn", "PAIRING HUE: PRESS LINK BUTTON");

  const modeState = readFixtureModeFields();
  const fixtureHint = {
    id: el.fxId.value.trim(),
    zone: modeState.zone,
    enabled: el.fxEnabled.value === "true",
    engineEnabled: modeState.engineEnabled,
    twitchEnabled: modeState.twitchEnabled,
    customEnabled: modeState.customEnabled,
    lightId: Number(el.fxLightId.value || 1),
    entertainmentAreaId: el.fxEntertainmentAreaId.value.trim()
  };

  const pair = await postJson("/hue/pair", {
    bridgeIp,
    bridgeId: el.fxBridgeId.value.trim(),
    appName: "hue-bridge-final",
    timeoutMs: 30000,
    pollMs: 1200,
    lightId: fixtureHint.lightId,
    entertainmentAreaId: fixtureHint.entertainmentAreaId,
    saveFixture: true,
    fixture: fixtureHint
  });

  el.fxHueDiscoverBtn.disabled = false;
  el.fxHuePairBtn.disabled = false;
  if (el.fxHueSaveBridgeBtn) el.fxHueSaveBridgeBtn.disabled = false;

  if (!pair.ok || !pair.data?.ok) {
    const code = pair.data?.error || "pair_failed";
    if (code === "link_button_timeout") {
      setBadge(el.health, "warn", "PAIR TIMEOUT: PRESS LINK + RETRY");
    } else if (code === "missing_entertainment_area") {
      setBadge(el.health, "warn", "PAIR BLOCKED: SET ENT AREA");
    } else if (code === "invalid_bridge_ip") {
      setBadge(el.health, "bad", "PAIR FAIL: INVALID BRIDGE IP");
    } else {
      setBadge(el.health, "bad", "HUE PAIR FAIL");
    }
    return;
  }

  const bridge = pair.data.bridge || {};
  const creds = pair.data.credentials || {};
  const areas = Array.isArray(pair.data.entertainmentAreas) ? pair.data.entertainmentAreas : [];
  const pairedFixture = pair.data.fixture && typeof pair.data.fixture === "object"
    ? pair.data.fixture
    : null;
  const fixtureSavedByPair = pair.data.fixtureSaved === true && Boolean(pairedFixture);
  const fixtureSaveError = String(pair.data.fixtureSaveError || "").trim();

  if (bridge.ip) el.fxBridgeIp.value = String(bridge.ip).trim();
  if (bridge.id) el.fxBridgeId.value = String(bridge.id).trim().toUpperCase();
  if (creds.username) el.fxUsername.value = String(creds.username).trim();
  if (creds.clientKey) el.fxClientKey.value = String(creds.clientKey).trim().toUpperCase();
  if (pairedFixture?.id) el.fxId.value = String(pairedFixture.id).trim();
  if (pairedFixture?.id && el.fxOriginalId) el.fxOriginalId.value = String(pairedFixture.id).trim();
  if (pairedFixture?.zone && !el.fxZone.value.trim()) {
    el.fxZone.value = String(pairedFixture.zone).trim();
  }
  if (!el.fxEntertainmentAreaId.value.trim() && areas.length) {
    const first = areas[0] || {};
    el.fxEntertainmentAreaId.value = String(first.name || first.id || "").trim();
  }

  let saved = null;
  if (fixtureSavedByPair) {
    const catalogSeed = await getKnownFixtureCatalog();
    const localCatalog = upsertFixtureCatalogEntry(pairedFixture, { catalogSeed });
    applyFixtureCatalogToUi(localCatalog);
    const refreshed = await refreshFixturesFromServer({ attempts: 5 });
    saved = {
      ok: true,
      savedFixture: pairedFixture,
      refreshOk: refreshed.ok,
      routeSync: { ok: true, changed: false }
    };
  } else {
    saved = await saveFixtureFromForm({ resetAfter: false });
  }

  if (!saved.ok) {
    const detail = saved.error || fixtureSaveError || "fixture save failed";
    const msg = `HUE PAIRED (SAVE FAIL: ${detail})`;
    setBadge(el.health, pair.data.warning ? "warn" : "bad", msg);
    return;
  }

  if (saved.savedFixture?.id) {
    el.fxId.value = String(saved.savedFixture.id);
    if (el.fxOriginalId) el.fxOriginalId.value = String(saved.savedFixture.id).trim();
  }

  const routeSync = saved.routeSync || { ok: true, changed: false };
  if (!routeSync.ok) {
    setBadge(el.health, "warn", "HUE PAIRED + SAVED (ROUTE UPDATE FAIL)");
    return;
  }

  if (pair.data.warning) {
    setBadge(
      el.health,
      "warn",
      routeSync.changed
        ? "HUE PAIRED + SAVED + ROUTE (AREA WARN)"
        : "HUE PAIRED + SAVED (AREA WARN)"
    );
    return;
  }

  if (routeSync.changed) {
    setBadge(el.health, "ok", "HUE PAIRED + SAVED + ROUTE UPDATED");
  } else {
    setBadge(el.health, "ok", "HUE PAIRED + SAVED");
  }
};

if (el.fxHueSaveBridgeBtn) {
  el.fxHueSaveBridgeBtn.onclick = async () => {
    if (el.fxBrand.value !== "hue") {
      el.fxBrand.value = "hue";
      applyFixtureBrandVisibility();
    }

    const areaCheck = ensureHueEntertainmentAreaSelection({
      forcePrompt: false,
      promptIfMissing: true,
      forceWhenBridgeConfigured: true
    });
    if (!areaCheck.ok) {
      setBadge(el.health, "warn", areaCheck.message || "ENT AREA REQUIRED");
      return;
    }

    const saved = await saveFixtureFromForm({ resetAfter: false });
    if (!saved.ok) {
      setBadge(el.health, "bad", `BRIDGE EDIT SAVE FAIL: ${saved.error || "invalid payload"}`);
      return;
    }

    const routeSync = saved.routeSync || { ok: true, changed: false };
    if (!routeSync.ok) {
      setBadge(el.health, "warn", "BRIDGE EDITS SAVED (ROUTE UPDATE FAIL)");
      return;
    }

    if (routeSync.changed) {
      setBadge(el.health, "ok", "BRIDGE EDITS SAVED + ROUTE UPDATED");
    } else {
      setBadge(el.health, "ok", "BRIDGE EDITS SAVED");
    }
  };
}

el.fxSaveBtn.onclick = async () => {
  const saved = await saveFixtureFromForm({ resetAfter: true });
  if (!saved.ok) {
    setBadge(el.health, "bad", `FIXTURE SAVE FAIL: ${saved.error || "invalid payload"}`);
    return;
  }

  const routeSync = saved.routeSync || { ok: true, changed: false };
  if (routeSync.ok && routeSync.changed) {
    setBadge(el.health, "ok", "FIXTURE SAVED + ROUTE UPDATED");
  } else if (!routeSync.ok) {
    setBadge(el.health, "warn", "FIXTURE SAVED (ROUTE UPDATE FAIL)");
  } else {
    setBadge(el.health, "ok", "FIXTURE SAVED");
  }
};

el.standFixtureSelect.onchange = () => {
  syncRouteSelectionUi();
};

const onRouteToggleChange = (source = "") => {
  enforceRouteToggleConstraints({ source });
  setRouteDraftStateFromCurrentChips();
  const fixture = getFixtureById(el.standFixtureSelect.value);
  if (fixture) {
    renderRouteDraftStatus(fixture);
  }

  if (!getRouteChipState(el.standRouteCustom)) {
    applyStandaloneEntryToControls(null);
  }
};
el.standRouteEngine.onclick = () => {
  toggleRouteChip(el.standRouteEngine);
  onRouteToggleChange("engine");
};
el.standRouteTwitch.onclick = () => {
  toggleRouteChip(el.standRouteTwitch);
  onRouteToggleChange("twitch");
};
el.standRouteCustom.onclick = () => {
  toggleRouteChip(el.standRouteCustom);
  onRouteToggleChange("custom");
};

el.standRouteApplyBtn.onclick = async () => {
  await applyFixtureRouteMode();
};

el.standConnectivityBtn.onclick = async () => {
  await testFixtureConnectivity();
};

const refreshStandaloneDraftStatus = () => {
  const fixtureId = String(ui.standaloneSelectedId || "").trim();
  const fixture = getFixtureById(fixtureId);
  if (!fixture) return;
  const mode = normalizeStandaloneMode(el.standMode.value).toUpperCase();
  const scene = normalizeStandaloneScene(el.standScene.value).toUpperCase();
  const speedSource = normalizeStandaloneSpeedMode(el.standSpeedMode.value).toUpperCase();
  const staticWord = getStandaloneToggleState(el.standStaticBtn) ? "STATIC" : "LIVE";
  const startWord = getStandaloneToggleState(el.standRaveStartBtn) ? "START_EVT_ON" : "START_EVT_OFF";
  const stopWord = getStandaloneToggleState(el.standRaveStopBtn) ? "STOP_EVT_ON" : "STOP_EVT_OFF";
  const colorWord = normalizeStandaloneColorMode(el.standColorMode.value).toUpperCase();
  const brandKey = String(fixture.brand || "").trim().toLowerCase();
  const zone = String(
    fixture.zone ||
    (brandKey === "hue" ? "hue" : (brandKey === "wiz" ? "wiz" : "custom"))
  );
  el.standStatus.value =
    `${fixtureId} | ${String(fixture.brand || "").toUpperCase()} | zone ${zone} | ` +
    `mode ${mode} | scene ${scene} | ${speedSource} | ${colorWord} | ${staticWord} | ${startWord} | ${stopWord} | draft (press APPLY TO DEVICE)`;
};

function bindStandaloneDraftTracking() {
  const trackedNodes = [
    el.standPower,
    el.standMode,
    el.standScene,
    el.standSpeedMode,
    el.standSpeedHz,
    el.standSpeedMinHz,
    el.standSpeedMaxHz,
    el.standBrightness,
    el.standRaveStopBrightness,
    el.standHue,
    el.standHueMin,
    el.standHueMax,
    el.standSat,
    el.standSatMin,
    el.standSatMax,
    el.standColorMode,
    el.standCctKelvin,
    el.standCctMinKelvin,
    el.standCctMaxKelvin,
    el.standTransitionMs
  ];

  const onDraftChange = () => {
    markStandaloneDraftDirty();
  };

  for (const node of trackedNodes) {
    if (!node) continue;
    node.addEventListener("input", onDraftChange);
    node.addEventListener("change", onDraftChange);
  }
}

el.standBrightness.oninput = syncStandaloneValueLabels;
el.standRaveStopBrightness.oninput = syncStandaloneValueLabels;
el.standHue.oninput = syncStandaloneValueLabels;
el.standSat.oninput = syncStandaloneValueLabels;
el.standHueMin.oninput = () => {
  syncStandaloneValueLabels();
  syncStandaloneModeUi({ enabled: !el.standMode.disabled });
};
el.standHueMax.oninput = () => {
  syncStandaloneValueLabels();
  syncStandaloneModeUi({ enabled: !el.standMode.disabled });
};
el.standSatMin.oninput = () => {
  syncStandaloneValueLabels();
  syncStandaloneModeUi({ enabled: !el.standMode.disabled });
};
el.standSatMax.oninput = () => {
  syncStandaloneValueLabels();
  syncStandaloneModeUi({ enabled: !el.standMode.disabled });
};
el.standCctKelvin.oninput = syncStandaloneValueLabels;
el.standCctMinKelvin.oninput = () => {
  syncStandaloneValueLabels();
  syncStandaloneModeUi({ enabled: !el.standMode.disabled });
};
el.standCctMaxKelvin.oninput = () => {
  syncStandaloneValueLabels();
  syncStandaloneModeUi({ enabled: !el.standMode.disabled });
};
el.standSpeedMinHz.oninput = () => {
  syncStandaloneValueLabels();
  syncStandaloneModeUi({ enabled: !el.standMode.disabled });
};
el.standSpeedMaxHz.oninput = () => {
  syncStandaloneValueLabels();
  syncStandaloneModeUi({ enabled: !el.standMode.disabled });
};
el.standMode.onchange = () => {
  syncStandaloneModeUi({ enabled: !el.standMode.disabled });
  refreshStandaloneDraftStatus();
};
el.standScene.onchange = refreshStandaloneDraftStatus;
el.standSpeedMode.onchange = () => {
  syncStandaloneModeUi({ enabled: !el.standMode.disabled });
  refreshStandaloneDraftStatus();
};
el.standColorMode.onchange = () => {
  syncStandaloneModeUi({ enabled: !el.standMode.disabled });
  refreshStandaloneDraftStatus();
};
el.standStaticBtn.onclick = () => {
  const nextOn = !getStandaloneToggleState(el.standStaticBtn);
  setStandaloneToggleState(el.standStaticBtn, nextOn, { on: "STATIC ON", off: "STATIC OFF" });
  syncStandaloneModeUi({ enabled: !el.standMode.disabled });
  markStandaloneDraftDirty();
};
el.standRaveStartBtn.onclick = () => {
  const nextOn = !getStandaloneToggleState(el.standRaveStartBtn);
  setStandaloneToggleState(el.standRaveStartBtn, nextOn, { on: "RAVE-START UPDATE ON", off: "RAVE-START UPDATE OFF" });
  markStandaloneDraftDirty();
};
el.standRaveStopBtn.onclick = () => {
  const nextOn = !getStandaloneToggleState(el.standRaveStopBtn);
  setStandaloneToggleState(el.standRaveStopBtn, nextOn, { on: "RAVE-END UPDATE ON", off: "RAVE-END UPDATE OFF" });
  markStandaloneDraftDirty();
};

if (el.customFixtureSelect) {
  el.customFixtureSelect.onchange = () => {
    applyCustomFixtureSelectionFromTab({ notify: false });
  };
}

if (el.customFixtureSyncBtn) {
  el.customFixtureSyncBtn.onclick = () => {
    applyCustomFixtureSelectionFromTab({ notify: true });
  };
}

el.standApplyBtn.onclick = async () => {
  await applyStandaloneState();
};

el.standRefreshBtn.onclick = async () => {
  clearStandaloneDraftState();
  const f = await getJson("/fixtures");
  if (f) updateFixtures(f);
  const ok = await refreshStandaloneFixtures();
  setBadge(el.health, ok ? "ok" : "bad", ok ? "FIXTURE REFRESH" : "FIXTURE REFRESH FAIL");
};
bindStandaloneDraftTracking();

el.modsRefreshBtn.onclick = async () => {
  const ok = await loadMods();
  setBadge(el.health, ok ? "ok" : "bad", ok ? "MODS REFRESHED" : "MODS REFRESH FAIL");
};

el.modsReloadBtn.onclick = async () => {
  if (ui.modsDraftDirty) {
    const proceed = window.confirm(
      "You have queued mod hotswap changes that are not applied yet.\n\nContinue reload anyway?"
    );
    if (!proceed) return;
  }
  const r = await postJson("/mods/reload", {});
  if (!r.ok || !r.data || !r.data.ok) {
    setBadge(el.health, "bad", "MODS RELOAD FAIL");
    return;
  }
  ui.modsDraftDirty = false;
  ui.modsDraftConfig = cloneModConfig(r.data?.config || {});
  renderMods(r.data);
  setBadge(el.health, "ok", "MODS RELOADED");
};

if (el.modsDebugToggleBtn) {
  el.modsDebugToggleBtn.onclick = async () => {
    const next = !ui.modsDebugEnabled;
    const ok = await setModsDebugEnabled(next);
    setBadge(
      el.health,
      ok ? "ok" : "bad",
      ok
        ? (next ? "MOD DEBUG ENABLED" : "MOD DEBUG DISABLED")
        : "MOD DEBUG TOGGLE FAIL"
    );
  };
}

if (el.modsDebugClearBtn) {
  el.modsDebugClearBtn.onclick = async () => {
    const ok = await clearModsDebugBuffer();
    setBadge(el.health, ok ? "ok" : "bad", ok ? "MOD DEBUG BUFFER CLEARED" : "MOD DEBUG CLEAR FAIL");
  };
}

if (el.modImportBrowseBtn && el.modImportPicker) {
  el.modImportBrowseBtn.onclick = () => {
    el.modImportPicker.value = "";
    el.modImportPicker.click();
  };
}

if (el.modImportPicker) {
  el.modImportPicker.onchange = async () => {
    const descriptors = filesToImportDescriptors(el.modImportPicker.files || []);
    if (!descriptors.length) {
      setModImportStatus("No files selected.");
      return;
    }
    await importModFromDescriptors(descriptors, "folder picker");
  };
}

if (el.modDropZone) {
  const stopDefault = ev => {
    ev.preventDefault();
    ev.stopPropagation();
  };

  el.modDropZone.addEventListener("dragenter", ev => {
    stopDefault(ev);
    el.modDropZone.classList.add("dragOver");
  });
  el.modDropZone.addEventListener("dragover", ev => {
    stopDefault(ev);
    el.modDropZone.classList.add("dragOver");
  });
  el.modDropZone.addEventListener("dragleave", ev => {
    stopDefault(ev);
    el.modDropZone.classList.remove("dragOver");
  });
  el.modDropZone.addEventListener("drop", async ev => {
    stopDefault(ev);
    el.modDropZone.classList.remove("dragOver");
    const descriptors = await descriptorsFromDropEvent(ev);
    await importModFromDescriptors(descriptors, "drag/drop");
  });
}

el.modEnableBtn.onclick = enableModFromUi;
el.modDisableBtn.onclick = disableModFromUi;
el.modApplyBtn.onclick = applyModHotswapFromUi;
el.modDiscardBtn.onclick = discardModDraftFromUi;
el.modActionRunBtn.onclick = runModAction;

/* POWER */
el.onBtn.onclick = async () => {
  const ok = await api("/rave/on");
  ui.raveOn = ok;
  setBadge(el.health, ok ? "ok" : "bad", ok ? "RAVE ON" : "RAVE ON FAIL");
  sync();
};

el.offBtn.onclick = async () => {
  const ok = await api("/rave/off");
  if (ok) ui.raveOn = false;
  setBadge(el.health, ok ? "ok" : "bad", ok ? "RAVE OFF" : "RAVE OFF FAIL");
  sync();
};

el.panicBtn.onclick = async () => {
  if (shouldConfirmDangerousAction() && !window.confirm("Trigger PANIC blackout?")) return;
  await api("/rave/panic");
  ui.raveOn = false;
  sync();
};

/* ENGINE */
el.reloadBtn.onclick = async () => {
  if (shouldConfirmDangerousAction() && !window.confirm("Hot reload engine runtime now?")) return;
  const ok = await api("/rave/reload");
  setBadge(el.health, ok ? "ok" : "bad", ok ? "ENGINE RELOADED" : "RELOAD FAIL");
};
el.dropBtn.onclick = async () => {
  if (!ui.audioReactivityMap?.dropEnabled) {
    setBadge(el.health, "warn", "DROP DISABLED (AUDIO REACT MAP)");
    return;
  }
  const r = await postJson("/rave/drop", {});
  if (!r.ok || !r.data?.ok) {
    setBadge(el.health, "bad", "DROP HIT FAIL");
    return;
  }
  setBadge(el.health, "ok", "DROP HIT");
};
el.hueEntBtn.onclick = async () => {
  const r = await postJson("/hue/transport?mode=entertainment", {});
  if (!r.ok || !r.data) {
    setBadge(el.health, "bad", "HUE ENT FAIL");
    return;
  }

  if (r.data.active === "entertainment") {
    setBadge(el.health, "ok", "HUE ENTERTAINMENT");
  } else {
    setBadge(el.health, "warn", "HUE ENT FALLBACK");
  }
};
el.hueRestBtn.onclick = async () => {
  const r = await postJson("/hue/transport?mode=rest", {});
  setBadge(el.health, r.ok ? "ok" : "bad", r.ok ? "HUE REST" : "HUE REST FAIL");
};
el.serverStopBtn.onclick = async () => {
  if (shouldConfirmDangerousAction() && !window.confirm("Stop the local RaveLink server now?")) return;

  setBadge(el.health, "warn", "SERVER STOPPING...");
  const r = await postJson("/system/stop", {});
  if (!r.ok && r.status !== 0) {
    setBadge(el.health, "bad", "SERVER STOP FAIL");
    return;
  }

  setTimeout(() => {
    window.location.reload();
  }, 1800);
};
el.fixturesReloadBtn.onclick = async () => {
  const ok = await api("/fixtures/reload");
  setBadge(el.health, ok ? "ok" : "bad", ok ? "FIXTURES RELOADED" : "FIXTURES RELOAD FAIL");
  const f = await getJson("/fixtures");
  if (f) updateFixtures(f);
  await loadColorPrefixConfig();
};

el.colorPrefixSaveBtn.onclick = async () => {
  await saveColorPrefixConfigFromUi({ reset: false });
};

el.colorPrefixResetBtn.onclick = async () => {
  await saveColorPrefixConfigFromUi({ reset: true });
};

el.autoStartPercent.oninput = syncAutomationPercentLabels;
el.autoStopPercent.oninput = syncAutomationPercentLabels;
el.autoRulesEnabled.onchange = () => {
  syncAutomationControlAccessibility();
};

el.autoRulesSaveBtn.onclick = async () => {
  const patch = collectAutomationConfigFromInputs();
  const r = await postJson("/automation/config", patch);
  if (!r.ok || !r.data) {
    setBadge(el.health, "bad", "AUTO RULES SAVE FAIL");
    return;
  }

  applyAutomationConfigToInputs(r.data.config || patch, r.data.meta || {});
  setBadge(el.health, "ok", "AUTO RULES SAVED");
};

el.autoRulesReloadBtn.onclick = async () => {
  const r = await postJson("/automation/reload", {});
  if (!r.ok || !r.data) {
    setBadge(el.health, "bad", "AUTO RULES RELOAD FAIL");
    return;
  }

  applyAutomationConfigToInputs(r.data.config || {}, r.data.meta || {});
  setBadge(el.health, "ok", "AUTO RULES RELOADED");
};

el.autoRulesTestStartBtn.onclick = async () => {
  const r = await postJson("/automation/apply?event=start", {});
  if (!r.ok || !r.data) {
    setBadge(el.health, "bad", "AUTO START TEST FAIL");
    return;
  }
  const ok = Boolean(r.data.result?.ok);
  setBadge(el.health, ok ? "ok" : "warn", ok ? "AUTO START TEST OK" : "AUTO START TEST WARN");
};

el.autoRulesTestStopBtn.onclick = async () => {
  const r = await postJson("/automation/apply?event=stop", {});
  if (!r.ok || !r.data) {
    setBadge(el.health, "bad", "AUTO STOP TEST FAIL");
    return;
  }
  const ok = Boolean(r.data.result?.ok);
  setBadge(el.health, ok ? "ok" : "warn", ok ? "AUTO STOP TEST OK" : "AUTO STOP TEST WARN");
};

/* AUDIO CONTROL */
el.aDevices.onchange = () => {
  if (el.aDevices.value === "") {
    el.aDeviceId.value = "";
  } else {
    el.aDeviceId.value = el.aDevices.value;
  }
};

el.aSampleRate.onchange = () => {
  syncAudioQuickPresetButtons();
};

el.aFrames.onchange = () => {
  syncAudioQuickPresetButtons();
};

const audioQuickTuningSliderNodes = [
  el.aQuickGain,
  el.aQuickNoiseGate,
  el.aQuickAutoTarget,
  el.aQuickAutoGate,
  el.aQuickLimiter
];
for (const node of audioQuickTuningSliderNodes) {
  if (!node) continue;
  node.addEventListener("input", () => {
    applyAudioQuickTuningSlidersToInputs();
  });
  node.addEventListener("change", () => {
    applyAudioQuickTuningSlidersToInputs();
  });
}

if (el.aQuickProfileMix) {
  el.aQuickProfileMix.addEventListener("input", () => {
    applyAudioQuickProfileMixSliderToSliders();
  });
  el.aQuickProfileMix.addEventListener("change", () => {
    applyAudioQuickProfileMixSliderToSliders();
  });
}

if (el.aQuickSnapStages) {
  el.aQuickSnapStages.addEventListener("change", () => {
    applyAudioQuickTuningSlidersToInputs();
  });
}

if (el.aQuickTuneResetBtn) {
  el.aQuickTuneResetBtn.onclick = () => {
    resetAudioQuickTuningToDefaults();
    setBadge(el.health, "ok", "QUICK TUNING RESET");
  };
}

const audioQuickTuningNumericNodes = [
  el.aGain,
  el.aNoise,
  el.aAutoLevelTarget,
  el.aAutoLevelGate,
  el.aLimiterThreshold
];
for (const node of audioQuickTuningNumericNodes) {
  if (!node) continue;
  node.addEventListener("input", () => {
    syncAudioQuickTuningFromInputs();
  });
  node.addEventListener("change", () => {
    syncAudioQuickTuningFromInputs();
  });
}

if (el.aQuickTuneApplyBtn) {
  el.aQuickTuneApplyBtn.onclick = async () => {
    applyAudioQuickTuningSlidersToInputs();
    const patch = {
      outputGain: Number(el.aGain?.value || "1"),
      noiseFloorMin: Number(el.aNoise?.value || "0.00045"),
      autoLevelTargetRms: Number(el.aAutoLevelTarget?.value || "0.028"),
      autoLevelGate: Number(el.aAutoLevelGate?.value || "0.007"),
      limiterThreshold: Number(el.aLimiterThreshold?.value || "0.82")
    };
    const r = await postJson("/audio/config", patch);
    if (!r.ok) {
      setBadge(el.health, "bad", "QUICK TUNE APPLY FAIL");
      return;
    }
    if (r.data?.config) {
      applyAudioConfigToInputs(r.data.config);
    } else {
      syncAudioQuickTuningFromInputs();
    }
    setBadge(
      el.health,
      "ok",
      r.data?.restarted ? "QUICK TUNING APPLIED + RESTART" : "QUICK TUNING APPLIED"
    );
  };
}

bindAudioReactivityMapUi();

if (el.reactMapApplyBtn) {
  el.reactMapApplyBtn.onclick = async () => {
    const result = await saveAudioReactivityMap({ reset: false });
    if (!result.ok) {
      setBadge(el.health, "bad", "REACT MAP APPLY FAIL");
      return;
    }
    setBadge(el.health, "ok", "REACT MAP APPLIED");
    sync();
  };
}

if (el.reactMapResetBtn) {
  el.reactMapResetBtn.onclick = async () => {
    if (!window.confirm("Reset audio reactivity map to defaults?")) return;
    const result = await saveAudioReactivityMap({ reset: true });
    if (!result.ok) {
      setBadge(el.health, "bad", "REACT MAP RESET FAIL");
      return;
    }
    setBadge(el.health, "ok", "REACT MAP RESET");
    sync();
  };
}

audioQuickPresetButtons.forEach(btn => {
  btn.onclick = () => {
    const name = String(btn.dataset.audioQuick || "").trim().toLowerCase();
    const ok = applyAudioQuickProfile(name);
    if (!ok) return;
    setBadge(el.health, "ok", `AUDIO PROFILE ${name.toUpperCase()}`);
    sync();
  };
});

if (el.aIsoSimpleMode) {
  el.aIsoSimpleMode.checked = ui.audioSimpleRoutingMode !== false;
  el.aIsoSimpleMode.onchange = () => {
    ui.audioSimpleRoutingMode = el.aIsoSimpleMode.checked === true;
    localStorage.setItem(AUDIO_SIMPLE_MODE_KEY, ui.audioSimpleRoutingMode ? "1" : "0");
    syncAudioRoutingComplexityUi();
  };
}

if (el.aAppsShowAll) {
  el.aAppsShowAll.checked = ui.audioAppsShowAll === true;
  el.aAppsShowAll.onchange = () => {
    ui.audioAppsShowAll = el.aAppsShowAll.checked === true;
    localStorage.setItem(AUDIO_APPS_SHOW_ALL_KEY, ui.audioAppsShowAll ? "1" : "0");
    setAudioAppSelectOptions(el.aAppPrimary, el.aAppPrimary?.value || "");
    setAudioAppSelectOptions(el.aAppFallback, el.aAppFallback?.value || "");
    updateAudioAppsFilterHintUi();
  };
}

if (el.aOptionalToolsInfoBtn) {
  el.aOptionalToolsInfoBtn.onclick = () => {
    openAudioOptionalToolsHelp();
  };
}

if (el.aOptionalToolsDismissBtn) {
  el.aOptionalToolsDismissBtn.onclick = () => {
    ui.audioOptionalToolsDismissed = true;
    localStorage.setItem(AUDIO_OPTIONAL_TOOLS_DISMISS_KEY, "1");
    renderAudioOptionalToolsBanner();
  };
}

syncAudioRoutingComplexityUi();
updateAudioAppsFilterHintUi();
renderAudioOptionalToolsBanner();

el.aRefreshBtn.onclick = async () => {
  const [cfgOk, reactOk, appsOk, optionalOk] = await Promise.all([
    loadAudioConfig(),
    loadAudioReactivityMap(),
    loadAudioApps(),
    loadAudioOptionalToolsStatus()
  ]);
  const ok = cfgOk && reactOk && appsOk && optionalOk;
  setBadge(el.health, ok ? "ok" : "bad", ok ? "AUDIO CFG+REACT REFRESH" : "AUDIO REFRESH FAIL");
};

el.aScanBtn.onclick = async () => {
  const ok = await loadAudioDevices();
  setBadge(el.health, ok ? "ok" : "bad", ok ? "AUDIO DEVICES SCANNED" : "AUDIO SCAN FAIL");
};

if (el.aAppsRefreshBtn) {
  el.aAppsRefreshBtn.onclick = async () => {
    const ok = await loadAudioApps();
    setBadge(el.health, ok ? "ok" : "bad", ok ? "RUNNING APPS REFRESHED" : "RUNNING APPS REFRESH FAIL");
  };
}

if (el.liveAudioAppSearchBtn) {
  el.liveAudioAppSearchBtn.onclick = async () => {
    const ok = await forceAudioAppIsolationScan();
    setBadge(
      el.health,
      ok ? "ok" : "bad",
      ok ? "APP ISOLATION SEARCH APPLIED" : "APP ISOLATION SEARCH FAIL"
    );
  };
}

const audioAppIsolationAutoApplyNodes = [
  el.aInputBackend,
  el.aFfmpegFormat,
  el.aFfmpegDevice,
  el.aFfmpegSources,
  el.aAppIsolationEnabled,
  el.aAppIsolationMultiSource,
  el.aAppIsolationStrict,
  el.aAppIsolationCheckMs,
  el.aAppPrimary,
  el.aAppFallback,
  el.aAppPrimarySources,
  el.aAppFallbackSources
];
for (const node of audioAppIsolationAutoApplyNodes) {
  if (!node) continue;
  node.addEventListener("change", () => {
    queueAudioAppIsolationAutoApply("APP ISO");
  });
}

el.aApplyBtn.onclick = async () => {
  const patch = collectAudioConfigFromInputs();
  const r = await postJson("/audio/config", patch);
  if (!r.ok) {
    setBadge(el.health, "bad", "AUDIO APPLY FAIL");
    return;
  }

  if (r.data && r.data.config) {
    applyAudioConfigToInputs(r.data.config);
  }
  await loadAudioApps();

  setBadge(
    el.health,
    "ok",
    r.data && r.data.restarted ? "AUDIO CFG APPLIED + RESTART" : "AUDIO CFG APPLIED"
  );
};

el.aRestartBtn.onclick = async () => {
  const r = await api("/audio/restart");
  setBadge(el.health, r ? "ok" : "bad", r ? "AUDIO RESTART" : "AUDIO RESTART FAIL");
};

el.aResetDefaultsBtn.onclick = async () => {
  if (!window.confirm("Reset audio settings to defaults and apply now?")) return;

  const r = await postJson("/audio/config", AUDIO_CONFIG_DEFAULTS);
  if (!r.ok) {
    setBadge(el.health, "bad", "AUDIO RESET FAIL");
    return;
  }

  applyAudioConfigToInputs(r.data?.config || AUDIO_CONFIG_DEFAULTS);
  setBadge(
    el.health,
    "ok",
    r.data && r.data.restarted ? "AUDIO DEFAULTS APPLIED + RESTART" : "AUDIO DEFAULTS APPLIED"
  );
  sync();
};

limiterPresetButtons.forEach(btn => {
  btn.onclick = async () => {
    const presetName = btn.dataset.limiterPreset;
    const preset = LIMITER_PRESETS[presetName];
    if (!preset) return;

    const r = await postJson("/audio/config", preset);
    if (!r.ok) {
      setBadge(el.health, "bad", "LIMITER PRESET FAIL");
      return;
    }

    el.aLimiterThreshold.value = String(preset.limiterThreshold);
    el.aLimiterKnee.value = String(preset.limiterKnee);
    ui.limiterPreset = presetName;

    if (r.data && r.data.config) {
      applyAudioConfigToInputs(r.data.config);
    }

    setBadge(el.health, "ok", `LIMITER ${presetName.toUpperCase()}`);
    sync();
  };
});

/* MODE */
function applyModeUiPolicy() {
  ui.mode = "interpret";
  ui.modeLock = "interpret";
}

applyModeUiPolicy();

function applyMetaAutoTempoTrackersState(trackers = {}, options = {}) {
  const normalized = normalizeMetaAutoTempoTrackersUi(
    trackers,
    ui.metaAutoTempoTrackers || AUDIO_REACTIVITY_MAP_DEFAULT.metaAutoTempoTrackers
  );
  if (options && Object.prototype.hasOwnProperty.call(options, "autoEnabled")) {
    ui.metaAutoTempoTrackersAuto = options.autoEnabled === true;
  }
  ui.metaAutoTempoTrackers = { ...normalized };
  ui.metaAutoTempoTrackersActive = { ...normalized };
  ui.metaAutoHueWizBaselineBlend = normalized.baseline === true;
  if (ui.audioReactivityMap && typeof ui.audioReactivityMap === "object") {
    ui.audioReactivityMap.metaAutoTempoTrackersAuto = ui.metaAutoTempoTrackersAuto === true;
    ui.audioReactivityMap.metaAutoTempoTrackers = { ...normalized };
    ui.audioReactivityMap.metaAutoHueWizBaselineBlend = normalized.baseline === true;
  }
}

async function setMetaAutoTempoTracker(modeKey, enabled, options = {}) {
  const mode = String(modeKey || "").trim().toLowerCase();
  if (!META_AUTO_TEMPO_TRACKER_KEYS.includes(mode)) return false;
  const announce = options.announce !== false;
  const r = await postJson("/rave/meta/auto/hz-trackers", {
    mode,
    enabled: Boolean(enabled)
  });
  if (!r.ok || !r.data) {
    if (announce) setBadge(el.health, "bad", "META H/W TOGGLE FAIL");
    return false;
  }
  applyMetaAutoTempoTrackersState(r.data.trackers || {}, {
    autoEnabled: r.data.autoEnabled === true
  });
  refreshAudioReactivityMapStatus();
  if (announce) {
    const word = mode === "baseline"
      ? (ui.metaAutoHueWizBaselineBlend ? "BASE+DRUMS FACTOR ON" : "BASE+DRUMS FACTOR OFF")
      : `${mode.toUpperCase()} FACTOR ${ui.metaAutoTempoTrackers[mode] ? "ON" : "OFF"}`;
    setBadge(el.health, "ok", `META H/W ${word}`);
  }
  sync();
  return true;
}

async function setMetaAutoHueWizBaselineBlend(enabled, options = {}) {
  return setMetaAutoTempoTracker("baseline", enabled, options);
}

async function setMetaAutoTempoTrackerAuto(enabled, options = {}) {
  const announce = options.announce !== false;
  const r = await postJson("/rave/meta/auto/hz-trackers/auto", {
    enabled: Boolean(enabled)
  });
  if (!r.ok || !r.data) {
    if (announce) setBadge(el.health, "bad", "META H/W AUTO FAIL");
    return false;
  }
  const nextTrackers = r.data.trackers || ui.metaAutoTempoTrackers;
  applyMetaAutoTempoTrackersState(nextTrackers, {
    autoEnabled: r.data.enabled === true
  });
  refreshAudioReactivityMapStatus();
  if (announce) {
    if (r.data.enabled && r.data.seededCandidates) {
      setBadge(el.health, "ok", "META H/W DOMINANT AUTO ON + CANDIDATES");
    } else {
      setBadge(el.health, "ok", r.data.enabled ? "META H/W DOMINANT AUTO ON" : "META H/W DOMINANT AUTO OFF");
    }
  }
  sync();
  return true;
}

async function buildMetaAutoTempoTrackerCandidates(options = {}) {
  const announce = options.announce !== false;
  const force = options.force !== false;
  const r = await postJson("/rave/meta/auto/hz-trackers/candidates", {
    force: Boolean(force),
    autoEnabled: true
  });
  if (!r.ok || !r.data) {
    if (announce) setBadge(el.health, "bad", "META H/W CANDIDATES FAIL");
    return false;
  }
  applyMetaAutoTempoTrackersState(r.data.trackers || ui.metaAutoTempoTrackers, {
    autoEnabled: r.data.autoEnabled === true
  });
  refreshAudioReactivityMapStatus();
  if (announce) {
    setBadge(el.health, "ok", r.data.changed ? "META H/W CANDIDATES APPLIED" : "META H/W CANDIDATES READY");
  }
  sync();
  return true;
}

el.metaAutoOnBtn.onclick = async () => {
  const r = await postJson("/rave/meta/auto?enabled=true", {});
  if (!r.ok || !r.data) {
    setBadge(el.health, "bad", "META AUTO FAIL");
    return;
  }

  ui.metaAutoEnabled = Boolean(r.data.enabled);
  ui.metaAutoReason = "enabled";
  ui.overclockAutoEnabled = false;
  ui.overclockAutoReason = "meta-auto";
  maybeApplySmartLiveReactivityPolicy("META AUTO ON");
  setBadge(el.health, "ok", "META AUTO ON");
  sync();
};

el.metaAutoOffBtn.onclick = async () => {
  const r = await postJson("/rave/meta/auto?enabled=false", {});
  if (!r.ok || !r.data) {
    setBadge(el.health, "bad", "META AUTO FAIL");
    return;
  }

  ui.metaAutoEnabled = Boolean(r.data.enabled);
  ui.metaAutoReason = "off";
  maybeApplySmartLiveReactivityPolicy("META AUTO OFF");
  setBadge(el.health, "ok", "META AUTO OFF");
  sync();
};

if (el.metaAutoHueWizBaselineBlendBtn) {
  el.metaAutoHueWizBaselineBlendBtn.onclick = async () => {
    await setMetaAutoHueWizBaselineBlend(!ui.metaAutoHueWizBaselineBlend);
  };
}
if (el.metaAutoTrackerAutoBtn) {
  el.metaAutoTrackerAutoBtn.onclick = async () => {
    await setMetaAutoTempoTrackerAuto(!ui.metaAutoTempoTrackersAuto);
  };
}
if (el.metaAutoTrackerCandidatesBtn) {
  el.metaAutoTrackerCandidatesBtn.onclick = async () => {
    await buildMetaAutoTempoTrackerCandidates({ force: true });
  };
}
if (el.metaAutoTrackerPeaksBtn) {
  el.metaAutoTrackerPeaksBtn.onclick = async () => {
    await setMetaAutoTempoTracker("peaks", !ui.metaAutoTempoTrackers?.peaks);
  };
}
if (el.metaAutoTrackerTransientsBtn) {
  el.metaAutoTrackerTransientsBtn.onclick = async () => {
    await setMetaAutoTempoTracker("transients", !ui.metaAutoTempoTrackers?.transients);
  };
}
if (el.metaAutoTrackerFluxBtn) {
  el.metaAutoTrackerFluxBtn.onclick = async () => {
    await setMetaAutoTempoTracker("flux", !ui.metaAutoTempoTrackers?.flux);
  };
}

/* AUTO PROFILE */
autoProfileButtons.forEach(btn => {
  btn.onclick = async () => {
    const name = btn.dataset.autoProfile;
    const metaOk = await disableMetaAutoForManualOverride({ announce: false });
    if (!metaOk) return;

    const ok = await api(`/rave/auto/profile?name=${name}`);
    if (!ok) {
      setBadge(el.health, "bad", "AUTO PROFILE FAIL");
      return;
    }

    ui.autoProfile = name;
    maybeApplySmartLiveReactivityPolicy(`AUTO ${String(name || "").toUpperCase()}`);
    setBadge(el.health, "ok", `AUTO ${name.toUpperCase()}`);
    sync();
  };
});

/* AUDIO REACTIVITY */
audioReactivityButtons.forEach(btn => {
  btn.onclick = async () => {
    const name = btn.dataset.audioReactivity;
    const metaOk = await disableMetaAutoForManualOverride({ announce: false });
    if (!metaOk) return;

    const ok = await api(`/rave/audio/reactivity?name=${name}`);
    if (!ok) {
      setBadge(el.health, "bad", "AUDIO REACT FAIL");
      return;
    }

    ui.audioReactivityPreset = name;
    maybeApplySmartLiveReactivityPolicy(`A-REACT ${String(name || "").toUpperCase()}`);
    setBadge(el.health, "ok", `A-REACT ${name.toUpperCase()}`);
    sync();
  };
});

/* SCENE LOCK */
sceneButtons.forEach(btn => {
  btn.onclick = async () => {
    const scene = btn.dataset.scene;
    if (scene === "auto") {
      ui.sceneLock = "auto";
      await api("/rave/scene/auto");
    } else {
      ui.sceneLock = scene;
      await api(`/rave/scene?name=${scene}`);
    }
    maybeApplySmartLiveReactivityPolicy(`SCENE ${String(ui.sceneLock || "auto").toUpperCase()}`);
    sync();
  };
});

async function setSceneSyncMode(enabled) {
  const response = await postJson("/rave/scene/sync", { enabled: Boolean(enabled) });
  if (!response.ok || !response.data) {
    setBadge(el.health, "bad", "SCENE SYNC FAIL");
    return false;
  }

  ui.wizSceneSync = Boolean(response.data.enabled);
  ui.sceneSyncStrategy = String(response.data.strategy || ui.sceneSyncStrategy || "").trim().toLowerCase()
    || (ui.wizSceneSync ? "linked" : "standalone");
  const sceneSyncLabels = getSceneSyncLabelContext();
  const standalone = ui.sceneSyncStrategy === "standalone";
  setBadge(
    el.health,
    "ok",
    ui.wizSceneSync && !standalone
      ? sceneSyncLabels.badgeSynced
      : sceneSyncLabels.badgeDesynced
  );
  sync();
  return true;
}

if (el.sceneSyncOnBtn) {
  el.sceneSyncOnBtn.onclick = async () => {
    await setSceneSyncMode(true);
  };
}

if (el.sceneSyncOffBtn) {
  el.sceneSyncOffBtn.onclick = async () => {
    await setSceneSyncMode(false);
  };
}

/* OVERCLOCK */
async function setOverclockAutoEnabled(enabled, options = {}) {
  const announce = options.announce !== false;
  const action = enabled ? "on" : "off";
  const r = await postJson(`/rave/overclock/auto?enabled=${enabled ? "true" : "false"}`, {});
  if (!r.ok || !r.data) {
    if (announce) {
      setBadge(el.health, "bad", `AUTO HZ ${action.toUpperCase()} FAIL`);
    }
    return false;
  }

  ui.overclockAutoEnabled = Boolean(r.data.enabled);
  ui.overclockAutoReason = ui.overclockAutoEnabled ? "enabled" : "off";
  if (Number.isFinite(Number(r.data.hz))) {
    ui.overclockAutoHz = Number(r.data.hz);
  }
  if (Number.isFinite(Number(r.data.overclockLevel))) {
    ui.overclockLevel = Number(r.data.overclockLevel);
    ui.overclock = ui.overclockLevel > 0;
  }
  if (ui.overclockAutoEnabled) {
    ui.metaAutoEnabled = false;
    ui.metaAutoReason = "off";
  }

  if (announce) {
    const hzLabel = Number.isFinite(Number(ui.overclockAutoHz))
      ? ` ${Number(ui.overclockAutoHz).toFixed(1).replace(/\.0$/, "")}HZ`
      : "";
    setBadge(
      el.health,
      ui.overclockAutoEnabled ? "ok" : "warn",
      ui.overclockAutoEnabled ? `AUTO HZ ON${hzLabel}` : "AUTO HZ OFF"
    );
  }
  maybeApplySmartLiveReactivityPolicy(ui.overclockAutoEnabled ? "OC AUTO ON" : "OC AUTO OFF");
  sync();
  return true;
}

async function disableOverclockAutoForManualOverride(options = {}) {
  const announce = options.announce !== false;
  if (!ui.overclockAutoEnabled) return true;

  const ok = await setOverclockAutoEnabled(false, { announce: false });
  if (!ok) {
    setBadge(el.health, "bad", "AUTO HZ DISABLE FAIL");
    return false;
  }
  ui.overclockAutoReason = "manual";
  if (announce) {
    setBadge(el.health, "warn", "AUTO HZ OFF (MANUAL OVERRIDE)");
  }
  return true;
}

async function setOverclockPreset(level, route, label = "") {
  const overclockAutoOk = await disableOverclockAutoForManualOverride({ announce: false });
  if (!overclockAutoOk) return false;
  const metaOk = await disableMetaAutoForManualOverride({ announce: false });
  if (!metaOk) return false;

  const ok = await api(route);
  if (!ok) {
    setBadge(el.health, "bad", "OVERCLOCK FAIL");
    return false;
  }
  ui.overclockLevel = Number(level);
  ui.overclock = ui.overclockLevel > 0;
  if (label) {
    setBadge(el.health, "ok", label);
  }
  maybeApplySmartLiveReactivityPolicy(label || "OVERCLOCK");
  sync();
  return true;
}

async function disableMetaAutoForManualOverride(options = {}) {
  const announce = options.announce !== false;
  if (!ui.metaAutoEnabled) return true;

  const r = await postJson("/rave/meta/auto?enabled=false", {});
  if (!r.ok || !r.data) {
    setBadge(el.health, "bad", "META AUTO DISABLE FAIL");
    return false;
  }
  ui.metaAutoEnabled = false;
  ui.metaAutoReason = "off";
  if (announce) {
    setBadge(el.health, "warn", "META AUTO OFF (MANUAL OVERRIDE)");
  }
  return true;
}

async function confirmUnsafeDevOverclock(hz) {
  if (!ui.devOverclockComicalAcked) {
    const step1 = window.confirm(
      `Unsafe DEV ${hz}Hz overclock requested.\n\nAre you sure?`
    );
    if (!step1) return false;
    const step2 = window.confirm("Really really sure?");
    if (!step2) return false;
    const step3 = window.confirm("Really really sure?");
    if (!step3) return false;

    const acked = await openDevOverclockAckGate(hz);
    if (!acked) return false;
    ui.devOverclockComicalAcked = true;
    localStorage.setItem(DEV_OVERCLOCK_COMICAL_ACK_KEY, "1");
    return true;
  }

  window.alert(
    "Warning: 20Hz and above is aggressive and destructive.\n\n" +
    "Behavior can become unstable or unpredictable."
  );
  return true;
}

async function setUnsafeDevOverclock(hz) {
  const parsedHz = Number(hz);
  const level = DEV_OVERCLOCK_LEVEL_BY_HZ[parsedHz];
  if (!Number.isFinite(parsedHz) || !Number.isFinite(level)) {
    setBadge(el.health, "bad", "INVALID DEV OVERCLOCK");
    return false;
  }
  if (!ui.devDebugMode) {
    setBadge(el.health, "warn", "ENABLE DEV DEBUG IN SETTINGS COG");
    return false;
  }
  if (!(await confirmUnsafeDevOverclock(parsedHz))) {
    setBadge(el.health, "warn", "DEV OVERCLOCK CANCELED");
    return false;
  }
  const overclockAutoOk = await disableOverclockAutoForManualOverride();
  if (!overclockAutoOk) return false;
  const metaOk = await disableMetaAutoForManualOverride();
  if (!metaOk) return false;

  const r = await postJson(`/rave/overclock/dev/${parsedHz}/on?unsafe=true`, { unsafe: true });
  if (!r.ok || !r.data || !r.data.ok) {
    const reason = r.data?.error ? `: ${r.data.error}` : "";
    setBadge(el.health, "bad", `DEV OVERCLOCK FAIL${reason}`);
    return false;
  }

  ui.overclockLevel = Number(level);
  ui.overclock = true;
  maybeApplySmartLiveReactivityPolicy(`DEV ${parsedHz}HZ`);
  setBadge(el.health, "warn", `DEV ${parsedHz}HZ ARMED`);
  sync();
  return true;
}

el.ocLudicrousBtn.onclick = () => setOverclockPreset(7, "/rave/overclock/ludicrous/on", "OC 16HZ");
el.ocHyperBtn.onclick = () => setOverclockPreset(6, "/rave/overclock/hyper/on", "OC 14HZ");
el.ocInsaneBtn.onclick = () => setOverclockPreset(5, "/rave/overclock/insane/on", "OC 12HZ");
el.ocExtremeBtn.onclick = () => setOverclockPreset(4, "/rave/overclock/extreme/on", "OC 10HZ");
el.ocUltraBtn.onclick = () => setOverclockPreset(3, "/rave/overclock/ultra/on", "OC 8HZ");
el.ocTurboBtn.onclick = () => setOverclockPreset(2, "/rave/overclock/turbo/on", "OC 6HZ");
el.ocOnBtn.onclick = () => setOverclockPreset(1, "/rave/overclock/on", "OC 4HZ");
el.ocOffBtn.onclick = () => setOverclockPreset(0, "/rave/overclock/off", "OC 2HZ");
if (el.ocAutoBtn) {
  el.ocAutoBtn.onclick = async () => {
    await setOverclockAutoEnabled(!ui.overclockAutoEnabled);
  };
}

if (el.ocDev20Btn) el.ocDev20Btn.onclick = () => setUnsafeDevOverclock(20);
if (el.ocDev30Btn) el.ocDev30Btn.onclick = () => setUnsafeDevOverclock(30);
if (el.ocDev40Btn) el.ocDev40Btn.onclick = () => setUnsafeDevOverclock(40);
if (el.ocDev50Btn) el.ocDev50Btn.onclick = () => setUnsafeDevOverclock(50);
if (el.ocDev60Btn) el.ocDev60Btn.onclick = () => setUnsafeDevOverclock(60);

/* MANUAL PALETTE SEQUENCER */
async function applyPalettePatch(patch = {}, badgePrefix = "PALETTE") {
  const r = await postJson("/rave/palette", patch);
  if (!r.ok || !r.data || !r.data.ok) {
    const reason = r.data?.error ? `: ${r.data.error}` : "";
    setBadge(el.health, "bad", `${badgePrefix} FAIL${reason}`);
    return false;
  }
  applyPaletteRuntimeSnapshotToUi(r.data || {}, { forceRender: true });
  maybeApplySmartLiveReactivityPolicy(`${badgePrefix} UPDATE`);
  sync();
  return true;
}

async function applyFixtureMetricPatch(patch = {}, badgePrefix = "FIXTURE METRIC") {
  const r = await postJson("/rave/fixture-metrics", patch);
  if (!r.ok || !r.data || !r.data.ok) {
    const reason = r.data?.error ? `: ${r.data.error}` : "";
    setBadge(el.health, "bad", `${badgePrefix} FAIL${reason}`);
    return false;
  }
  applyFixtureMetricRoutingSnapshotToUi(r.data || {});
  if (r.data?.brandFixtures && typeof r.data.brandFixtures === "object") {
    ui.paletteBrandFixtures = {
      hue: Array.isArray(r.data.brandFixtures.hue) ? r.data.brandFixtures.hue.slice() : [],
      wiz: Array.isArray(r.data.brandFixtures.wiz) ? r.data.brandFixtures.wiz.slice() : []
    };
  }
  renderPaletteBrandMenus({ force: true, reason: "fixture_metric_patch" });
  sync();
  return true;
}

async function applyFixtureRoutingClearPatch(patch = {}, badgePrefix = "OVERRIDE") {
  const r = await postJson("/rave/fixture-routing/clear", patch);
  if (!r.ok || !r.data || !r.data.ok) {
    const reason = r.data?.error ? `: ${r.data.error}` : "";
    setBadge(el.health, "bad", `${badgePrefix} FAIL${reason}`);
    return false;
  }
  applyPaletteRuntimeSnapshotToUi(r.data || {}, { forceRender: true });
  maybeApplySmartLiveReactivityPolicy(`${badgePrefix} UPDATE`);
  sync();
  return true;
}

function syncPaletteDisorderAggressionSliderUi() {
  const pct = Math.round(normalizePaletteDisorderAggressionUi(ui.paletteDisorderAggression, 0.35) * 100);
  if (el.paletteDisorderAggression) el.paletteDisorderAggression.value = String(pct);
  if (el.paletteDisorderAggressionVal) el.paletteDisorderAggressionVal.textContent = `${pct}%`;
}

function isPaletteGlobalScopeActiveUi() {
  return normalizePaletteControlScopeUi(ui.paletteControlScope, "global") === "global";
}

function formatPaletteCycleModeLabelUi(mode) {
  const key = normalizePaletteCycleModeUi(mode, "on_trigger");
  return PALETTE_CYCLE_MODE_LABELS[key] || key.toUpperCase();
}

function formatPaletteBrightnessModeLabelUi(mode) {
  const key = normalizePaletteBrightnessModeUi(mode, "legacy");
  return PALETTE_BRIGHTNESS_MODE_LABELS[key] || key.toUpperCase();
}

function formatPaletteVividnessLabelUi(level) {
  const key = normalizePaletteVividnessUi(level, 2);
  return PALETTE_VIVIDNESS_LABELS[key] || String(key);
}

function describePaletteCycleModeUi(mode) {
  const key = normalizePaletteCycleModeUi(mode, "on_trigger");
  if (key === "timed_cycle") {
    return "Cycles to the next palette group on timer and keeps moving colors inside the active group.";
  }
  if (key === "reactive_shift") {
    return "Cycles to the next palette group when song progression shifts enough; colors continue moving inside the active group.";
  }
  if (key === "spectrum_mapper") {
    return "Chooses active palette group from mapped audio features; colors continue moving inside that selected group.";
  }
  return "Cycles to the next palette group on beat/drop triggers while colors continue moving inside the active group.";
}

function setPaletteGlobalModeNoticeUi(message = "", options = {}) {
  const next = String(message || "").trim();
  ui.paletteGlobalModeNotice = next;
  if (paletteGlobalModeNoticeTimer) {
    clearTimeout(paletteGlobalModeNoticeTimer);
    paletteGlobalModeNoticeTimer = null;
  }
  const ttlMs = Number(options.ttlMs);
  if (next && Number.isFinite(ttlMs) && ttlMs > 0) {
    paletteGlobalModeNoticeTimer = setTimeout(() => {
      ui.paletteGlobalModeNotice = "";
      if (el.paletteModeNotice) el.paletteModeNotice.textContent = "";
      sync();
    }, ttlMs);
  }
  if (options.syncNow !== false) {
    sync();
  }
}

function setPaletteBrandModeNoticeUi(brand, message = "", options = {}) {
  const brandKey = normalizePaletteBrandUi(brand);
  if (!brandKey) return;
  const next = String(message || "").trim();
  if (!ui.paletteBrandModeNotices || typeof ui.paletteBrandModeNotices !== "object") {
    ui.paletteBrandModeNotices = { hue: "", wiz: "" };
  }
  ui.paletteBrandModeNotices[brandKey] = next;
  const existingTimer = paletteBrandModeNoticeTimers[brandKey];
  if (existingTimer) {
    clearTimeout(existingTimer);
    paletteBrandModeNoticeTimers[brandKey] = null;
  }
  const ttlMs = Number(options.ttlMs);
  if (next && Number.isFinite(ttlMs) && ttlMs > 0) {
    paletteBrandModeNoticeTimers[brandKey] = setTimeout(() => {
      if (!ui.paletteBrandModeNotices || typeof ui.paletteBrandModeNotices !== "object") return;
      ui.paletteBrandModeNotices[brandKey] = "";
      renderPaletteBrandMenus({ reason: "palette_brand_notice_timeout" });
      sync();
    }, ttlMs);
  }
  if (options.syncNow !== false) {
    renderPaletteBrandMenus({ reason: "palette_brand_notice_update" });
    sync();
  }
}

function setPaletteControlScopeUi(scope, options = {}) {
  const next = normalizePaletteControlScopeUi(scope, ui.paletteControlScope);
  const changed = next !== ui.paletteControlScope;
  ui.paletteControlScope = next;
  if (next === "custom") {
    ui.paletteCustomBrand = normalizePaletteCustomBrandMemoryUi(ui.paletteCustomBrand, "hue");
  }
  if (changed || options.forceRender === true) {
    renderPaletteBrandMenus({ force: true, reason: "palette_scope_change" });
  }
  if (options.sync !== false) {
    sync();
  }
}

function setPaletteCustomBrandUi(brand, options = {}) {
  const next = normalizePaletteCustomBrandMemoryUi(brand, ui.paletteCustomBrand);
  const changed = next !== ui.paletteCustomBrand;
  ui.paletteCustomBrand = next;
  if (changed || options.forceRender === true) {
    renderPaletteBrandMenus({ force: true, reason: "palette_custom_brand_change" });
  }
  if (options.sync !== false) {
    sync();
  }
}

function syncPaletteTimedIntervalSliderUi() {
  const sec = normalizePaletteTimedIntervalSecUi(ui.paletteTimedIntervalSec, 5);
  ui.paletteTimedIntervalSec = sec;
  if (el.paletteTimedIntervalSec) el.paletteTimedIntervalSec.value = String(sec);
  if (el.paletteTimedIntervalSecVal) el.paletteTimedIntervalSecVal.textContent = `${sec}s`;
}

function syncPaletteBeatLockGraceSliderUi() {
  const sec = normalizePaletteBeatLockGraceSecUi(ui.paletteBeatLockGraceSec, 2);
  ui.paletteBeatLockGraceSec = sec;
  if (el.paletteBeatLockGraceSec) el.paletteBeatLockGraceSec.value = String(sec);
  if (el.paletteBeatLockGraceSecVal) el.paletteBeatLockGraceSecVal.textContent = `+${sec}s`;
}

function syncPaletteReactiveMarginSliderUi() {
  const margin = normalizePaletteReactiveMarginUi(ui.paletteReactiveMargin, 28);
  ui.paletteReactiveMargin = margin;
  if (el.paletteReactiveMargin) el.paletteReactiveMargin.value = String(margin);
  if (el.paletteReactiveMarginVal) el.paletteReactiveMarginVal.textContent = String(margin);
}

function formatPaletteBrightnessFollowAmountUi(value = 1) {
  const amount = normalizePaletteBrightnessFollowAmountUi(value, 1);
  return `${amount.toFixed(2)}x`;
}

function syncPaletteBrightnessFollowSliderUi() {
  const amount = normalizePaletteBrightnessFollowAmountUi(ui.paletteBrightnessFollowAmount, 1);
  ui.paletteBrightnessFollowAmount = amount;
  const pct = Math.round(amount * 100);
  if (el.paletteBrightnessFollowAmount) el.paletteBrightnessFollowAmount.value = String(pct);
  if (el.paletteBrightnessFollowAmountVal) {
    el.paletteBrightnessFollowAmountVal.textContent = formatPaletteBrightnessFollowAmountUi(amount);
  }
}

function collectPaletteSpectrumFeatureMapFromSelectorsUi(selectors = getPaletteSpectrumFeatureSelectors()) {
  const next = [];
  const nodes = Array.isArray(selectors) ? selectors : [];
  for (let i = 0; i < 5; i += 1) {
    const node = nodes[i];
    next.push(
      normalizePaletteAudioFeatureUi(
        node?.value,
        PALETTE_DEFAULT_SPECTRUM_FEATURE_MAP[i % PALETTE_DEFAULT_SPECTRUM_FEATURE_MAP.length]
      )
    );
  }
  return next;
}

function syncPaletteSpectrumFeatureSelectorsUi() {
  ui.paletteSpectrumFeatureMap = normalizePaletteSpectrumFeatureMapUi(
    ui.paletteSpectrumFeatureMap,
    PALETTE_DEFAULT_SPECTRUM_FEATURE_MAP
  );
  const selectors = getPaletteSpectrumFeatureSelectors();
  const manualMode = normalizePaletteSpectrumMapModeUi(ui.paletteSpectrumMapMode, "auto") === "manual";
  selectors.forEach((node, idx) => {
    if (!node) return;
    const value = ui.paletteSpectrumFeatureMap[idx % ui.paletteSpectrumFeatureMap.length];
    if (node.value !== value) node.value = value;
    node.disabled = !manualMode;
  });
}

if (el.paletteScopeGlobalBtn) {
  el.paletteScopeGlobalBtn.onclick = () => {
    setPaletteControlScopeUi("global");
  };
}

if (el.paletteScopeCustomBtn) {
  el.paletteScopeCustomBtn.onclick = () => {
    setPaletteControlScopeUi("custom");
  };
}

paletteCustomBrandButtons.forEach(btn => {
  btn.onclick = () => {
    setPaletteCustomBrandUi(btn.dataset.paletteCustomBrand);
  };
});

paletteCycleModeButtons.forEach(btn => {
  btn.onclick = async () => {
    if (!isPaletteGlobalScopeActiveUi()) return;
    const nextMode = normalizePaletteCycleModeUi(btn.dataset.paletteCycleMode, ui.paletteCycleMode || "on_trigger");
    const previousMode = normalizePaletteCycleModeUi(ui.paletteCycleMode, "on_trigger");
    const ok = await applyPalettePatch({ cycleMode: nextMode }, "PALETTE MODE");
    if (ok) {
      if (nextMode !== previousMode) {
        setPaletteGlobalModeNoticeUi(
          `${formatPaletteCycleModeLabelUi(nextMode)} active. ${formatPaletteCycleModeLabelUi(previousMode)} was replaced. ${describePaletteCycleModeUi(nextMode)}`,
          { ttlMs: 3600 }
        );
      }
      setBadge(el.health, "ok", `PALETTE MODE ${formatPaletteCycleModeLabelUi(nextMode)}`);
    }
  };
});

paletteBeatLockButtons.forEach(btn => {
  btn.onclick = async () => {
    if (!isPaletteGlobalScopeActiveUi()) return;
    const enabled = String(btn.dataset.paletteBeatLock || "").trim().toLowerCase() === "true";
    const ok = await applyPalettePatch({ beatLock: enabled }, "PALETTE BEAT LOCK");
    if (ok) {
      setBadge(el.health, "ok", `PALETTE BEAT LOCK ${enabled ? "ON" : "OFF"}`);
    }
  };
});

paletteBrightnessModeButtons.forEach(btn => {
  btn.onclick = async () => {
    if (!isPaletteGlobalScopeActiveUi()) return;
    const mode = normalizePaletteBrightnessModeUi(btn.dataset.paletteBrightnessMode, ui.paletteBrightnessMode || "legacy");
    const ok = await applyPalettePatch({ brightnessMode: mode }, "PALETTE BRIGHTNESS");
    if (ok) {
      setBadge(el.health, "ok", `PALETTE BRIGHTNESS ${formatPaletteBrightnessModeLabelUi(mode)}`);
    }
  };
});

paletteSpectrumModeButtons.forEach(btn => {
  btn.onclick = async () => {
    if (!isPaletteGlobalScopeActiveUi()) return;
    const mode = normalizePaletteSpectrumMapModeUi(btn.dataset.paletteSpectrumMode, ui.paletteSpectrumMapMode || "auto");
    const ok = await applyPalettePatch({ spectrumMapMode: mode }, "PALETTE SPECTRUM");
    if (ok) {
      setBadge(el.health, "ok", `PALETTE SPECTRUM ${mode === "manual" ? "MANUAL" : "AUTO"}`);
    }
  };
});

if (el.paletteBrightnessFollowAmount) {
  el.paletteBrightnessFollowAmount.oninput = () => {
    ui.paletteBrightnessFollowAmount = normalizePaletteBrightnessFollowAmountUi(
      Number(el.paletteBrightnessFollowAmount.value) / 100,
      ui.paletteBrightnessFollowAmount ?? 1
    );
    syncPaletteBrightnessFollowSliderUi();
  };
  el.paletteBrightnessFollowAmount.onchange = async () => {
    if (!isPaletteGlobalScopeActiveUi()) return;
    if (normalizePaletteBrightnessModeUi(ui.paletteBrightnessMode, "legacy") !== "test") return;
    const amount = normalizePaletteBrightnessFollowAmountUi(
      Number(el.paletteBrightnessFollowAmount.value) / 100,
      ui.paletteBrightnessFollowAmount ?? 1
    );
    ui.paletteBrightnessFollowAmount = amount;
    syncPaletteBrightnessFollowSliderUi();
    const ok = await applyPalettePatch({ brightnessFollowAmount: amount }, "PALETTE BRIGHTNESS");
    if (ok) {
      setBadge(el.health, "ok", `PALETTE FOLLOW ${formatPaletteBrightnessFollowAmountUi(amount)}`);
    }
  };
}

if (el.paletteTimedIntervalSec) {
  el.paletteTimedIntervalSec.oninput = () => {
    ui.paletteTimedIntervalSec = normalizePaletteTimedIntervalSecUi(
      el.paletteTimedIntervalSec.value,
      ui.paletteTimedIntervalSec || 5
    );
    syncPaletteTimedIntervalSliderUi();
  };
  el.paletteTimedIntervalSec.onchange = async () => {
    if (!isPaletteGlobalScopeActiveUi()) return;
    const intervalSec = normalizePaletteTimedIntervalSecUi(
      el.paletteTimedIntervalSec.value,
      ui.paletteTimedIntervalSec || 5
    );
    ui.paletteTimedIntervalSec = intervalSec;
    syncPaletteTimedIntervalSliderUi();
    const ok = await applyPalettePatch({ timedIntervalSec: intervalSec }, "PALETTE TIMER");
    if (ok) {
      setBadge(el.health, "ok", `PALETTE TIMER ${intervalSec}s`);
    }
  };
}

if (el.paletteBeatLockGraceSec) {
  el.paletteBeatLockGraceSec.oninput = () => {
    ui.paletteBeatLockGraceSec = normalizePaletteBeatLockGraceSecUi(
      el.paletteBeatLockGraceSec.value,
      ui.paletteBeatLockGraceSec || 2
    );
    syncPaletteBeatLockGraceSliderUi();
  };
  el.paletteBeatLockGraceSec.onchange = async () => {
    if (!isPaletteGlobalScopeActiveUi()) return;
    const graceSec = normalizePaletteBeatLockGraceSecUi(
      el.paletteBeatLockGraceSec.value,
      ui.paletteBeatLockGraceSec || 2
    );
    ui.paletteBeatLockGraceSec = graceSec;
    syncPaletteBeatLockGraceSliderUi();
    const ok = await applyPalettePatch({ beatLockGraceSec: graceSec }, "PALETTE BEAT LOCK");
    if (ok) {
      setBadge(el.health, "ok", `PALETTE BEAT LOCK +${graceSec}s`);
    }
  };
}

if (el.paletteReactiveMargin) {
  el.paletteReactiveMargin.oninput = () => {
    ui.paletteReactiveMargin = normalizePaletteReactiveMarginUi(
      el.paletteReactiveMargin.value,
      ui.paletteReactiveMargin || 28
    );
    syncPaletteReactiveMarginSliderUi();
  };
  el.paletteReactiveMargin.onchange = async () => {
    if (!isPaletteGlobalScopeActiveUi()) return;
    const margin = normalizePaletteReactiveMarginUi(
      el.paletteReactiveMargin.value,
      ui.paletteReactiveMargin || 28
    );
    ui.paletteReactiveMargin = margin;
    syncPaletteReactiveMarginSliderUi();
    const ok = await applyPalettePatch({ reactiveMargin: margin }, "PALETTE REACTIVE");
    if (ok) {
      setBadge(el.health, "ok", `PALETTE REACTIVE MARGIN ${margin}`);
    }
  };
}

getPaletteSpectrumFeatureSelectors().forEach(node => {
  node.onchange = async () => {
    if (!isPaletteGlobalScopeActiveUi()) return;
    const nextMap = collectPaletteSpectrumFeatureMapFromSelectorsUi();
    ui.paletteSpectrumFeatureMap = nextMap.slice();
    syncPaletteSpectrumFeatureSelectorsUi();
    const ok = await applyPalettePatch({ spectrumFeatureMap: nextMap }, "PALETTE SPECTRUM");
    if (ok) {
      setBadge(el.health, "ok", "PALETTE SPECTRUM MAP UPDATED");
    }
  };
});

paletteCountButtons.forEach(btn => {
  btn.onclick = async () => {
    if (!isPaletteGlobalScopeActiveUi()) return;
    const count = normalizePaletteColorCountUi(btn.dataset.paletteCount, ui.paletteColorsPerFamily || 3);
    const ok = await applyPalettePatch({ colorsPerFamily: count }, "PALETTE COUNT");
    if (ok) {
      setBadge(el.health, "ok", `PALETTE COUNT ${count}`);
    }
  };
});

paletteVividnessButtons.forEach(btn => {
  btn.onclick = async () => {
    if (!isPaletteGlobalScopeActiveUi()) return;
    const level = normalizePaletteVividnessUi(btn.dataset.paletteVividness, ui.paletteVividness || 2);
    const ok = await applyPalettePatch({ vividness: level }, "PALETTE VIVIDNESS");
    if (ok) {
      setBadge(el.health, "ok", `PALETTE VIVIDNESS ${formatPaletteVividnessLabelUi(level)}`);
    }
  };
});

palettePresetButtons.forEach(btn => {
  btn.onclick = async () => {
    if (!isPaletteGlobalScopeActiveUi()) return;
    const key = String(btn.dataset.palettePreset || "").trim().toLowerCase();
    const preset = PALETTE_PRESETS[key];
    if (!preset) return;
    const patch = {
      families: preset.families.slice()
    };
    if (Number.isFinite(Number(preset.colorsPerFamily))) {
      patch.colorsPerFamily = Number(preset.colorsPerFamily);
    }
    const ok = await applyPalettePatch(patch, "PALETTE PRESET");
    if (ok) {
      const countText = Number.isFinite(Number(preset.colorsPerFamily))
        ? `x${Number(preset.colorsPerFamily)}`
        : `x${normalizePaletteColorCountUi(ui.paletteColorsPerFamily, 3)}`;
      setBadge(el.health, "ok", `PRESET ${String(preset.label || key).toUpperCase()} ${countText}`);
    }
  };
});

if (el.paletteFamilyGrid) {
  el.paletteFamilyGrid.onclick = async e => {
    if (!isPaletteGlobalScopeActiveUi()) return;
    const btn = e.target.closest("[data-palette-family]");
    if (!btn) return;
    const selected = String(btn.dataset.paletteFamily || "").trim().toLowerCase();
    if (!selected || !PALETTE_FAMILY_ORDER.includes(selected)) return;
    const current = normalizePaletteFamiliesUi(ui.paletteFamilies, ["red", "green", "blue"]);
    const exists = current.includes(selected);
    let nextFamilies = exists
      ? current.filter(name => name !== selected)
      : current.concat([selected]);
    if (!nextFamilies.length) nextFamilies = [selected];
    nextFamilies = PALETTE_FAMILY_ORDER.filter(name => nextFamilies.includes(name));
    const ok = await applyPalettePatch({ families: nextFamilies }, "PALETTE FAMILIES");
    if (ok) {
      setBadge(el.health, "ok", `PALETTES ${getPaletteFamiliesLabelUi(nextFamilies)}`);
    }
  };
}

paletteDisorderButtons.forEach(btn => {
  btn.onclick = async () => {
    if (!isPaletteGlobalScopeActiveUi()) return;
    const disorder = String(btn.dataset.paletteDisorder || "").toLowerCase() === "true";
    const ok = await applyPalettePatch({ disorder }, "PALETTE ORDER");
    if (ok) {
      setBadge(el.health, "ok", disorder ? "PALETTE ORDER DISORDER" : "PALETTE ORDER ORDERED");
    }
  };
});

if (el.paletteDisorderAggression) {
  el.paletteDisorderAggression.oninput = () => {
    ui.paletteDisorderAggression = normalizePaletteDisorderAggressionUi(el.paletteDisorderAggression.value, 0.35);
    syncPaletteDisorderAggressionSliderUi();
  };
  el.paletteDisorderAggression.onchange = async () => {
    if (!isPaletteGlobalScopeActiveUi()) return;
    const aggression = normalizePaletteDisorderAggressionUi(el.paletteDisorderAggression.value, ui.paletteDisorderAggression || 0.35);
    ui.paletteDisorderAggression = aggression;
    syncPaletteDisorderAggressionSliderUi();
    const ok = await applyPalettePatch({ disorderAggression: aggression }, "PALETTE CHAOS");
    if (ok) setBadge(el.health, "ok", `PALETTE CHAOS ${Math.round(aggression * 100)}%`);
  };
}
if (el.paletteDisorderAggressionResetBtn) {
  el.paletteDisorderAggressionResetBtn.onclick = async () => {
    if (!isPaletteGlobalScopeActiveUi()) return;
    ui.paletteDisorderAggression = 0.35;
    syncPaletteDisorderAggressionSliderUi();
    const ok = await applyPalettePatch({ disorderAggression: 0.35 }, "PALETTE CHAOS");
    if (ok) setBadge(el.health, "ok", "PALETTE CHAOS RESET");
  };
}

function getPaletteBrandScopePatchUi(brandKey) {
  const brand = normalizePaletteBrandUi(brandKey);
  if (!brand) return null;
  const fixtures = getPaletteBrandFixturesUi(brand);
  const validFixtureIds = new Set(fixtures.map(entry => String(entry.id || "").trim()).filter(Boolean));
  const requested = String(ui.paletteFixtureSelectionByBrand?.[brand] || PALETTE_ALL_FIXTURES_VALUE).trim();
  const selected = requested !== PALETTE_ALL_FIXTURES_VALUE && validFixtureIds.has(requested)
    ? requested
    : PALETTE_ALL_FIXTURES_VALUE;
  if (ui.paletteFixtureSelectionByBrand[brand] !== selected) {
    ui.paletteFixtureSelectionByBrand[brand] = selected;
    persistPaletteFixtureSelectionMemory();
  }
  const patch = { brand };
  if (selected && selected !== PALETTE_ALL_FIXTURES_VALUE) {
    patch.fixtureId = selected;
  }
  return patch;
}

if (el.paletteBrandMenus) {
  const markBrandMenusHot = () => markPaletteBrandMenusInteraction(480);
  ["pointerdown", "focusin", "keydown", "input", "change"].forEach(type => {
    el.paletteBrandMenus.addEventListener(type, markBrandMenusHot, { capture: true });
  });

  el.paletteBrandMenus.onchange = async e => {
    const fixtureSelect = e.target.closest("select[data-palette-brand-fixture]");
    if (!fixtureSelect) return;
    const brand = normalizePaletteBrandUi(fixtureSelect.dataset.paletteBrandFixture);
    if (!brand) return;
    const selected = String(fixtureSelect.value || PALETTE_ALL_FIXTURES_VALUE).trim() || PALETTE_ALL_FIXTURES_VALUE;
    ui.paletteFixtureSelectionByBrand[brand] = selected;
    persistPaletteFixtureSelectionMemory();
    renderPaletteBrandMenus({ force: true, reason: "fixture_select_change" });
    sync();
  };

  el.paletteBrandMenus.oninput = e => {
    const chaosSlider = e.target.closest("input[data-palette-brand-aggression]");
    if (chaosSlider) {
      const brand = normalizePaletteBrandUi(chaosSlider.dataset.paletteBrandAggression);
      if (!brand) return;
      const pct = Math.round(normalizePaletteDisorderAggressionUi(chaosSlider.value, 0.35) * 100);
      const valueNode = el.paletteBrandMenus.querySelector(`[data-palette-brand-aggression-val="${brand}"]`);
      if (valueNode) valueNode.textContent = `${pct}%`;
      return;
    }

    const timedSlider = e.target.closest("input[data-palette-brand-timed]");
    if (timedSlider) {
      const brand = normalizePaletteBrandUi(timedSlider.dataset.paletteBrandTimed);
      if (!brand) return;
      const intervalSec = normalizePaletteTimedIntervalSecUi(timedSlider.value, 5);
      const valueNode = el.paletteBrandMenus.querySelector(`[data-palette-brand-timed-val="${brand}"]`);
      if (valueNode) valueNode.textContent = `${intervalSec}s`;
      timedSlider.value = String(intervalSec);
      return;
    }

    const beatGraceSlider = e.target.closest("input[data-palette-brand-beat-grace]");
    if (beatGraceSlider) {
      const brand = normalizePaletteBrandUi(beatGraceSlider.dataset.paletteBrandBeatGrace);
      if (!brand) return;
      const graceSec = normalizePaletteBeatLockGraceSecUi(beatGraceSlider.value, 2);
      const valueNode = el.paletteBrandMenus.querySelector(`[data-palette-brand-beat-grace-val="${brand}"]`);
      if (valueNode) valueNode.textContent = `+${graceSec}s`;
      beatGraceSlider.value = String(graceSec);
      return;
    }

    const reactiveMarginSlider = e.target.closest("input[data-palette-brand-reactive-margin]");
    if (reactiveMarginSlider) {
      const brand = normalizePaletteBrandUi(reactiveMarginSlider.dataset.paletteBrandReactiveMargin);
      if (!brand) return;
      const margin = normalizePaletteReactiveMarginUi(reactiveMarginSlider.value, 28);
      const valueNode = el.paletteBrandMenus.querySelector(`[data-palette-brand-reactive-margin-val="${brand}"]`);
      if (valueNode) valueNode.textContent = String(margin);
      reactiveMarginSlider.value = String(margin);
      return;
    }

    const brightnessFollowSlider = e.target.closest("input[data-palette-brand-brightness-follow]");
    if (brightnessFollowSlider) {
      const brand = normalizePaletteBrandUi(brightnessFollowSlider.dataset.paletteBrandBrightnessFollow);
      if (!brand) return;
      const amount = normalizePaletteBrightnessFollowAmountUi(
        Number(brightnessFollowSlider.value) / 100,
        1
      );
      const valueNode = el.paletteBrandMenus.querySelector(`[data-palette-brand-brightness-follow-val="${brand}"]`);
      if (valueNode) valueNode.textContent = formatPaletteBrightnessFollowAmountUi(amount);
      brightnessFollowSlider.value = String(Math.round(amount * 100));
      return;
    }

    const harmonySlider = e.target.closest("input[data-fixture-metric-harmony]");
    if (harmonySlider) {
      const brand = normalizePaletteBrandUi(harmonySlider.dataset.fixtureMetricHarmony);
      if (!brand) return;
      const harmony = normalizeFixtureMetricHarmonySizeUi(
        harmonySlider.value,
        FIXTURE_METRIC_CONFIG_DEFAULT.harmonySize
      );
      const valueNode = el.paletteBrandMenus.querySelector(`[data-fixture-metric-harmony-val="${brand}"]`);
      if (valueNode) valueNode.textContent = String(harmony);
      return;
    }

    const maxHzSlider = e.target.closest("input[data-fixture-metric-maxhz]");
    if (maxHzSlider) {
      const brand = normalizePaletteBrandUi(maxHzSlider.dataset.fixtureMetricMaxhz);
      if (!brand) return;
      const maxHz = normalizeFixtureMetricMaxHzUi(maxHzSlider.value, FIXTURE_METRIC_MAX_HZ_DEFAULT);
      const valueNode = el.paletteBrandMenus.querySelector(`[data-fixture-metric-maxhz-val="${brand}"]`);
      if (valueNode) valueNode.textContent = formatFixtureMetricMaxHzUi(maxHz);
    }
  };

  el.paletteBrandMenus.onclick = async e => {
    const clearBtn = e.target.closest("[data-palette-brand-clear]");
    if (clearBtn) {
      const brand = normalizePaletteBrandUi(clearBtn.dataset.paletteBrandClear);
      if (!brand) return;
      const scopePatch = getPaletteBrandScopePatchUi(brand);
      if (!scopePatch) return;
      const targetLabel = scopePatch.fixtureId ? scopePatch.fixtureId : `${brand.toUpperCase()} ALL`;
      const clearOk = await applyFixtureRoutingClearPatch(
        { ...scopePatch },
        `${brand.toUpperCase()} OVERRIDE`
      );
      if (clearOk) {
        setBadge(el.health, "ok", `OVERRIDES CLEARED ${targetLabel}`);
      }
      return;
    }

    const countBtn = e.target.closest("[data-palette-brand-count]");
    if (countBtn) {
      const brand = normalizePaletteBrandUi(countBtn.dataset.paletteBrandCount);
      if (!brand) return;
      const count = normalizePaletteColorCountUi(countBtn.dataset.count, 3);
      const scopePatch = getPaletteBrandScopePatchUi(brand);
      if (!scopePatch) return;
      const ok = await applyPalettePatch(
        { ...scopePatch, colorsPerFamily: count },
        `${brand.toUpperCase()} PALETTE COUNT`
      );
      if (ok) {
        setBadge(el.health, "ok", `${brand.toUpperCase()} COUNT ${count}`);
      }
      return;
    }

    const vividnessBtn = e.target.closest("[data-palette-brand-vividness]");
    if (vividnessBtn) {
      const brand = normalizePaletteBrandUi(vividnessBtn.dataset.paletteBrandVividness);
      if (!brand) return;
      const level = normalizePaletteVividnessUi(vividnessBtn.dataset.level, 2);
      const scopePatch = getPaletteBrandScopePatchUi(brand);
      if (!scopePatch) return;
      const ok = await applyPalettePatch(
        { ...scopePatch, vividness: level },
        `${brand.toUpperCase()} PALETTE VIVIDNESS`
      );
      if (ok) {
        setBadge(el.health, "ok", `${brand.toUpperCase()} VIVIDNESS ${formatPaletteVividnessLabelUi(level)}`);
      }
      return;
    }

    const familyBtn = e.target.closest("[data-palette-brand-family]");
    if (familyBtn) {
      const brand = normalizePaletteBrandUi(familyBtn.dataset.paletteBrandFamily);
      if (!brand) return;
      const family = String(familyBtn.dataset.family || "").trim().toLowerCase();
      if (!PALETTE_FAMILY_ORDER.includes(family)) return;
      const scopePatch = getPaletteBrandScopePatchUi(brand);
      if (!scopePatch) return;
      const selectedFixture = scopePatch.fixtureId || PALETTE_ALL_FIXTURES_VALUE;
      const currentConfig = getPaletteScopedConfigUi(brand, selectedFixture);
      const currentFamilies = normalizePaletteFamiliesUi(currentConfig.families, ["red", "green", "blue"]);
      const exists = currentFamilies.includes(family);
      let nextFamilies = exists
        ? currentFamilies.filter(name => name !== family)
        : currentFamilies.concat([family]);
      if (!nextFamilies.length) nextFamilies = [family];
      nextFamilies = PALETTE_FAMILY_ORDER.filter(name => nextFamilies.includes(name));
      const ok = await applyPalettePatch(
        { ...scopePatch, families: nextFamilies },
        `${brand.toUpperCase()} PALETTE FAMILIES`
      );
      if (ok) {
        setBadge(el.health, "ok", `${brand.toUpperCase()} ${getPaletteFamiliesLabelUi(nextFamilies)}`);
      }
      return;
    }

    const disorderBtn = e.target.closest("[data-palette-brand-disorder]");
    if (disorderBtn) {
      const brand = normalizePaletteBrandUi(disorderBtn.dataset.paletteBrandDisorder);
      if (!brand) return;
      const disorder = String(disorderBtn.dataset.disorder || "").trim().toLowerCase() === "true";
      const scopePatch = getPaletteBrandScopePatchUi(brand);
      if (!scopePatch) return;
      const ok = await applyPalettePatch(
        { ...scopePatch, disorder },
        `${brand.toUpperCase()} PALETTE ORDER`
      );
      if (ok) {
        setBadge(el.health, "ok", `${brand.toUpperCase()} ${disorder ? "DISORDER" : "ORDERED"}`);
      }
      return;
    }

    const cycleModeBtn = e.target.closest("[data-palette-brand-cycle-mode]");
    if (cycleModeBtn) {
      const brand = normalizePaletteBrandUi(cycleModeBtn.dataset.paletteBrandCycleMode);
      if (!brand) return;
      const nextMode = normalizePaletteCycleModeUi(cycleModeBtn.dataset.mode, "on_trigger");
      const scopePatch = getPaletteBrandScopePatchUi(brand);
      if (!scopePatch) return;
      const selectedFixture = scopePatch.fixtureId || PALETTE_ALL_FIXTURES_VALUE;
      const scopedConfig = getPaletteScopedConfigUi(brand, selectedFixture);
      const previousMode = normalizePaletteCycleModeUi(scopedConfig.cycleMode, "on_trigger");
      const ok = await applyPalettePatch(
        { ...scopePatch, cycleMode: nextMode },
        `${brand.toUpperCase()} PALETTE MODE`
      );
      if (ok) {
        if (nextMode !== previousMode) {
          setPaletteBrandModeNoticeUi(
            brand,
            `${formatPaletteCycleModeLabelUi(nextMode)} active. ${formatPaletteCycleModeLabelUi(previousMode)} was replaced. ${describePaletteCycleModeUi(nextMode)}`,
            { ttlMs: 3600 }
          );
        }
        setBadge(el.health, "ok", `${brand.toUpperCase()} MODE ${formatPaletteCycleModeLabelUi(nextMode)}`);
      }
      return;
    }

    const brightnessModeBtn = e.target.closest("[data-palette-brand-brightness-mode]");
    if (brightnessModeBtn) {
      const brand = normalizePaletteBrandUi(brightnessModeBtn.dataset.paletteBrandBrightnessMode);
      if (!brand) return;
      const mode = normalizePaletteBrightnessModeUi(brightnessModeBtn.dataset.mode, "legacy");
      const scopePatch = getPaletteBrandScopePatchUi(brand);
      if (!scopePatch) return;
      const ok = await applyPalettePatch(
        { ...scopePatch, brightnessMode: mode },
        `${brand.toUpperCase()} BRIGHTNESS`
      );
      if (ok) {
        setBadge(el.health, "ok", `${brand.toUpperCase()} BRIGHTNESS ${formatPaletteBrightnessModeLabelUi(mode)}`);
      }
      return;
    }

    const beatLockBtn = e.target.closest("[data-palette-brand-beat-lock]");
    if (beatLockBtn) {
      const brand = normalizePaletteBrandUi(beatLockBtn.dataset.paletteBrandBeatLock);
      if (!brand) return;
      const enabled = String(beatLockBtn.dataset.enabled || "").trim().toLowerCase() === "true";
      const scopePatch = getPaletteBrandScopePatchUi(brand);
      if (!scopePatch) return;
      const ok = await applyPalettePatch(
        { ...scopePatch, beatLock: enabled },
        `${brand.toUpperCase()} BEAT LOCK`
      );
      if (ok) {
        setBadge(el.health, "ok", `${brand.toUpperCase()} BEAT LOCK ${enabled ? "ON" : "OFF"}`);
      }
      return;
    }

    const spectrumModeBtn = e.target.closest("[data-palette-brand-spectrum-mode]");
    if (spectrumModeBtn) {
      const brand = normalizePaletteBrandUi(spectrumModeBtn.dataset.paletteBrandSpectrumMode);
      if (!brand) return;
      const mode = normalizePaletteSpectrumMapModeUi(spectrumModeBtn.dataset.mode, "auto");
      const scopePatch = getPaletteBrandScopePatchUi(brand);
      if (!scopePatch) return;
      const ok = await applyPalettePatch(
        { ...scopePatch, spectrumMapMode: mode },
        `${brand.toUpperCase()} SPECTRUM`
      );
      if (ok) {
        setBadge(el.health, "ok", `${brand.toUpperCase()} SPECTRUM ${mode === "manual" ? "MANUAL" : "AUTO"}`);
      }
      return;
    }

    const metricModeBtn = e.target.closest("[data-fixture-metric-mode]");
    if (metricModeBtn) {
      const brand = normalizePaletteBrandUi(metricModeBtn.dataset.fixtureMetricMode);
      if (!brand) return;
      const mode = normalizeFixtureMetricModeUi(metricModeBtn.dataset.mode, FIXTURE_METRIC_CONFIG_DEFAULT.mode);
      const scopePatch = getPaletteBrandScopePatchUi(brand);
      if (!scopePatch) return;
      const ok = await applyFixtureMetricPatch(
        { ...scopePatch, mode },
        `${brand.toUpperCase()} METRIC MODE`
      );
      if (ok) {
        setBadge(el.health, "ok", `${brand.toUpperCase()} MODE ${mode === "meta_auto" ? "META AUTO" : "MANUAL"}`);
      }
      return;
    }

    const metricBtn = e.target.closest("[data-fixture-metric-key]");
    if (metricBtn) {
      const brand = normalizePaletteBrandUi(metricBtn.dataset.fixtureMetricKey);
      if (!brand) return;
      const metric = normalizeFixtureMetricKeyUi(metricBtn.dataset.metric, FIXTURE_METRIC_CONFIG_DEFAULT.metric);
      const scopePatch = getPaletteBrandScopePatchUi(brand);
      if (!scopePatch) return;
      const ok = await applyFixtureMetricPatch(
        { ...scopePatch, metric },
        `${brand.toUpperCase()} METRIC`
      );
      if (ok) {
        setBadge(el.health, "ok", `${brand.toUpperCase()} ${FIXTURE_METRIC_LABELS[metric] || metric.toUpperCase()}`);
      }
      return;
    }

    const flipBtn = e.target.closest("[data-fixture-metric-flip]");
    if (flipBtn) {
      const brand = normalizePaletteBrandUi(flipBtn.dataset.fixtureMetricFlip);
      if (!brand) return;
      const enabled = String(flipBtn.dataset.enabled || "").trim().toLowerCase() === "true";
      const scopePatch = getPaletteBrandScopePatchUi(brand);
      if (!scopePatch) return;
      const ok = await applyFixtureMetricPatch(
        { ...scopePatch, metaAutoFlip: enabled },
        `${brand.toUpperCase()} METRIC FLIP`
      );
      if (ok) {
        setBadge(el.health, "ok", `${brand.toUpperCase()} ${enabled ? "FLIP ON" : "FLIP OFF"}`);
      }
      return;
    }

    const maxHzModeBtn = e.target.closest("[data-fixture-metric-maxhz-mode]");
    if (maxHzModeBtn) {
      const brand = normalizePaletteBrandUi(maxHzModeBtn.dataset.fixtureMetricMaxhzMode);
      if (!brand) return;
      const unclamped = String(maxHzModeBtn.dataset.unclamped || "").trim().toLowerCase() === "true";
      const scopePatch = getPaletteBrandScopePatchUi(brand);
      if (!scopePatch) return;
      if (unclamped) {
        const ok = await applyFixtureMetricPatch(
          { ...scopePatch, maxHz: null },
          `${brand.toUpperCase()} MAX HZ`
        );
        if (ok) {
          setBadge(el.health, "ok", `${brand.toUpperCase()} MAX HZ UNCLAMPED`);
        }
        return;
      }
      const slider = el.paletteBrandMenus.querySelector(`input[data-fixture-metric-maxhz="${brand}"]`);
      const maxHz = normalizeFixtureMetricMaxHzUi(
        slider?.value,
        FIXTURE_METRIC_MAX_HZ_DEFAULT
      );
      const appliedHz = Number.isFinite(maxHz) && maxHz > 0
        ? maxHz
        : FIXTURE_METRIC_MAX_HZ_DEFAULT;
      const ok = await applyFixtureMetricPatch(
        { ...scopePatch, maxHz: appliedHz },
        `${brand.toUpperCase()} MAX HZ`
      );
      if (ok) {
        setBadge(el.health, "ok", `${brand.toUpperCase()} MAX HZ ${formatFixtureMetricMaxHzUi(appliedHz)}`);
      }
    }
  };

  el.paletteBrandMenus.addEventListener("change", async e => {
    const chaosSlider = e.target.closest("input[data-palette-brand-aggression]");
    if (chaosSlider) {
      const brand = normalizePaletteBrandUi(chaosSlider.dataset.paletteBrandAggression);
      if (!brand) return;
      const aggression = normalizePaletteDisorderAggressionUi(chaosSlider.value, 0.35);
      const scopePatch = getPaletteBrandScopePatchUi(brand);
      if (!scopePatch) return;
      const ok = await applyPalettePatch(
        { ...scopePatch, disorderAggression: aggression },
        `${brand.toUpperCase()} PALETTE CHAOS`
      );
      if (ok) {
        setBadge(el.health, "ok", `${brand.toUpperCase()} CHAOS ${Math.round(aggression * 100)}%`);
      }
      return;
    }

    const timedSlider = e.target.closest("input[data-palette-brand-timed]");
    if (timedSlider) {
      const brand = normalizePaletteBrandUi(timedSlider.dataset.paletteBrandTimed);
      if (!brand) return;
      const intervalSec = normalizePaletteTimedIntervalSecUi(timedSlider.value, 5);
      const scopePatch = getPaletteBrandScopePatchUi(brand);
      if (!scopePatch) return;
      const ok = await applyPalettePatch(
        { ...scopePatch, timedIntervalSec: intervalSec },
        `${brand.toUpperCase()} TIMER`
      );
      if (ok) {
        setBadge(el.health, "ok", `${brand.toUpperCase()} TIMER ${intervalSec}s`);
      }
      return;
    }

    const beatGraceSlider = e.target.closest("input[data-palette-brand-beat-grace]");
    if (beatGraceSlider) {
      const brand = normalizePaletteBrandUi(beatGraceSlider.dataset.paletteBrandBeatGrace);
      if (!brand) return;
      const graceSec = normalizePaletteBeatLockGraceSecUi(beatGraceSlider.value, 2);
      const scopePatch = getPaletteBrandScopePatchUi(brand);
      if (!scopePatch) return;
      const ok = await applyPalettePatch(
        { ...scopePatch, beatLockGraceSec: graceSec },
        `${brand.toUpperCase()} BEAT LOCK`
      );
      if (ok) {
        setBadge(el.health, "ok", `${brand.toUpperCase()} BEAT LOCK +${graceSec}s`);
      }
      return;
    }

    const reactiveMarginSlider = e.target.closest("input[data-palette-brand-reactive-margin]");
    if (reactiveMarginSlider) {
      const brand = normalizePaletteBrandUi(reactiveMarginSlider.dataset.paletteBrandReactiveMargin);
      if (!brand) return;
      const margin = normalizePaletteReactiveMarginUi(reactiveMarginSlider.value, 28);
      const scopePatch = getPaletteBrandScopePatchUi(brand);
      if (!scopePatch) return;
      const ok = await applyPalettePatch(
        { ...scopePatch, reactiveMargin: margin },
        `${brand.toUpperCase()} REACTIVE`
      );
      if (ok) {
        setBadge(el.health, "ok", `${brand.toUpperCase()} REACTIVE MARGIN ${margin}`);
      }
      return;
    }

    const brightnessFollowSlider = e.target.closest("input[data-palette-brand-brightness-follow]");
    if (brightnessFollowSlider) {
      const brand = normalizePaletteBrandUi(brightnessFollowSlider.dataset.paletteBrandBrightnessFollow);
      if (!brand) return;
      const amount = normalizePaletteBrightnessFollowAmountUi(
        Number(brightnessFollowSlider.value) / 100,
        1
      );
      const scopePatch = getPaletteBrandScopePatchUi(brand);
      if (!scopePatch) return;
      const ok = await applyPalettePatch(
        { ...scopePatch, brightnessFollowAmount: amount },
        `${brand.toUpperCase()} BRIGHTNESS`
      );
      if (ok) {
        setBadge(el.health, "ok", `${brand.toUpperCase()} FOLLOW ${formatPaletteBrightnessFollowAmountUi(amount)}`);
      }
      return;
    }

    const spectrumSlot = e.target.closest("select[data-palette-brand-spectrum-slot]");
    if (spectrumSlot) {
      const brand = normalizePaletteBrandUi(spectrumSlot.dataset.paletteBrandSpectrum);
      if (!brand) return;
      const scopePatch = getPaletteBrandScopePatchUi(brand);
      if (!scopePatch) return;
      const card = el.paletteBrandMenus.querySelector(`[data-palette-brand-card="${brand}"]`);
      const selectors = card
        ? Array.from(card.querySelectorAll(`select[data-palette-brand-spectrum="${brand}"][data-palette-brand-spectrum-slot]`))
        : [];
      selectors.sort((a, b) => {
        const ai = Number(a.dataset.paletteBrandSpectrumSlot);
        const bi = Number(b.dataset.paletteBrandSpectrumSlot);
        return ai - bi;
      });
      const nextMap = [];
      for (let i = 0; i < 5; i += 1) {
        const node = selectors[i];
        nextMap.push(
          normalizePaletteAudioFeatureUi(
            node?.value,
            PALETTE_DEFAULT_SPECTRUM_FEATURE_MAP[i % PALETTE_DEFAULT_SPECTRUM_FEATURE_MAP.length]
          )
        );
      }
      const ok = await applyPalettePatch(
        { ...scopePatch, spectrumFeatureMap: nextMap },
        `${brand.toUpperCase()} SPECTRUM`
      );
      if (ok) {
        setBadge(el.health, "ok", `${brand.toUpperCase()} SPECTRUM MAP UPDATED`);
      }
      return;
    }

    const harmonySlider = e.target.closest("input[data-fixture-metric-harmony]");
    if (harmonySlider) {
      const brand = normalizePaletteBrandUi(harmonySlider.dataset.fixtureMetricHarmony);
      if (!brand) return;
      const harmonySize = normalizeFixtureMetricHarmonySizeUi(
        harmonySlider.value,
        FIXTURE_METRIC_CONFIG_DEFAULT.harmonySize
      );
      const scopePatch = getPaletteBrandScopePatchUi(brand);
      if (!scopePatch) return;
      const ok = await applyFixtureMetricPatch(
        { ...scopePatch, harmonySize },
        `${brand.toUpperCase()} HARMONY`
      );
      if (ok) {
        setBadge(el.health, "ok", `${brand.toUpperCase()} HARMONY ${harmonySize}`);
      }
      return;
    }

    const maxHzSlider = e.target.closest("input[data-fixture-metric-maxhz]");
    if (maxHzSlider) {
      const brand = normalizePaletteBrandUi(maxHzSlider.dataset.fixtureMetricMaxhz);
      if (!brand) return;
      const maxHz = normalizeFixtureMetricMaxHzUi(
        maxHzSlider.value,
        FIXTURE_METRIC_MAX_HZ_DEFAULT
      );
      const appliedHz = Number.isFinite(maxHz) && maxHz > 0
        ? maxHz
        : FIXTURE_METRIC_MAX_HZ_DEFAULT;
      const scopePatch = getPaletteBrandScopePatchUi(brand);
      if (!scopePatch) return;
      const ok = await applyFixtureMetricPatch(
        { ...scopePatch, maxHz: appliedHz },
        `${brand.toUpperCase()} MAX HZ`
      );
      if (ok) {
        setBadge(el.health, "ok", `${brand.toUpperCase()} MAX HZ ${formatFixtureMetricMaxHzUi(appliedHz)}`);
      }
    }
  });
}

/* MIDI CONTROL */
if (el.midiBindingAction) {
  el.midiBindingAction.onchange = () => {
    applyMidiBindingEditor(ui.midiSnapshot);
  };
}

if (el.midiBindingType) {
  el.midiBindingType.onchange = () => {
    const type = String(el.midiBindingType.value || "note").toLowerCase();
    const defaultMin = type === "cc" ? 64 : 1;
    const current = Number(el.midiBindingMinValue?.value);
    if (!Number.isFinite(current) || current < 0 || current > 127) {
      if (el.midiBindingMinValue) el.midiBindingMinValue.value = String(defaultMin);
    }
  };
}

if (el.midiLearnAction) {
  el.midiLearnAction.onchange = () => {
    if (el.midiBindingAction) {
      const next = normalizeMidiAction(el.midiLearnAction.value);
      if (next) {
        el.midiBindingAction.value = next;
        applyMidiBindingEditor(ui.midiSnapshot);
      }
    }
  };
}

if (el.midiRefreshBtn) {
  el.midiRefreshBtn.onclick = async () => {
    const ok = await loadMidiStatus({ refresh: true });
    setBadge(el.health, ok ? "ok" : "bad", ok ? "MIDI PORTS REFRESHED" : "MIDI REFRESH FAIL");
  };
}

if (el.midiSaveCfgBtn) {
  el.midiSaveCfgBtn.onclick = async () => {
    const patch = collectMidiConfigPatch();
    const response = await postJson("/midi/config", patch);
    if (!response.ok || !response.data) {
      setBadge(el.health, "bad", "MIDI CONFIG SAVE FAIL");
      return;
    }
    applyMidiSnapshot(response.data);
    setBadge(el.health, "ok", "MIDI CONFIG SAVED");
  };
}

if (el.midiLearnArmBtn) {
  el.midiLearnArmBtn.onclick = async () => {
    const action = normalizeMidiAction(el.midiLearnAction?.value);
    if (!action) {
      setBadge(el.health, "warn", "SELECT MIDI ACTION");
      return;
    }
    const response = await postJson(`/midi/learn/${encodeURIComponent(action)}`, {});
    if (!response.ok || !response.data) {
      setBadge(el.health, "bad", "MIDI LEARN ARM FAIL");
      return;
    }
    applyMidiSnapshot(response.data);
    setBadge(el.health, "ok", `MIDI LEARN ${formatMidiActionLabel(action)}`);
  };
}

if (el.midiLearnCancelBtn) {
  el.midiLearnCancelBtn.onclick = async () => {
    const response = await postJson("/midi/learn/cancel", {});
    if (!response.ok || !response.data) {
      setBadge(el.health, "bad", "MIDI LEARN CANCEL FAIL");
      return;
    }
    applyMidiSnapshot(response.data);
    setBadge(el.health, "ok", "MIDI LEARN CANCELED");
  };
}

if (el.midiTriggerBtn) {
  el.midiTriggerBtn.onclick = async () => {
    const action = normalizeMidiAction(el.midiLearnAction?.value);
    if (!action) {
      setBadge(el.health, "warn", "SELECT MIDI ACTION");
      return;
    }
    const response = await postJson(`/midi/trigger/${encodeURIComponent(action)}`, {});
    if (!response.ok || !response.data) {
      setBadge(el.health, "bad", "MIDI ACTION TRIGGER FAIL");
      return;
    }
    applyMidiSnapshot(response.data);
    setBadge(el.health, "ok", `MIDI TRIGGERED ${formatMidiActionLabel(action)}`);
  };
}

if (el.midiBindingSaveBtn) {
  el.midiBindingSaveBtn.onclick = async () => {
    const action = normalizeMidiAction(el.midiBindingAction?.value);
    if (!action) {
      setBadge(el.health, "warn", "SELECT BINDING ACTION");
      return;
    }
    const patch = collectMidiBindingPatch();
    const response = await postJson(`/midi/bindings/${encodeURIComponent(action)}`, patch);
    if (!response.ok || !response.data) {
      setBadge(el.health, "bad", "MIDI BINDING SAVE FAIL");
      return;
    }
    applyMidiSnapshot(response.data);
    setBadge(el.health, "ok", `MIDI BINDING SAVED ${formatMidiActionLabel(action)}`);
  };
}

if (el.midiBindingClearBtn) {
  el.midiBindingClearBtn.onclick = async () => {
    const action = normalizeMidiAction(el.midiBindingAction?.value);
    if (!action) {
      setBadge(el.health, "warn", "SELECT BINDING ACTION");
      return;
    }
    const response = await deleteJson(`/midi/bindings/${encodeURIComponent(action)}`);
    if (!response.ok || !response.data) {
      setBadge(el.health, "bad", "MIDI BINDING CLEAR FAIL");
      return;
    }
    applyMidiSnapshot(response.data);
    setBadge(el.health, "ok", `MIDI BINDING CLEARED ${formatMidiActionLabel(action)}`);
  };
}

if (el.midiBindingResetBtn) {
  el.midiBindingResetBtn.onclick = async () => {
    const response = await postJson("/midi/bindings/reset", {});
    if (!response.ok || !response.data) {
      setBadge(el.health, "bad", "MIDI DEFAULT RESET FAIL");
      return;
    }
    applyMidiSnapshot(response.data);
    setBadge(el.health, "ok", "MIDI DEFAULT BINDINGS RESTORED");
  };
}

const REACTOR_DEFAULTS = Object.freeze({
  master: 1.0,
  dropImpact: 1.0
});

function normalizeVisualMaster(value) {
  const n = Number(value);
  if (!Number.isFinite(n)) return REACTOR_DEFAULTS.master;
  return Math.min(2, Math.max(0, n));
}

function normalizeDropImpact(value) {
  const n = Number(value);
  if (!Number.isFinite(n)) return REACTOR_DEFAULTS.dropImpact;
  return Math.min(2, Math.max(0.5, n));
}

function getReactorRiskState() {
  const overclockLevel = Number(ui.overclockLevel || 0);
  const master = normalizeVisualMaster(ui.visualMaster);
  const drop = normalizeDropImpact(ui.dropIntensity);
  const boosted = master > 1.05 || drop > 1.05;
  const aggressive = master >= 1.2 || drop >= 1.25;

  if (overclockLevel >= 8) {
    return {
      level: "bad",
      text: "Critical risk: DEV overclock tiers (>=20Hz) are destructive and may cause transport collapse, erratic flashing, or unpredictable fixture behavior."
    };
  }

  if (overclockLevel >= 4 && aggressive) {
    return {
      level: "bad",
      text: "High risk: boosted MASTER/DROP with >=10Hz overclock can cause clipping, harsh flashes, and unstable device behavior. Lower sliders or lower overclock."
    };
  }

  if ((overclockLevel >= 2 && boosted) || aggressive) {
    return {
      level: "warn",
      text: "Caution: higher MASTER/DROP often degrades quality. Combine carefully with overclock tiers >=6Hz."
    };
  }

  return {
    level: "base",
    text: "Safe baseline: keep MASTER near 1.00 and DROP near 1.0, then tune gradually."
  };
}

function updateReactorRiskNotice() {
  if (!el.reactorRiskNotice) return;
  const state = getReactorRiskState();
  el.reactorRiskNotice.textContent = state.text;
  el.reactorRiskNotice.classList.remove("warn", "bad");
  if (state.level === "warn") {
    el.reactorRiskNotice.classList.add("warn");
  } else if (state.level === "bad") {
    el.reactorRiskNotice.classList.add("bad");
  }
}

function applyReactorSliderUi() {
  ui.visualMaster = normalizeVisualMaster(ui.visualMaster);
  ui.dropIntensity = normalizeDropImpact(ui.dropIntensity);
  if (el.master) el.master.value = String(Math.round(ui.visualMaster * 50));
  if (el.dropIntensity) el.dropIntensity.value = String(Math.round(ui.dropIntensity * 100));
  if (el.masterVal) el.masterVal.textContent = ui.visualMaster.toFixed(2);
  if (el.dropVal) el.dropVal.textContent = ui.dropIntensity.toFixed(1);
  updateReactorRiskNotice();
}

function resetReactorControls(mode = "both") {
  if (mode === "master" || mode === "both") {
    ui.visualMaster = REACTOR_DEFAULTS.master;
  }
  if (mode === "drop" || mode === "both") {
    ui.dropIntensity = REACTOR_DEFAULTS.dropImpact;
  }
  applyReactorSliderUi();
}

/* SLIDERS */
el.master.oninput = () => {
  ui.visualMaster = normalizeVisualMaster(Number(el.master.value) / 50);
  applyReactorSliderUi();
};
el.master.ondblclick = () => {
  resetReactorControls("master");
  setBadge(el.health, "ok", "MASTER RESET TO 1.00");
};

el.flowIntensity.oninput = () => {
  ui.flowIntensity = clampFlowIntensity(Number(el.flowIntensity.value) / 100);
  ui.flowIntensityInputUntil = Date.now() + 900;
  applyFlowIntensityUi();

  if (flowIntensityCommitTimer) clearTimeout(flowIntensityCommitTimer);
  flowIntensityCommitTimer = setTimeout(() => {
    commitFlowIntensity({ silent: true });
  }, 170);
};

el.flowIntensity.onchange = () => {
  if (flowIntensityCommitTimer) {
    clearTimeout(flowIntensityCommitTimer);
    flowIntensityCommitTimer = null;
  }
  commitFlowIntensity({ silent: false });
};
el.flowIntensity.ondblclick = () => {
  resetFlowIntensity({ silent: false });
};

el.dropIntensity.oninput = () => {
  ui.dropIntensity = normalizeDropImpact(Number(el.dropIntensity.value) / 100);
  applyReactorSliderUi();
};
el.dropIntensity.ondblclick = () => {
  resetReactorControls("drop");
  setBadge(el.health, "ok", "DROP IMPACT RESET TO 1.0");
};

el.masterInlineResetBtn.onclick = () => {
  resetReactorControls("master");
  setBadge(el.health, "ok", "MASTER RESET TO 1.00");
};

el.flowResetBtn.onclick = () => {
  resetFlowIntensity({ silent: false });
};

el.dropInlineResetBtn.onclick = () => {
  resetReactorControls("drop");
  setBadge(el.health, "ok", "DROP IMPACT RESET TO 1.0");
};

el.reactorResetBtn.onclick = () => {
  resetReactorControls("both");
  setBadge(el.health, "ok", "REACTOR SLIDERS RESET");
};

/* OSCILLOSCOPE */
const mainScopeCtx = el.canvas.getContext("2d");
const telemetryScopeCtx = el.telemetryCanvas.getContext("2d");
const SCOPE_MAX_PIXEL_RATIO = 1.0;
const MAIN_SCOPE_MAX_FPS = 24;
const MAIN_SCOPE_FRAME_MS = Math.round(1000 / MAIN_SCOPE_MAX_FPS);
const telemetrySeriesMax = 240;
const telemetrySeries = {
  energy: [],
  rms: [],
  flux: [],
  hueLat: [],
  wizLat: [],
  drop: []
};

let telemetryGridCache = null;
let mainGridCache = null;

function getCanvasResolutionScale() {
  const dpr = Math.max(1, Number(window.devicePixelRatio) || 1);
  return Math.min(1, SCOPE_MAX_PIXEL_RATIO / dpr);
}

function resizeOneCanvas(canvas) {
  const scale = getCanvasResolutionScale();
  const nextW = Math.max(1, Math.floor(canvas.offsetWidth * scale));
  const nextH = Math.max(1, Math.floor(canvas.offsetHeight * scale));
  if (canvas.width !== nextW) canvas.width = nextW;
  if (canvas.height !== nextH) canvas.height = nextH;
}

function rebuildTelemetryGridCache() {
  const w = el.telemetryCanvas.width;
  const h = el.telemetryCanvas.height;
  if (!w || !h) return;

  const cache = document.createElement("canvas");
  cache.width = w;
  cache.height = h;
  const ctx = cache.getContext("2d");

  ctx.fillStyle = "#030711";
  ctx.fillRect(0, 0, w, h);
  ctx.strokeStyle = "#17213d";
  ctx.lineWidth = 1;

  for (let i = 1; i < 6; i++) {
    const y = (i / 6) * h;
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(w, y);
    ctx.stroke();
  }

  for (let i = 1; i < 12; i++) {
    const x = (i / 12) * w;
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, h);
    ctx.stroke();
  }

  telemetryGridCache = cache;
}

function rebuildMainGridCache() {
  const w = el.canvas.width;
  const h = el.canvas.height;
  if (!w || !h) return;

  const cache = document.createElement("canvas");
  cache.width = w;
  cache.height = h;
  const ctx = cache.getContext("2d");

  ctx.fillStyle = "#030711";
  ctx.fillRect(0, 0, w, h);

  ctx.strokeStyle = "rgba(23,33,61,0.85)";
  ctx.lineWidth = 1;
  for (let i = 1; i < 8; i++) {
    const y = (i / 8) * h;
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(w, y);
    ctx.stroke();
  }
  for (let i = 1; i < 14; i++) {
    const x = (i / 14) * w;
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, h);
    ctx.stroke();
  }

  // Scope center reference
  ctx.strokeStyle = "rgba(70,96,148,0.55)";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(0, h * 0.5);
  ctx.lineTo(w, h * 0.5);
  ctx.stroke();

  mainGridCache = cache;
}

function resizeCanvas() {
  resizeOneCanvas(el.canvas);
  resizeOneCanvas(el.telemetryCanvas);
  rebuildMainGridCache();
  rebuildTelemetryGridCache();
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

const clamp01 = v => Math.min(1, Math.max(0, Number(v) || 0));
const scopeInput = {
  energy: 0.05,
  rms: 0.03,
  transient: 0,
  flux: 0,
  beat: 0,
  low: 0,
  mid: 0,
  high: 0,
  drop: false
};
const scopeState = {
  energy: 0.05,
  rms: 0.03,
  transient: 0,
  flux: 0,
  beat: 0,
  low: 0,
  mid: 0,
  high: 0
};

function updateMainScopeInput(t, a) {
  scopeInput.energy = clamp01((Number(t?.energy || 0) / 1.2));
  scopeInput.rms = clamp01(a?.level ?? t?.audioSourceLevel ?? t?.rms ?? 0);
  scopeInput.transient = clamp01(a?.transient ?? t?.audioTransient ?? 0);
  scopeInput.flux = clamp01(a?.spectralFlux ?? t?.audioFlux ?? 0);
  scopeInput.beat = clamp01((Number(t?.beatConfidence || 0) || 0));
  scopeInput.low = clamp01(a?.bandLow ?? t?.audioBandLow ?? scopeInput.rms);
  scopeInput.mid = clamp01(a?.bandMid ?? t?.audioBandMid ?? scopeInput.rms * 0.9);
  scopeInput.high = clamp01(a?.bandHigh ?? t?.audioBandHigh ?? scopeInput.rms * 0.8);
  scopeInput.drop = Boolean(t?.drop);
}

function updateScopeHud(t, a) {
  const rms = clamp01(a?.level ?? t?.audioSourceLevel ?? t?.rms ?? 0);
  const eng = clamp01((Number(t?.energy || 0) / 1.2));
  const tr = clamp01(a?.transient ?? t?.audioTransient ?? 0);
  const flx = clamp01(a?.spectralFlux ?? t?.audioFlux ?? 0);
  const beat = clamp01(Number(t?.beatConfidence || 0));
  const drive = clamp01(rms * 0.46 + eng * 0.42 + tr * 0.12);
  const motion = clamp01(tr * 0.46 + flx * 0.34 + beat * 0.2);

  el.scopeDrive.textContent = drive.toFixed(2);
  el.scopeMotion.textContent = motion.toFixed(2);
  el.scopeScene.textContent = String(t?.scene || "-").replace(/^flow_/, "F:");
  el.scopeBehav.textContent = String(t?.behavior || "-").toUpperCase();
}

let ph = 0;
let mainScopeAnim = null;
let mainScopeLastFrameAt = 0;

function monitorsActive() {
  return ui.activeTab === "live" && !document.hidden;
}

function drawWave() {
  const w = el.canvas.width;
  const h = el.canvas.height;
  if (!w || !h) return;

  scopeState.energy += (scopeInput.energy - scopeState.energy) * 0.16;
  scopeState.rms += (scopeInput.rms - scopeState.rms) * 0.2;
  scopeState.transient += (scopeInput.transient - scopeState.transient) * 0.22;
  scopeState.flux += (scopeInput.flux - scopeState.flux) * 0.18;
  scopeState.beat += (scopeInput.beat - scopeState.beat) * 0.2;
  scopeState.low += (scopeInput.low - scopeState.low) * 0.2;
  scopeState.mid += (scopeInput.mid - scopeState.mid) * 0.2;
  scopeState.high += (scopeInput.high - scopeState.high) * 0.2;

  const drop = scopeInput.drop;
  const drive = clamp01(
    scopeState.rms * 0.44 +
    scopeState.energy * 0.36 +
    scopeState.transient * 0.12 +
    scopeState.beat * 0.08
  );
  const motion = clamp01(
    scopeState.transient * 0.46 +
    scopeState.flux * 0.34 +
    scopeState.beat * 0.2
  );
  const gain = ui.visualMaster * (drop ? ui.dropIntensity : 1);

  mainScopeCtx.clearRect(0, 0, w, h);
  if (!mainGridCache || mainGridCache.width !== w || mainGridCache.height !== h) {
    rebuildMainGridCache();
  }
  if (mainGridCache) {
    mainScopeCtx.drawImage(mainGridCache, 0, 0);
  } else {
    mainScopeCtx.fillStyle = "#030711";
    mainScopeCtx.fillRect(0, 0, w, h);
  }

  const centerY = h * 0.5;
  const maxAmp = h * 0.34;
  const amp = Math.max(1.5, maxAmp * (0.04 + drive * 0.38 + motion * 0.52) * gain);

  // Keep points bounded for GPU/CPU friendliness.
  const points = Math.max(72, Math.min(160, Math.floor(w / 4)));
  const step = w / Math.max(1, points - 1);

  const drawTrace = (color, width, fn) => {
    mainScopeCtx.strokeStyle = color;
    mainScopeCtx.lineWidth = width;
    mainScopeCtx.beginPath();
    for (let i = 0; i < points; i++) {
      const x = i * step;
      const t = i / Math.max(1, points - 1);
      const y = fn(x, t);
      if (i === 0) mainScopeCtx.moveTo(x, y);
      else mainScopeCtx.lineTo(x, y);
    }
    mainScopeCtx.stroke();
  };

  const lowWeight = clamp01(0.35 + scopeState.low * 0.85);
  const midWeight = clamp01(0.35 + scopeState.mid * 0.85);
  const highWeight = clamp01(0.3 + scopeState.high * 0.92);
  const baseFreq = 0.012 + scopeState.beat * 0.02 + scopeState.transient * 0.012;
  const modFreq = 0.034 + scopeState.flux * 0.042;

  drawTrace("rgba(26,220,255,0.88)", 1.2, (x, t) => {
    const y =
      centerY +
      Math.sin(x * baseFreq + ph * 0.09) * amp * 0.58 * lowWeight +
      Math.sin(x * 0.006 + ph * 0.05) * amp * 0.22 * scopeState.low;
    return y;
  });

  drawTrace("rgba(255,74,122,0.92)", drop ? 1.8 : 1.5, (x, t) => {
    const y =
      centerY +
      Math.sin(x * (baseFreq * 1.45) + ph * 0.15 + 0.7) * amp * 0.64 * midWeight +
      Math.sin(x * modFreq + ph * 0.22) * amp * 0.18 * scopeState.transient;
    return y;
  });

  drawTrace("rgba(255,210,72,0.82)", 1.1, (x, t) => {
    const y =
      centerY +
      Math.sin(x * (baseFreq * 2.4) + ph * 0.24 + 1.7) * amp * 0.46 * highWeight +
      Math.sin(x * (modFreq * 1.6) + ph * 0.3) * amp * 0.15 * scopeState.high;
    return y;
  });

  drawTrace(drop ? "rgba(255,245,245,0.9)" : "rgba(198,226,255,0.72)", drop ? 2.2 : 1.6, (x, t) => {
    const low = Math.sin(x * baseFreq + ph * 0.09) * 0.42 * lowWeight;
    const mid = Math.sin(x * (baseFreq * 1.45) + ph * 0.15 + 0.7) * 0.34 * midWeight;
    const high = Math.sin(x * (baseFreq * 2.4) + ph * 0.24 + 1.7) * 0.24 * highWeight;
    const transientLift = Math.sin(x * modFreq + ph * 0.26) * 0.2 * scopeState.transient;
    return centerY + (low + mid + high + transientLift) * amp;
  });

  if (drop || motion > 0.58) {
    const pulseSpacing = Math.max(16, Math.round(w / 18));
    mainScopeCtx.strokeStyle = drop ? "rgba(255,255,255,0.26)" : "rgba(80,205,255,0.18)";
    mainScopeCtx.lineWidth = 1;
    for (let x = pulseSpacing; x < w; x += pulseSpacing) {
      if (((x / pulseSpacing) | 0) % 2 === 0 && !drop) continue;
      mainScopeCtx.beginPath();
      mainScopeCtx.moveTo(x, centerY - amp * (0.24 + motion * 0.24));
      mainScopeCtx.lineTo(x, centerY + amp * (0.24 + motion * 0.24));
      mainScopeCtx.stroke();
    }
  }

  ph += 0.8 + scopeState.transient * 1.45 + scopeState.flux * 1.05 + scopeState.beat * 1.1 + (drop ? 0.6 : 0);
}

function renderMainScope(now = performance.now()) {
  if (!monitorsActive()) {
    mainScopeAnim = null;
    mainScopeLastFrameAt = 0;
    return;
  }

  if (!mainScopeLastFrameAt || (now - mainScopeLastFrameAt) >= MAIN_SCOPE_FRAME_MS) {
    drawWave();
    mainScopeLastFrameAt = now;
  }

  mainScopeAnim = requestAnimationFrame(renderMainScope);
}

function updateMonitorRenderingState() {
  if (monitorsActive()) {
    if (!mainScopeAnim) {
      mainScopeAnim = requestAnimationFrame(renderMainScope);
    }
    drawTelemetryScope();
    return;
  }

  if (mainScopeAnim) {
    cancelAnimationFrame(mainScopeAnim);
    mainScopeAnim = null;
  }
  mainScopeLastFrameAt = 0;
}

function pushScopeSample(t, h, w, a) {
  const energy = Math.min(1, Math.max(0, Number(t?.energy || 0) / 1.2));
  const rms = Math.min(1, Math.max(0, Number(t?.audioSourceLevel ?? t?.rms ?? 0)));
  const flux = Math.min(1, Math.max(0, Number(a?.spectralFlux || 0)));
  const hueLat = Math.min(1, Math.max(0, Number(h?.lastDurationMs || 0) / 180));
  const wizLat = Math.min(1, Math.max(0, Number(w?.lastDurationMs || 0) / 120));
  const drop = Boolean(t?.drop);

  telemetrySeries.energy.push(energy);
  telemetrySeries.rms.push(rms);
  telemetrySeries.flux.push(flux);
  telemetrySeries.hueLat.push(hueLat);
  telemetrySeries.wizLat.push(wizLat);
  telemetrySeries.drop.push(drop ? 1 : 0);

  for (const key of Object.keys(telemetrySeries)) {
    if (telemetrySeries[key].length > telemetrySeriesMax) {
      telemetrySeries[key].shift();
    }
  }
}

function drawScopeLine(values, color, width = 1.4) {
  const w = el.telemetryCanvas.width;
  const h = el.telemetryCanvas.height;
  const len = values.length;
  if (!len) return;

  telemetryScopeCtx.strokeStyle = color;
  telemetryScopeCtx.lineWidth = width;
  telemetryScopeCtx.beginPath();
  for (let i = 0; i < len; i++) {
    const x = (i / Math.max(1, telemetrySeriesMax - 1)) * w;
    const y = h - values[i] * h;
    if (i === 0) telemetryScopeCtx.moveTo(x, y);
    else telemetryScopeCtx.lineTo(x, y);
  }
  telemetryScopeCtx.stroke();
}

function drawTelemetryScope() {
  const w = el.telemetryCanvas.width;
  const h = el.telemetryCanvas.height;
  if (!w || !h) return;

  telemetryScopeCtx.clearRect(0, 0, w, h);
  if (!telemetryGridCache || telemetryGridCache.width !== w || telemetryGridCache.height !== h) {
    rebuildTelemetryGridCache();
  }
  if (telemetryGridCache) {
    telemetryScopeCtx.drawImage(telemetryGridCache, 0, 0);
  } else {
    telemetryScopeCtx.fillStyle = "#030711";
    telemetryScopeCtx.fillRect(0, 0, w, h);
  }

  drawScopeLine(telemetrySeries.energy, "#ff334f", 1.8);
  drawScopeLine(telemetrySeries.rms, "#22d7ff", 1.5);
  drawScopeLine(telemetrySeries.flux, "#ffd34e", 1.4);
  drawScopeLine(telemetrySeries.hueLat, "#ff8c3a", 1.3);
  drawScopeLine(telemetrySeries.wizLat, "#38ff9f", 1.3);

  telemetryScopeCtx.strokeStyle = "rgba(255,255,255,0.4)";
  telemetryScopeCtx.lineWidth = 1;
  const drops = telemetrySeries.drop;
  for (let i = 0; i < drops.length; i++) {
    if (!drops[i]) continue;
    const x = (i / Math.max(1, telemetrySeriesMax - 1)) * w;
    telemetryScopeCtx.beginPath();
    telemetryScopeCtx.moveTo(x, 0);
    telemetryScopeCtx.lineTo(x, h);
    telemetryScopeCtx.stroke();
  }
}

function sync() {
  el.onBtn.classList.toggle("active", ui.raveOn);
  el.offBtn.classList.toggle("active", !ui.raveOn);
  applyModeUiPolicy();
  el.metaAutoOnBtn.classList.toggle("active", ui.metaAutoEnabled);
  el.metaAutoOffBtn.classList.toggle("active", !ui.metaAutoEnabled);
  if (el.metaAutoTrackerAutoBtn) {
    el.metaAutoTrackerAutoBtn.classList.toggle("active", ui.metaAutoTempoTrackersAuto === true);
    el.metaAutoTrackerAutoBtn.textContent = ui.metaAutoTempoTrackersAuto
      ? "DOMINANT MODE: AUTO ON"
      : "DOMINANT MODE: AUTO OFF";
  }
  const metaTempoTrackers = normalizeMetaAutoTempoTrackersUi(
    ui.metaAutoTempoTrackers,
    AUDIO_REACTIVITY_MAP_DEFAULT.metaAutoTempoTrackers
  );
  const metaTempoTrackersActive = normalizeMetaAutoTempoTrackersUi(
    ui.metaAutoTempoTrackersActive,
    metaTempoTrackers
  );
  ui.metaAutoTempoTrackers = { ...metaTempoTrackers };
  ui.metaAutoTempoTrackersActive = { ...metaTempoTrackersActive };
  if (el.metaAutoTrackerCandidatesBtn) {
    const anyCandidate = Boolean(
      metaTempoTrackers.baseline ||
      metaTempoTrackers.peaks ||
      metaTempoTrackers.transients ||
      metaTempoTrackers.flux
    );
    el.metaAutoTrackerCandidatesBtn.classList.toggle("active", anyCandidate);
    el.metaAutoTrackerCandidatesBtn.textContent = anyCandidate
      ? "BUILD CANDIDATES (READY)"
      : "BUILD CANDIDATES";
  }
  ui.metaAutoHueWizBaselineBlend = metaTempoTrackers.baseline === true;
  if (el.metaAutoHueWizBaselineBlendBtn) {
    const blendEnabled = Boolean(metaTempoTrackers.baseline);
    el.metaAutoHueWizBaselineBlendBtn.classList.toggle("active", blendEnabled);
    el.metaAutoHueWizBaselineBlendBtn.textContent = blendEnabled
      ? "BASE+DRUMS ON"
      : "BASE+DRUMS OFF";
  }
  if (el.metaAutoTrackerPeaksBtn) {
    const peaksEnabled = Boolean(metaTempoTrackers.peaks);
    el.metaAutoTrackerPeaksBtn.classList.toggle("active", peaksEnabled);
    el.metaAutoTrackerPeaksBtn.textContent = peaksEnabled
      ? "PEAKS ON"
      : "PEAKS OFF";
  }
  if (el.metaAutoTrackerTransientsBtn) {
    const transientsEnabled = Boolean(metaTempoTrackers.transients);
    el.metaAutoTrackerTransientsBtn.classList.toggle("active", transientsEnabled);
    el.metaAutoTrackerTransientsBtn.textContent = transientsEnabled
      ? "TRANSIENTS ON"
      : "TRANSIENTS OFF";
  }
  if (el.metaAutoTrackerFluxBtn) {
    const fluxEnabled = Boolean(metaTempoTrackers.flux);
    el.metaAutoTrackerFluxBtn.classList.toggle("active", fluxEnabled);
    el.metaAutoTrackerFluxBtn.textContent = fluxEnabled
      ? "FLUX ON"
      : "FLUX OFF";
  }
  if (el.metaAutoHueWizBaselineBlendStat) {
    const trackersForStatus = ui.metaAutoTempoTrackersAuto
      ? metaTempoTrackersActive
      : metaTempoTrackers;
    const trackerLabels = [];
    if (trackersForStatus.baseline) trackerLabels.push("BASELINE+DRUMS");
    if (trackersForStatus.peaks) trackerLabels.push("PEAKS");
    if (trackersForStatus.transients) trackerLabels.push("TRANSIENTS");
    if (trackersForStatus.flux) trackerLabels.push("FLUX");
    const autoWord = ui.metaAutoTempoTrackersAuto ? "AUTO-CANDIDATES" : "HARD-TOGGLE";
    if (trackerLabels.length && ui.metaAutoEnabled) {
      el.metaAutoHueWizBaselineBlendStat.textContent = `DOMINANT FACTORS: ${trackerLabels.join("+")} | HZ ACTIVE (${autoWord})`;
    } else if (trackerLabels.length) {
      el.metaAutoHueWizBaselineBlendStat.textContent = `DOMINANT FACTORS: ${trackerLabels.join("+")} | HZ ARMED (${autoWord})`;
    } else {
      el.metaAutoHueWizBaselineBlendStat.textContent = ui.metaAutoTempoTrackersAuto
        ? "DOMINANT FACTORS: NONE SELECTED (AUTO ON, USE BUILD CANDIDATES)"
        : "DOMINANT FACTORS: NONE (MANUAL TOGGLE MODE)";
    }
  }
  const metaGenreLabel = String(ui.metaAutoGenre || "auto").toUpperCase();
  const metaReasonLabel = String(ui.metaAutoReason || "").toUpperCase();
  const metaHzNum = Number(ui.metaAutoHz);
  const metaHzLabel = Number.isFinite(metaHzNum)
    ? `${metaHzNum.toFixed(1).replace(/\.0$/, "")}HZ`
    : "";
  el.metaAutoStat.textContent = ui.metaAutoEnabled
    ? `ON ${metaGenreLabel}${metaReasonLabel ? ` ${metaReasonLabel}` : ""}${metaHzLabel ? ` ${metaHzLabel}` : ""}`.trim()
    : "OFF";
  el.flowStat.textContent = `${Number(ui.flowIntensity || 1).toFixed(2)}x`;
  if (el.dropBtn) {
    const dropEnabled = Boolean(ui.audioReactivityMap?.dropEnabled);
    el.dropBtn.disabled = !dropEnabled;
    el.dropBtn.title = dropEnabled
      ? "Trigger one manual drop hit event for testing visuals."
      : "Drop trigger disabled. Enable DROP REACTIVE in audio reactivity map.";
  }

  autoProfileButtons.forEach(btn => {
    btn.classList.toggle("active", btn.dataset.autoProfile === ui.autoProfile);
  });

  audioReactivityButtons.forEach(btn => {
    btn.classList.toggle("active", btn.dataset.audioReactivity === ui.audioReactivityPreset);
  });

  audioQuickPresetButtons.forEach(btn => {
    btn.classList.toggle("active", btn.dataset.audioQuick === ui.audioQuickProfile);
  });

  limiterPresetButtons.forEach(btn => {
    btn.classList.toggle("active", btn.dataset.limiterPreset === ui.limiterPreset);
  });

  if (el.ocAutoBtn) {
    const autoHzNum = Number(ui.overclockAutoHz);
    const autoHzLabel = Number.isFinite(autoHzNum)
      ? autoHzNum.toFixed(1).replace(/\.0$/, "")
      : "";
    el.ocAutoBtn.classList.toggle("active", Boolean(ui.overclockAutoEnabled));
    el.ocAutoBtn.textContent = ui.overclockAutoEnabled
      ? `AUTO HZ ${autoHzLabel ? `${autoHzLabel}HZ` : "ON"}`
      : "AUTO HZ (NO META)";
  }
  el.ocLudicrousBtn.classList.toggle("active", ui.overclockLevel === 7);
  if (el.ocDevCluster) {
    el.ocDevCluster.classList.toggle("hidden", !ui.devDebugMode);
  }
  if (el.devToolsPanel) {
    el.devToolsPanel.classList.toggle("hidden", !ui.devDebugMode);
  }
  if (el.devDebugToggleBtn) {
    el.devDebugToggleBtn.classList.toggle("active", ui.devDebugMode);
  }
  if (el.ocDev20Btn) el.ocDev20Btn.classList.toggle("active", ui.overclockLevel === 8);
  if (el.ocDev30Btn) el.ocDev30Btn.classList.toggle("active", ui.overclockLevel === 9);
  if (el.ocDev40Btn) el.ocDev40Btn.classList.toggle("active", ui.overclockLevel === 10);
  if (el.ocDev50Btn) el.ocDev50Btn.classList.toggle("active", ui.overclockLevel === 11);
  if (el.ocDev60Btn) el.ocDev60Btn.classList.toggle("active", ui.overclockLevel === 12);
  el.ocHyperBtn.classList.toggle("active", ui.overclockLevel === 6);
  el.ocInsaneBtn.classList.toggle("active", ui.overclockLevel === 5);
  el.ocExtremeBtn.classList.toggle("active", ui.overclockLevel === 4);
  el.ocUltraBtn.classList.toggle("active", ui.overclockLevel === 3);
  el.ocTurboBtn.classList.toggle("active", ui.overclockLevel === 2);
  el.ocOnBtn.classList.toggle("active", ui.overclockLevel === 1);
  el.ocOffBtn.classList.toggle("active", ui.overclockLevel === 0);

  sceneButtons.forEach(btn => {
    const scene = btn.dataset.scene;
    btn.classList.toggle("active", scene === ui.sceneLock);
  });
  const sceneSyncLabels = getSceneSyncLabelContext();
  const sceneStandalone = String(ui.sceneSyncStrategy || "standalone").trim().toLowerCase() === "standalone";
  if (el.sceneSyncOnBtn) {
    el.sceneSyncOnBtn.classList.toggle("active", !sceneStandalone && Boolean(ui.wizSceneSync));
    el.sceneSyncOnBtn.textContent = sceneSyncLabels.syncButton;
  }
  if (el.sceneSyncOffBtn) {
    el.sceneSyncOffBtn.classList.toggle("active", sceneStandalone || !Boolean(ui.wizSceneSync));
    el.sceneSyncOffBtn.textContent = sceneSyncLabels.desyncButton;
  }
  if (el.sceneSyncStat) {
    el.sceneSyncStat.textContent = (!sceneStandalone && Boolean(ui.wizSceneSync))
      ? sceneSyncLabels.statusSynced
      : sceneSyncLabels.statusDesynced;
  }

  const paletteScope = normalizePaletteControlScopeUi(ui.paletteControlScope, "global");
  const customScopeActive = paletteScope === "custom";
  ui.paletteControlScope = paletteScope;
  if (el.paletteScopeGlobalBtn) {
    el.paletteScopeGlobalBtn.classList.toggle("active", !customScopeActive);
  }
  if (el.paletteScopeCustomBtn) {
    el.paletteScopeCustomBtn.classList.toggle("active", customScopeActive);
  }
  if (el.paletteGlobalPanel) {
    el.paletteGlobalPanel.classList.toggle("isDisabled", customScopeActive);
  }
  if (el.paletteCustomPanel) {
    el.paletteCustomPanel.classList.toggle("hidden", !customScopeActive);
  }
  if (el.paletteModeNotice) {
    const globalNotice = String(ui.paletteGlobalModeNotice || "").trim();
    const brandNotice = String(ui.paletteBrandModeNotices?.[ui.paletteCustomBrand] || "").trim();
    el.paletteModeNotice.textContent = customScopeActive ? brandNotice : globalNotice;
  }
  paletteCustomBrandButtons.forEach(btn => {
    const brand = normalizePaletteBrandUi(btn.dataset.paletteCustomBrand);
    const active = brand === normalizePaletteBrandUi(ui.paletteCustomBrand);
    btn.classList.toggle("active", active);
    btn.disabled = !customScopeActive;
  });
  if (el.paletteBrandMenus) {
    const cards = Array.from(el.paletteBrandMenus.querySelectorAll("[data-palette-brand-card]"));
    const availableBrands = cards
      .map(card => normalizePaletteBrandUi(card.dataset.paletteBrandCard))
      .filter(Boolean);
    if (customScopeActive && availableBrands.length && !availableBrands.includes(ui.paletteCustomBrand)) {
      ui.paletteCustomBrand = availableBrands[0];
    }
    cards.forEach(card => {
      const brand = normalizePaletteBrandUi(card.dataset.paletteBrandCard);
      const visible = !customScopeActive || brand === ui.paletteCustomBrand;
      card.classList.toggle("hidden", !visible);
    });
  }

  paletteCountButtons.forEach(btn => {
    const count = normalizePaletteColorCountUi(btn.dataset.paletteCount, ui.paletteColorsPerFamily || 3);
    btn.classList.toggle("active", count === ui.paletteColorsPerFamily);
  });
  paletteVividnessButtons.forEach(btn => {
    const level = normalizePaletteVividnessUi(btn.dataset.paletteVividness, ui.paletteVividness || 2);
    btn.classList.toggle("active", level === normalizePaletteVividnessUi(ui.paletteVividness, 2));
  });
  palettePresetButtons.forEach(btn => {
    const key = String(btn.dataset.palettePreset || "").trim().toLowerCase();
    btn.classList.toggle("active", isPalettePresetActiveUi(key));
  });
  getPaletteFamilyButtons().forEach(btn => {
    const key = String(btn.dataset.paletteFamily || "").trim().toLowerCase();
    btn.classList.toggle("active", normalizePaletteFamiliesUi(ui.paletteFamilies).includes(key));
  });
  paletteDisorderButtons.forEach(btn => {
    const disorder = String(btn.dataset.paletteDisorder || "").toLowerCase() === "true";
    btn.classList.toggle("active", disorder === Boolean(ui.paletteDisorder));
  });
  paletteCycleModeButtons.forEach(btn => {
    const mode = normalizePaletteCycleModeUi(btn.dataset.paletteCycleMode, "on_trigger");
    btn.classList.toggle("active", mode === normalizePaletteCycleModeUi(ui.paletteCycleMode, "on_trigger"));
  });
  paletteBeatLockButtons.forEach(btn => {
    const enabled = String(btn.dataset.paletteBeatLock || "").trim().toLowerCase() === "true";
    btn.classList.toggle("active", enabled === (ui.paletteBeatLock === true));
  });
  paletteBrightnessModeButtons.forEach(btn => {
    const mode = normalizePaletteBrightnessModeUi(btn.dataset.paletteBrightnessMode, "legacy");
    btn.classList.toggle("active", mode === normalizePaletteBrightnessModeUi(ui.paletteBrightnessMode, "legacy"));
  });
  paletteSpectrumModeButtons.forEach(btn => {
    const mode = normalizePaletteSpectrumMapModeUi(btn.dataset.paletteSpectrumMode, "auto");
    btn.classList.toggle("active", mode === normalizePaletteSpectrumMapModeUi(ui.paletteSpectrumMapMode, "auto"));
  });
  syncPaletteDisorderAggressionSliderUi();
  syncPaletteTimedIntervalSliderUi();
  syncPaletteBeatLockGraceSliderUi();
  syncPaletteReactiveMarginSliderUi();
  syncPaletteBrightnessFollowSliderUi();
  syncPaletteSpectrumFeatureSelectorsUi();
  const brightnessMode = normalizePaletteBrightnessModeUi(ui.paletteBrightnessMode, "legacy");
  if (el.paletteBrightnessFollowWrap) {
    el.paletteBrightnessFollowWrap.classList.toggle("hidden", brightnessMode !== "test");
  }
  if (el.paletteBrightnessFollowAmount) {
    el.paletteBrightnessFollowAmount.disabled = brightnessMode !== "test";
  }
  const globalCycleMode = normalizePaletteCycleModeUi(ui.paletteCycleMode, "on_trigger");
  const showTimed = globalCycleMode === "timed_cycle";
  const showReactive = globalCycleMode === "reactive_shift";
  const showSpectrum = globalCycleMode === "spectrum_mapper";
  if (el.paletteTimedControls) {
    el.paletteTimedControls.classList.toggle("hidden", !showTimed);
  }
  if (el.paletteReactiveControls) {
    el.paletteReactiveControls.classList.toggle("hidden", !showReactive);
  }
  if (el.paletteSpectrumControls) {
    el.paletteSpectrumControls.classList.toggle("hidden", !showSpectrum);
  }
  const canEditSpectrumMap = showSpectrum && normalizePaletteSpectrumMapModeUi(ui.paletteSpectrumMapMode, "auto") === "manual";
  getPaletteSpectrumFeatureSelectors().forEach(node => {
    if (!node) return;
    node.disabled = !canEditSpectrumMap;
  });
  if (el.paletteStat) {
    el.paletteStat.textContent = `${getPaletteFamiliesLabelUi(ui.paletteFamilies)} x${ui.paletteColorsPerFamily} | ${formatPaletteVividnessLabelUi(ui.paletteVividness)}`;
  }
  if (el.paletteOrderStat) {
    el.paletteOrderStat.textContent = ui.paletteDisorder
      ? `DISORDER ${Math.round((ui.paletteDisorderAggression || 0) * 100)}%`
      : "ORDERED";
  }

  el.sceneLockStat.textContent = ui.sceneLock === "auto"
    ? "AUTO"
    : ui.sceneLock.toUpperCase();
  updateAudioReactivityPolicyUi();
  updateReactorRiskNotice();
}

function updateFixtures(f) {
  const summary = f && f.summary ? f.summary : {};
  const routes = f?.routes || summary.routes || {};
  const snapshotHasFixturesArray = Array.isArray(f?.fixtures);
  const fixtures = Array.isArray(f?.fixtures)
    ? f.fixtures
    : (Array.isArray(ui.fixturesCatalog) ? ui.fixturesCatalog.slice() : []);
  const standalone = Array.isArray(f?.standalone)
    ? f.standalone
    : (Array.isArray(ui.standaloneFixtures) ? ui.standaloneFixtures.slice() : []);
  ui.fixtureModBrands = collectFixtureModBrandsFromSnapshot(summary, fixtures);
  ui.sceneSyncActiveBrands = collectActiveSceneSyncBrands(fixtures);
  syncFixtureBrandOptions();
  updateConnectivityCache(f?.connectivity || []);
  ui.connectivitySummary = f?.connectivitySummary || null;

  el.fixHue.textContent = String(summary.hue ?? 0);
  el.fixWiz.textContent = String(summary.wiz ?? 0);
  el.fixHueReady.textContent = String(summary.hueReady ?? 0);
  el.fixWizReady.textContent = String(summary.wizReady ?? 0);
  ui.engineReadyTargets = Number(summary.hueEngineReady ?? summary.hueReady ?? 0) +
    Number(summary.wizEngineReady ?? summary.wizReady ?? 0);
  ui.engineModeTargets = Number(summary.hueEngine ?? 0) + Number(summary.wizEngine ?? 0);
  el.routeHue.textContent = routes.HUE_STATE || "-";
  el.routeWiz.textContent = routes.WIZ_PULSE || "-";
  el.routeTwitchHue.textContent = routes.TWITCH_HUE || "-";
  el.routeTwitchWiz.textContent = routes.TWITCH_WIZ || "-";
  el.routeHueInput.value = routes.HUE_STATE || "hue";
  el.routeWizInput.value = routes.WIZ_PULSE || "wiz";
  el.routeTwitchHueInput.value = routes.TWITCH_HUE || "hue";
  el.routeTwitchWizInput.value = routes.TWITCH_WIZ || "wiz";
  el.cfgVer.textContent = String(summary.version ?? 0);
  el.cfgAt.textContent = summary.loadedAt
    ? new Date(summary.loadedAt).toLocaleTimeString()
    : "-";

  applyFixtureCatalogToUi(fixtures);
  renderPaletteBrandMenus({ reason: "fixtures_update" });
  renderStandaloneFixtures(standalone, { preserveDraft: true });
  ui.fixturesSnapshotLoaded = snapshotHasFixturesArray || fixtures.length > 0;
}

function detectAudioQuickProfile(config = {}) {
  const sampleRate = Number(config.sampleRate);
  const framesPerBuffer = Number(config.framesPerBuffer ?? config.frames);
  const profileName = Object.keys(AUDIO_QUICK_PROFILES).find(name => {
    const profile = AUDIO_QUICK_PROFILES[name];
    return (
      Number(profile.sampleRate) === sampleRate &&
      Number(profile.framesPerBuffer) === framesPerBuffer
    );
  });
  return profileName || "";
}

const AUDIO_QUICK_TUNE_BOUNDS = Object.freeze({
  gain: Object.freeze({ min: 0.35, max: 2.5 }),
  noiseFloorMin: Object.freeze({ min: 0.00005, max: 0.02 }),
  autoLevelTargetRms: Object.freeze({ min: 0.008, max: 0.12 }),
  autoLevelGate: Object.freeze({ min: 0.001, max: 0.03 }),
  limiterThreshold: Object.freeze({ min: 0.55, max: 0.96 })
});

const AUDIO_QUICK_TUNE_STAGES = Object.freeze({
  profile: Object.freeze([
    Object.freeze({
      pct: 0,
      label: "QUIET SOURCE",
      values: Object.freeze({ gain: 26, noiseFloorMin: 18, autoLevelTargetRms: 28, autoLevelGate: 20, limiterControl: 34 })
    }),
    Object.freeze({
      pct: 25,
      label: "CALM",
      values: Object.freeze({ gain: 33, noiseFloorMin: 28, autoLevelTargetRms: 31, autoLevelGate: 24, limiterControl: 40 })
    }),
    Object.freeze({
      pct: 50,
      label: "BALANCED",
      values: Object.freeze({ gain: 40, noiseFloorMin: 36, autoLevelTargetRms: 36, autoLevelGate: 30, limiterControl: 48 })
    }),
    Object.freeze({
      pct: 75,
      label: "HOT SOURCE",
      values: Object.freeze({ gain: 52, noiseFloorMin: 54, autoLevelTargetRms: 42, autoLevelGate: 42, limiterControl: 62 })
    }),
    Object.freeze({
      pct: 100,
      label: "LOUD ROOM",
      values: Object.freeze({ gain: 64, noiseFloorMin: 72, autoLevelTargetRms: 50, autoLevelGate: 58, limiterControl: 76 })
    })
  ]),
  gain: Object.freeze([
    Object.freeze({ pct: 20, label: "CALM" }),
    Object.freeze({ pct: 35, label: "BALANCED" }),
    Object.freeze({ pct: 50, label: "PUNCHY" }),
    Object.freeze({ pct: 65, label: "HOT" }),
    Object.freeze({ pct: 80, label: "AGGRESSIVE" })
  ]),
  noiseFloorMin: Object.freeze([
    Object.freeze({ pct: 12, label: "OPEN GATE" }),
    Object.freeze({ pct: 28, label: "LIGHT ROOM" }),
    Object.freeze({ pct: 42, label: "CLEAN ROOM" }),
    Object.freeze({ pct: 58, label: "NOISY ROOM" }),
    Object.freeze({ pct: 74, label: "STRICT GATE" })
  ]),
  autoLevelTargetRms: Object.freeze([
    Object.freeze({ pct: 20, label: "SOFT BOOST" }),
    Object.freeze({ pct: 34, label: "BALANCED" }),
    Object.freeze({ pct: 50, label: "STRONG BOOST" }),
    Object.freeze({ pct: 68, label: "HARD BOOST" })
  ]),
  autoLevelGate: Object.freeze([
    Object.freeze({ pct: 18, label: "ALWAYS READY" }),
    Object.freeze({ pct: 32, label: "NORMAL" }),
    Object.freeze({ pct: 46, label: "ROOM SAFE" }),
    Object.freeze({ pct: 62, label: "STRICT" })
  ]),
  limiterControl: Object.freeze([
    Object.freeze({ pct: 24, label: "SOFT LIMIT" }),
    Object.freeze({ pct: 42, label: "BALANCED" }),
    Object.freeze({ pct: 58, label: "HARD LIMIT" }),
    Object.freeze({ pct: 74, label: "MAX CONTROL" })
  ])
});

function clamp01Ui(value, fallback = 0) {
  const n = Number(value);
  if (!Number.isFinite(n)) return fallback;
  return Math.max(0, Math.min(1, n));
}

function linearToPctUi(value, min, max, fallbackPct = 0) {
  const range = Number(max) - Number(min);
  if (!(range > 0)) return fallbackPct;
  return clamp01Ui((Number(value) - Number(min)) / range, fallbackPct);
}

function pctToLinearUi(pct, min, max, fallback = min) {
  const safePct = clamp01Ui(pct, 0);
  const range = Number(max) - Number(min);
  if (!(range > 0)) return Number(fallback);
  return Number(min) + (range * safePct);
}

function logToPctUi(value, min, max, fallbackPct = 0) {
  const safeMin = Math.max(1e-9, Number(min));
  const safeMax = Math.max(safeMin + 1e-9, Number(max));
  const safeValue = Math.max(safeMin, Math.min(safeMax, Number(value)));
  const logMin = Math.log10(safeMin);
  const logMax = Math.log10(safeMax);
  const denom = logMax - logMin;
  if (!(denom > 0)) return fallbackPct;
  return clamp01Ui((Math.log10(safeValue) - logMin) / denom, fallbackPct);
}

function pctToLogUi(pct, min, max, fallback = min) {
  const safeMin = Math.max(1e-9, Number(min));
  const safeMax = Math.max(safeMin + 1e-9, Number(max));
  const safePct = clamp01Ui(pct, 0);
  const logMin = Math.log10(safeMin);
  const logMax = Math.log10(safeMax);
  return 10 ** (logMin + ((logMax - logMin) * safePct));
}

function getAudioQuickTuneSliderMap() {
  return {
    gain: el.aQuickGain,
    noiseFloorMin: el.aQuickNoiseGate,
    autoLevelTargetRms: el.aQuickAutoTarget,
    autoLevelGate: el.aQuickAutoGate,
    limiterControl: el.aQuickLimiter
  };
}

function isAudioQuickSnapEnabled() {
  return el.aQuickSnapStages ? el.aQuickSnapStages.checked === true : true;
}

function mapLimiterThresholdToControlPct(value = 0.82) {
  return 1 - linearToPctUi(
    value,
    AUDIO_QUICK_TUNE_BOUNDS.limiterThreshold.min,
    AUDIO_QUICK_TUNE_BOUNDS.limiterThreshold.max,
    0.34
  );
}

function mapControlPctToLimiterThreshold(pct = 0.34) {
  return pctToLinearUi(
    1 - clamp01Ui(pct, 0.34),
    AUDIO_QUICK_TUNE_BOUNDS.limiterThreshold.min,
    AUDIO_QUICK_TUNE_BOUNDS.limiterThreshold.max,
    0.82
  );
}

function getNearestAudioQuickTuneStage(key = "", pct = 0) {
  const list = Array.isArray(AUDIO_QUICK_TUNE_STAGES[key]) ? AUDIO_QUICK_TUNE_STAGES[key] : [];
  if (!list.length) return null;
  const target = clamp01Ui(pct, 0) * 100;
  let best = list[0];
  let bestDiff = Math.abs(target - Number(best.pct || 0));
  for (let i = 1; i < list.length; i += 1) {
    const stage = list[i];
    const diff = Math.abs(target - Number(stage.pct || 0));
    if (diff < bestDiff) {
      best = stage;
      bestDiff = diff;
    }
  }
  return best;
}

function normalizeAudioQuickTunePct(key = "", pct = 0, options = {}) {
  const clamped = clamp01Ui(pct, 0);
  if (options.allowSnap === false || !isAudioQuickSnapEnabled()) return clamped;
  const stage = getNearestAudioQuickTuneStage(key, clamped);
  if (!stage) return clamped;
  return clamp01Ui(Number(stage.pct || 0) / 100, clamped);
}

function setAudioQuickTuneStageText(key = "", pct = 0, options = {}) {
  const stageNodeByKey = {
    profile: el.aQuickProfileStage,
    gain: el.aQuickGainStage,
    noiseFloorMin: el.aQuickNoiseGateStage,
    autoLevelTargetRms: el.aQuickAutoTargetStage,
    autoLevelGate: el.aQuickAutoGateStage,
    limiterControl: el.aQuickLimiterStage
  };
  const node = stageNodeByKey[key];
  if (!node) return;
  const custom = options.custom === true;
  if (custom) {
    node.textContent = "STAGE: CUSTOM";
    return;
  }
  const stage = getNearestAudioQuickTuneStage(key, pct);
  node.textContent = stage?.label ? `STAGE: ${stage.label}` : "STAGE: CUSTOM";
}

function getAudioQuickTuneProfileInterpolatedPcts(profilePct = 0.5) {
  const points = AUDIO_QUICK_TUNE_STAGES.profile;
  const target = clamp01Ui(profilePct, 0.5) * 100;
  let lower = points[0];
  let upper = points[points.length - 1];
  for (let i = 0; i < points.length; i += 1) {
    const point = points[i];
    if (Number(point.pct) <= target) lower = point;
    if (Number(point.pct) >= target) {
      upper = point;
      break;
    }
  }
  if (Number(upper.pct) <= Number(lower.pct)) {
    return { ...lower.values };
  }
  const t = (target - Number(lower.pct)) / (Number(upper.pct) - Number(lower.pct));
  return {
    gain: Number(lower.values.gain) + ((Number(upper.values.gain) - Number(lower.values.gain)) * t),
    noiseFloorMin: Number(lower.values.noiseFloorMin) + ((Number(upper.values.noiseFloorMin) - Number(lower.values.noiseFloorMin)) * t),
    autoLevelTargetRms: Number(lower.values.autoLevelTargetRms) + ((Number(upper.values.autoLevelTargetRms) - Number(lower.values.autoLevelTargetRms)) * t),
    autoLevelGate: Number(lower.values.autoLevelGate) + ((Number(upper.values.autoLevelGate) - Number(lower.values.autoLevelGate)) * t),
    limiterControl: Number(lower.values.limiterControl) + ((Number(upper.values.limiterControl) - Number(lower.values.limiterControl)) * t)
  };
}

function syncAudioQuickProfileSliderFromPcts(pcts = {}) {
  if (!el.aQuickProfileMix || !el.aQuickProfileMixVal) return;
  const points = AUDIO_QUICK_TUNE_STAGES.profile;
  let best = points[0];
  let bestDist = Number.POSITIVE_INFINITY;
  for (const point of points) {
    const dist =
      Math.abs((Number(pcts.gain || 0) * 100) - Number(point.values.gain || 0)) +
      Math.abs((Number(pcts.noiseFloorMin || 0) * 100) - Number(point.values.noiseFloorMin || 0)) +
      Math.abs((Number(pcts.autoLevelTargetRms || 0) * 100) - Number(point.values.autoLevelTargetRms || 0)) +
      Math.abs((Number(pcts.autoLevelGate || 0) * 100) - Number(point.values.autoLevelGate || 0)) +
      Math.abs((Number(pcts.limiterControl || 0) * 100) - Number(point.values.limiterControl || 0));
    if (dist < bestDist) {
      bestDist = dist;
      best = point;
    }
  }
  const isCustom = bestDist > 30;
  const profilePct = isCustom
    ? clamp01Ui(Number(el.aQuickProfileMix.value) / 100, Number(best.pct) / 100)
    : clamp01Ui(Number(best.pct) / 100, 0.5);
  if (!isCustom) {
    el.aQuickProfileMix.value = String(Math.round(profilePct * 100));
  }
  el.aQuickProfileMixVal.textContent = `${Math.round(profilePct * 100)}%`;
  setAudioQuickTuneStageText("profile", profilePct, { custom: isCustom });
}

function syncAudioQuickTuningFromInputs() {
  if (!el.aQuickGain || !el.aQuickNoiseGate || !el.aQuickAutoTarget || !el.aQuickAutoGate || !el.aQuickLimiter) return;

  const gain = clampNumber(Number(el.aGain?.value), AUDIO_QUICK_TUNE_BOUNDS.gain.min, AUDIO_QUICK_TUNE_BOUNDS.gain.max, 1);
  const noiseFloorMin = clampNumber(
    Number(el.aNoise?.value),
    AUDIO_QUICK_TUNE_BOUNDS.noiseFloorMin.min,
    AUDIO_QUICK_TUNE_BOUNDS.noiseFloorMin.max,
    0.00045
  );
  const autoTarget = clampNumber(
    Number(el.aAutoLevelTarget?.value),
    AUDIO_QUICK_TUNE_BOUNDS.autoLevelTargetRms.min,
    AUDIO_QUICK_TUNE_BOUNDS.autoLevelTargetRms.max,
    0.028
  );
  const autoGate = clampNumber(
    Number(el.aAutoLevelGate?.value),
    AUDIO_QUICK_TUNE_BOUNDS.autoLevelGate.min,
    AUDIO_QUICK_TUNE_BOUNDS.autoLevelGate.max,
    0.007
  );
  const limiter = clampNumber(
    Number(el.aLimiterThreshold?.value),
    AUDIO_QUICK_TUNE_BOUNDS.limiterThreshold.min,
    AUDIO_QUICK_TUNE_BOUNDS.limiterThreshold.max,
    0.82
  );

  const gainPct = linearToPctUi(gain, AUDIO_QUICK_TUNE_BOUNDS.gain.min, AUDIO_QUICK_TUNE_BOUNDS.gain.max, 0.33);
  const noisePct = logToPctUi(
    noiseFloorMin,
    AUDIO_QUICK_TUNE_BOUNDS.noiseFloorMin.min,
    AUDIO_QUICK_TUNE_BOUNDS.noiseFloorMin.max,
    0.28
  );
  const autoTargetPct = linearToPctUi(
    autoTarget,
    AUDIO_QUICK_TUNE_BOUNDS.autoLevelTargetRms.min,
    AUDIO_QUICK_TUNE_BOUNDS.autoLevelTargetRms.max,
    0.31
  );
  const autoGatePct = linearToPctUi(
    autoGate,
    AUDIO_QUICK_TUNE_BOUNDS.autoLevelGate.min,
    AUDIO_QUICK_TUNE_BOUNDS.autoLevelGate.max,
    0.21
  );
  const limiterPct = mapLimiterThresholdToControlPct(limiter);

  el.aQuickGain.value = String(Math.round(gainPct * 100));
  el.aQuickNoiseGate.value = String(Math.round(noisePct * 100));
  el.aQuickAutoTarget.value = String(Math.round(autoTargetPct * 100));
  el.aQuickAutoGate.value = String(Math.round(autoGatePct * 100));
  el.aQuickLimiter.value = String(Math.round(limiterPct * 100));

  if (el.aQuickGainVal) el.aQuickGainVal.textContent = `${gain.toFixed(2)}x`;
  if (el.aQuickNoiseGateVal) el.aQuickNoiseGateVal.textContent = noiseFloorMin.toFixed(5);
  if (el.aQuickAutoTargetVal) el.aQuickAutoTargetVal.textContent = autoTarget.toFixed(3);
  if (el.aQuickAutoGateVal) el.aQuickAutoGateVal.textContent = autoGate.toFixed(3);
  if (el.aQuickLimiterVal) el.aQuickLimiterVal.textContent = `${Math.round(limiterPct * 100)}%`;

  setAudioQuickTuneStageText("gain", gainPct);
  setAudioQuickTuneStageText("noiseFloorMin", noisePct);
  setAudioQuickTuneStageText("autoLevelTargetRms", autoTargetPct);
  setAudioQuickTuneStageText("autoLevelGate", autoGatePct);
  setAudioQuickTuneStageText("limiterControl", limiterPct);
  syncAudioQuickProfileSliderFromPcts({
    gain: gainPct,
    noiseFloorMin: noisePct,
    autoLevelTargetRms: autoTargetPct,
    autoLevelGate: autoGatePct,
    limiterControl: limiterPct
  });
}

function applyAudioQuickTuningSlidersToInputs() {
  if (!el.aQuickGain || !el.aQuickNoiseGate || !el.aQuickAutoTarget || !el.aQuickAutoGate || !el.aQuickLimiter) return;

  let gainPct = normalizeAudioQuickTunePct("gain", Number(el.aQuickGain.value) / 100);
  let noisePct = normalizeAudioQuickTunePct("noiseFloorMin", Number(el.aQuickNoiseGate.value) / 100);
  let autoTargetPct = normalizeAudioQuickTunePct("autoLevelTargetRms", Number(el.aQuickAutoTarget.value) / 100);
  let autoGatePct = normalizeAudioQuickTunePct("autoLevelGate", Number(el.aQuickAutoGate.value) / 100);
  let limiterPct = normalizeAudioQuickTunePct("limiterControl", Number(el.aQuickLimiter.value) / 100);

  el.aQuickGain.value = String(Math.round(gainPct * 100));
  el.aQuickNoiseGate.value = String(Math.round(noisePct * 100));
  el.aQuickAutoTarget.value = String(Math.round(autoTargetPct * 100));
  el.aQuickAutoGate.value = String(Math.round(autoGatePct * 100));
  el.aQuickLimiter.value = String(Math.round(limiterPct * 100));

  const gain = pctToLinearUi(gainPct, AUDIO_QUICK_TUNE_BOUNDS.gain.min, AUDIO_QUICK_TUNE_BOUNDS.gain.max, 1);
  const noiseFloorMin = pctToLogUi(
    noisePct,
    AUDIO_QUICK_TUNE_BOUNDS.noiseFloorMin.min,
    AUDIO_QUICK_TUNE_BOUNDS.noiseFloorMin.max,
    0.00045
  );
  const autoTarget = pctToLinearUi(
    autoTargetPct,
    AUDIO_QUICK_TUNE_BOUNDS.autoLevelTargetRms.min,
    AUDIO_QUICK_TUNE_BOUNDS.autoLevelTargetRms.max,
    0.028
  );
  const autoGate = pctToLinearUi(
    autoGatePct,
    AUDIO_QUICK_TUNE_BOUNDS.autoLevelGate.min,
    AUDIO_QUICK_TUNE_BOUNDS.autoLevelGate.max,
    0.007
  );
  const limiter = mapControlPctToLimiterThreshold(limiterPct);

  if (el.aGain) el.aGain.value = gain.toFixed(2);
  if (el.aNoise) el.aNoise.value = noiseFloorMin.toFixed(5);
  if (el.aAutoLevelTarget) el.aAutoLevelTarget.value = autoTarget.toFixed(3);
  if (el.aAutoLevelGate) el.aAutoLevelGate.value = autoGate.toFixed(3);
  if (el.aLimiterThreshold) el.aLimiterThreshold.value = limiter.toFixed(2);

  syncAudioQuickTuningFromInputs();
}

function applyAudioQuickProfileMixSliderToSliders() {
  if (!el.aQuickProfileMix) return;
  let profilePct = normalizeAudioQuickTunePct("profile", Number(el.aQuickProfileMix.value) / 100);
  el.aQuickProfileMix.value = String(Math.round(profilePct * 100));
  if (el.aQuickProfileMixVal) el.aQuickProfileMixVal.textContent = `${Math.round(profilePct * 100)}%`;
  setAudioQuickTuneStageText("profile", profilePct);

  const sliderMap = getAudioQuickTuneSliderMap();
  const profilePcts = getAudioQuickTuneProfileInterpolatedPcts(profilePct);
  for (const [key, node] of Object.entries(sliderMap)) {
    if (!node) continue;
    const nextPct = normalizeAudioQuickTunePct(key, Number(profilePcts[key] || 0) / 100);
    node.value = String(Math.round(nextPct * 100));
  }
  applyAudioQuickTuningSlidersToInputs();
}

function resetAudioQuickTuningToDefaults() {
  if (el.aGain) el.aGain.value = Number(AUDIO_CONFIG_DEFAULTS.outputGain || 1).toFixed(2);
  if (el.aNoise) el.aNoise.value = Number(AUDIO_CONFIG_DEFAULTS.noiseFloorMin || 0.00045).toFixed(5);
  if (el.aAutoLevelTarget) el.aAutoLevelTarget.value = Number(AUDIO_CONFIG_DEFAULTS.autoLevelTargetRms || 0.028).toFixed(3);
  if (el.aAutoLevelGate) el.aAutoLevelGate.value = Number(AUDIO_CONFIG_DEFAULTS.autoLevelGate || 0.007).toFixed(3);
  if (el.aLimiterThreshold) el.aLimiterThreshold.value = Number(AUDIO_CONFIG_DEFAULTS.limiterThreshold || 0.82).toFixed(2);
  syncAudioQuickTuningFromInputs();
}

function syncAudioQuickPresetButtons() {
  const profileName = detectAudioQuickProfile({
    sampleRate: Number(el.aSampleRate?.value),
    framesPerBuffer: Number(el.aFrames?.value)
  });
  ui.audioQuickProfile = profileName || "";
  audioQuickPresetButtons.forEach(btn => {
    btn.classList.toggle("active", btn.dataset.audioQuick === profileName);
  });
}

function applyAudioQuickProfile(name) {
  const profile = AUDIO_QUICK_PROFILES[String(name || "").trim().toLowerCase()];
  if (!profile) return false;
  el.aSampleRate.value = String(profile.sampleRate);
  el.aFrames.value = String(profile.framesPerBuffer);
  syncAudioQuickPresetButtons();
  return true;
}

function normalizeAudioDeviceListUi(value, fallback = []) {
  const source = Array.isArray(value)
    ? value
    : String(value || "")
      .split(/[\r\n,;]+/g)
      .map(item => String(item || "").trim());
  const out = [];
  for (const item of source) {
    const text = String(item || "").trim();
    if (!text) continue;
    if (out.includes(text)) continue;
    out.push(text);
    if (out.length >= 6) break;
  }
  if (out.length) return out;
  const fallbackList = Array.isArray(fallback)
    ? fallback
    : [];
  if (!fallbackList.length) return [];
  return normalizeAudioDeviceListUi(fallbackList, []);
}

function formatAudioDeviceListUi(list = []) {
  return normalizeAudioDeviceListUi(list, []).join("\n");
}

function normalizeAudioAppNameUi(value) {
  const raw = String(value || "").trim();
  if (!raw) return "";
  return raw.slice(0, 128);
}

function normalizeAudioAppTokenUi(value) {
  const appName = normalizeAudioAppNameUi(value).toLowerCase();
  if (!appName) return "";
  return appName.endsWith(".exe") ? appName.slice(0, -4) : appName;
}

function getAudioSelectableAppsUi() {
  const apps = Array.isArray(ui.audioRunningApps) ? ui.audioRunningApps : [];
  if (ui.audioAppsShowAll === true) return apps;
  const filtered = apps.filter(app => {
    if (app?.audioCapable === true) return true;
    if (app?.likelyAudio === true) return true;
    if (app?.hasWindow === true) return true;
    if (Array.isArray(app?.windowTitles) && app.windowTitles.length > 0) return true;
    return false;
  });
  return filtered.length ? filtered : apps;
}

function updateAudioAppsFilterHintUi() {
  if (!el.aAppsFilterHint) return;
  const totalApps = Array.isArray(ui.audioRunningApps) ? ui.audioRunningApps.length : 0;
  const visibleApps = getAudioSelectableAppsUi().length;
  const source = String(ui.audioAppHintMeta?.source || "").trim().toLowerCase();
  const sourceText = source === "proctap_audio_processes" ? "audio-probe" : "window-fallback";
  const audioCapable = Array.isArray(ui.audioRunningApps)
    ? ui.audioRunningApps.filter(app => app?.audioCapable === true).length
    : 0;

  if (ui.audioAppsShowAll === true) {
    el.aAppsFilterHint.textContent = `APP LIST MODE: all processes (${visibleApps})`;
    return;
  }
  if (audioCapable > 0) {
    el.aAppsFilterHint.textContent = `APP LIST MODE: audio-capable (${visibleApps}/${totalApps}) via ${sourceText}`;
    return;
  }
  el.aAppsFilterHint.textContent = `APP LIST MODE: likely audio apps (${visibleApps}/${totalApps}) via ${sourceText}`;
}

function syncAudioRoutingComplexityUi() {
  const simpleMode = ui.audioSimpleRoutingMode !== false;
  if (el.aIsoSimpleMode) el.aIsoSimpleMode.checked = simpleMode;
  document.querySelectorAll(".audioIsoAdvanced").forEach(node => {
    node.classList.toggle("hidden", simpleMode);
  });
}

function setAudioAppSelectOptions(selectNode, selectedValue = "") {
  if (!selectNode) return;
  const selected = normalizeAudioAppNameUi(selectedValue);
  const apps = getAudioSelectableAppsUi();
  const options = [{ value: "", label: "NONE" }];
  for (const app of apps) {
    const appName = normalizeAudioAppNameUi(app?.displayName || app?.app || app?.processName || "");
    if (!appName) continue;
    const instances = Number(app?.instances || 0);
    const labelBase = instances > 1 ? `${appName} (${instances})` : appName;
    const suffix = ui.audioAppsShowAll === true && app?.audioCapable !== true ? " [other]" : "";
    const label = `${labelBase}${suffix}`;
    options.push({ value: appName, label });
  }
  if (selected && !options.some(option => option.value.toLowerCase() === selected.toLowerCase())) {
    options.push({ value: selected, label: `${selected} (configured)` });
  }
  selectNode.innerHTML = "";
  for (const option of options) {
    const node = document.createElement("option");
    node.value = option.value;
    node.textContent = option.label;
    if (selected && String(option.value).toLowerCase() === selected.toLowerCase()) {
      node.selected = true;
    }
    selectNode.appendChild(node);
  }
}

function updateAudioAppIsolationStatusText(text = "") {
  const line = String(text || "").trim() || "App source scan idle.";
  if (el.aAppIsolationStatus) el.aAppIsolationStatus.value = line;
  if (el.liveAudioAppSearchStat) el.liveAudioAppSearchStat.value = line;
}

function renderAudioOptionalToolsBanner() {
  if (!el.aOptionalToolsBanner || !el.aOptionalToolsBadge || !el.aOptionalToolsText) return;
  const status = ui.audioOptionalToolsStatus && typeof ui.audioOptionalToolsStatus === "object"
    ? ui.audioOptionalToolsStatus
    : null;
  if (!status || String(status.platform || "").trim() !== "win32") {
    el.aOptionalToolsBanner.classList.add("hidden");
    return;
  }

  const ffmpegOk = status?.checks?.ffmpeg?.available === true;
  const procTapOk = status?.checks?.procTap?.available === true;
  const ready = status.optionalToolsReady === true;
  const needsInstall = status.needsOptionalInstall === true;
  const dismissed = ui.audioOptionalToolsDismissed === true;
  const showBanner = needsInstall || !dismissed;
  if (!showBanner) {
    el.aOptionalToolsBanner.classList.add("hidden");
    return;
  }

  el.aOptionalToolsBanner.classList.remove("hidden", "ok", "warn");
  el.aOptionalToolsBanner.classList.add(ready ? "ok" : "warn");
  el.aOptionalToolsBadge.className = `statusPill ${ready ? "ok" : "warn"}`;
  el.aOptionalToolsBadge.textContent = ready ? "INSTALLED" : "OPTIONAL INSTALL AVAILABLE";

  const scriptName = String(status?.installScript?.fileName || "RaveLink-Bridge-Install-Optional-Audio-Tools.bat");
  if (ready) {
    el.aOptionalToolsText.innerHTML =
      `Advanced app-isolation tools are installed. You can reinstall any time using <code>${escapeHtmlUi(scriptName)}</code>.`;
    return;
  }

  const missingParts = [];
  if (!ffmpegOk) missingParts.push("ffmpeg");
  if (!procTapOk) missingParts.push("process loopback tools");
  const missingWord = missingParts.length ? missingParts.join(" + ") : "optional tools";
  el.aOptionalToolsText.innerHTML =
    `Optional advanced app-isolation needs <b>${escapeHtmlUi(missingWord)}</b>. Install with one click from Start Menu: <b>RaveLink Bridge > Install Optional Audio Tools</b>.`;
}

function openAudioOptionalToolsHelp() {
  const status = ui.audioOptionalToolsStatus && typeof ui.audioOptionalToolsStatus === "object"
    ? ui.audioOptionalToolsStatus
    : null;
  const scriptName = String(status?.installScript?.fileName || "RaveLink-Bridge-Install-Optional-Audio-Tools.bat");
  const startMenuHint = String(
    status?.installScript?.startMenuHint || "Start Menu > RaveLink Bridge > Install Optional Audio Tools"
  );
  const lines = [
    "Optional Audio Tools Setup",
    "",
    "1) Open:",
    `   ${startMenuHint}`,
    "",
    "2) If using portable ZIP, run this file from app folder:",
    `   ${scriptName}`,
    "",
    "3) Wait for installer window to finish, then click REFRESH CFG in AUDIO tab."
  ];
  window.alert(lines.join("\n"));
}

async function loadAudioOptionalToolsStatus() {
  const r = await getJson("/audio/optional-tools/status");
  if (!r || !r.ok || !r.status || typeof r.status !== "object") return false;
  ui.audioOptionalToolsStatus = { ...r.status };
  renderAudioOptionalToolsBanner();
  return true;
}

function applyAudioAppIsolationTelemetry(telemetry = null) {
  const t = telemetry && typeof telemetry === "object" ? telemetry : null;
  const appIso = t && t.appIsolation && typeof t.appIsolation === "object"
    ? t.appIsolation
    : null;
  if (!appIso) return;

  const enabled = appIso.enabled === true;
  const mode = String(appIso.mode || (enabled ? "auto" : "manual")).trim().toUpperCase();
  const activeApp = String(appIso.activeApp || "").trim();
  const devices = Array.isArray(appIso.resolvedDevices) ? appIso.resolvedDevices : [];
  const sourceWord = devices.length
    ? `${devices.length} SOURCE${devices.length === 1 ? "" : "S"}`
    : "NO SOURCES";
  const strictWord = appIso.strict === true ? " | STRICT" : "";
  const appWord = activeApp ? activeApp : "none";
  let line = enabled
    ? `APP ISO ${mode} | APP ${appWord} | ${sourceWord}${strictWord}`
    : `APP ISO OFF | ${sourceWord}`;
  const backendWord = String(t?.backend || "").trim().toLowerCase();
  if (enabled && backendWord !== "ffmpeg" && backendWord !== "proctap") {
    line = `${line} | WARNING BACKEND=${String(t?.backend || "unknown").toUpperCase()}`;
  }
  const liveConfig = t && t.config && typeof t.config === "object" ? t.config : null;
  if (liveConfig) {
    const sameList = (a = [], b = []) => {
      if (a.length !== b.length) return false;
      for (let i = 0; i < a.length; i += 1) {
        if (String(a[i] || "").trim() !== String(b[i] || "").trim()) return false;
      }
      return true;
    };
    const uiEnabled = el.aAppIsolationEnabled ? el.aAppIsolationEnabled.checked === true : enabled;
    const uiMulti = el.aAppIsolationMultiSource ? el.aAppIsolationMultiSource.checked === true : (appIso.multiSource === true);
    const uiStrict = el.aAppIsolationStrict ? el.aAppIsolationStrict.checked === true : (appIso.strict === true);
    const uiCheckMs = el.aAppIsolationCheckMs
      ? Number(el.aAppIsolationCheckMs.value || 300000)
      : Number(appIso.checkMs || 300000);
    const uiPrimaryApp = normalizeAudioAppNameUi(el.aAppPrimary?.value || "");
    const uiFallbackApp = normalizeAudioAppNameUi(el.aAppFallback?.value || "");
    const uiPrimarySources = normalizeAudioDeviceListUi(el.aAppPrimarySources?.value || "");
    const uiFallbackSources = normalizeAudioDeviceListUi(el.aAppFallbackSources?.value || "");
    const uiDefaultSources = normalizeAudioDeviceListUi(
      el.aFfmpegSources ? el.aFfmpegSources.value : (el.aFfmpegDevice?.value || ""),
      String(el.aFfmpegDevice?.value || "").trim() ? [String(el.aFfmpegDevice.value || "").trim()] : []
    );
    const liveDefaultSources = normalizeAudioDeviceListUi(
      liveConfig.ffmpegInputDevices,
      String(liveConfig.ffmpegInputDevice || "").trim() ? [String(liveConfig.ffmpegInputDevice || "").trim()] : []
    );
    const pendingApply =
      uiEnabled !== (liveConfig.ffmpegAppIsolationEnabled === true) ||
      uiMulti !== (liveConfig.ffmpegAppIsolationMultiSource === true) ||
      uiStrict !== (liveConfig.ffmpegAppIsolationStrict === true) ||
      uiCheckMs !== Number(liveConfig.ffmpegAppIsolationCheckMs || 300000) ||
      uiPrimaryApp.toLowerCase() !== String(liveConfig.ffmpegAppIsolationPrimaryApp || "").trim().toLowerCase() ||
      uiFallbackApp.toLowerCase() !== String(liveConfig.ffmpegAppIsolationFallbackApp || "").trim().toLowerCase() ||
      !sameList(uiDefaultSources, liveDefaultSources) ||
      !sameList(uiPrimarySources, normalizeAudioDeviceListUi(liveConfig.ffmpegAppIsolationPrimaryDevices)) ||
      !sameList(uiFallbackSources, normalizeAudioDeviceListUi(liveConfig.ffmpegAppIsolationFallbackDevices));
    if (pendingApply) {
      line = `${line} | PENDING APPLY`;
    }
  }
  updateAudioAppIsolationStatusText(line);
}

async function loadAudioApps(options = {}) {
  const applyTelemetry = options?.applyTelemetry !== false;
  const r = await getJson("/audio/apps?includeAudioHints=1");
  if (!r || !r.ok || !Array.isArray(r.apps)) return false;
  ui.audioRunningApps = r.apps.slice();
  ui.audioRunningAppsHinted = r.apps.slice();
  ui.audioAppHintMeta = r.audioHints && typeof r.audioHints === "object"
    ? { ...r.audioHints }
    : null;
  ui.audioAudioCapableTokens = Array.isArray(r.audioHints?.audioTokens)
    ? r.audioHints.audioTokens
      .map(token => normalizeAudioAppTokenUi(token))
      .filter(Boolean)
    : [];
  ui.audioAppsLoaded = true;
  setAudioAppSelectOptions(el.aAppPrimary, el.aAppPrimary?.value || "");
  setAudioAppSelectOptions(el.aAppFallback, el.aAppFallback?.value || "");
  updateAudioAppsFilterHintUi();
  if (applyTelemetry) applyAudioAppIsolationTelemetry(r.telemetry || null);
  return true;
}

async function forceAudioAppIsolationScan() {
  const r = await postJson("/audio/ffmpeg/app-isolation/scan", {});
  if (!r.ok || !r.data) return false;
  const appsReloaded = await loadAudioApps({ applyTelemetry: false });
  if (!appsReloaded && Array.isArray(r.data.runningApps)) {
    ui.audioRunningApps = r.data.runningApps.slice();
    ui.audioRunningAppsHinted = r.data.runningApps.slice();
    ui.audioAppHintMeta = null;
    ui.audioAudioCapableTokens = [];
    ui.audioAppsLoaded = true;
    setAudioAppSelectOptions(el.aAppPrimary, el.aAppPrimary?.value || "");
    setAudioAppSelectOptions(el.aAppFallback, el.aAppFallback?.value || "");
    updateAudioAppsFilterHintUi();
  }
  if (r.data.config && typeof r.data.config === "object") {
    applyAudioConfigToInputs(r.data.config);
  }
  applyAudioAppIsolationTelemetry(r.data.telemetry || null);
  return true;
}

function applyAudioConfigToInputs(config = {}) {
  const backendRaw = String(config.inputBackend || "auto").trim().toLowerCase();
  el.aInputBackend.value = backendRaw === "ffmpeg" || backendRaw === "portaudio" ? backendRaw : "auto";
  el.aDeviceMatch.value = config.deviceMatch || "";
  el.aDeviceId.value = config.deviceId === null || config.deviceId === undefined
    ? ""
    : String(config.deviceId);
  el.aFfmpegPath.value = String(config.ffmpegPath || "ffmpeg");
  const ffmpegFormatRaw = String(config.ffmpegInputFormat || "dshow").trim().toLowerCase();
  el.aFfmpegFormat.value = ffmpegFormatRaw === "wasapi" ? "wasapi" : "dshow";
  const sourceList = normalizeAudioDeviceListUi(
    config.ffmpegInputDevices,
    String(config.ffmpegInputDevice || "").trim() ? [String(config.ffmpegInputDevice || "").trim()] : []
  );
  el.aFfmpegDevice.value = sourceList[0] || String(config.ffmpegInputDevice || "");
  if (el.aFfmpegSources) el.aFfmpegSources.value = formatAudioDeviceListUi(sourceList);
  if (el.aAppIsolationEnabled) el.aAppIsolationEnabled.checked = config.ffmpegAppIsolationEnabled === true;
  if (el.aAppIsolationMultiSource) el.aAppIsolationMultiSource.checked = config.ffmpegAppIsolationMultiSource === true;
  if (el.aAppIsolationStrict) el.aAppIsolationStrict.checked = config.ffmpegAppIsolationStrict === true;
  if (el.aAppIsolationCheckMs) {
    const checkMs = String(Number(config.ffmpegAppIsolationCheckMs || 300000));
    const hasOption = Array.from(el.aAppIsolationCheckMs.options || []).some(option => option.value === checkMs);
    if (!hasOption) {
      const custom = document.createElement("option");
      custom.value = checkMs;
      custom.textContent = `${Math.max(1, Math.round(Number(checkMs) / 60000))} MIN (CUSTOM)`;
      el.aAppIsolationCheckMs.appendChild(custom);
    }
    el.aAppIsolationCheckMs.value = checkMs;
  }
  setAudioAppSelectOptions(el.aAppPrimary, String(config.ffmpegAppIsolationPrimaryApp || "").trim());
  setAudioAppSelectOptions(el.aAppFallback, String(config.ffmpegAppIsolationFallbackApp || "").trim());
  if (el.aAppPrimarySources) {
    el.aAppPrimarySources.value = formatAudioDeviceListUi(config.ffmpegAppIsolationPrimaryDevices);
  }
  if (el.aAppFallbackSources) {
    el.aAppFallbackSources.value = formatAudioDeviceListUi(config.ffmpegAppIsolationFallbackDevices);
  }
  el.aSampleRate.value = String(config.sampleRate ?? "96000");
  el.aFrames.value = String(config.framesPerBuffer ?? "256");
  el.aChannels.value = String(config.channels ?? "2");
  el.aGain.value = String(config.outputGain ?? "1");
  if (el.aAutoLevelEnabled) el.aAutoLevelEnabled.checked = config.autoLevelEnabled !== false;
  if (el.aAutoLevelTarget) el.aAutoLevelTarget.value = String(config.autoLevelTargetRms ?? "0.028");
  if (el.aAutoLevelMinGain) el.aAutoLevelMinGain.value = String(config.autoLevelMinGain ?? "0.45");
  if (el.aAutoLevelMaxGain) el.aAutoLevelMaxGain.value = String(config.autoLevelMaxGain ?? "1.55");
  if (el.aAutoLevelGate) el.aAutoLevelGate.value = String(config.autoLevelGate ?? "0.007");
  el.aNoise.value = String(config.noiseFloorMin ?? "0.00045");
  el.aPeakDecay.value = String(config.peakDecay ?? "0.93");
  el.aBandLowHz.value = String(config.bandLowHz ?? "180");
  el.aBandMidHz.value = String(config.bandMidHz ?? "2200");
  el.aLimiterThreshold.value = String(config.limiterThreshold ?? "0.82");
  el.aLimiterKnee.value = String(config.limiterKnee ?? "0.16");
  el.aRestartMs.value = String(config.restartMs ?? "1500");
  el.aLogTicks.value = String(config.logEveryTicks ?? "60");
  ui.limiterPreset = detectLimiterPreset(config);
  ui.audioQuickProfile = detectAudioQuickProfile(config);
  syncAudioQuickPresetButtons();
  syncAudioQuickTuningFromInputs();
}

function collectAudioConfigFromInputs() {
  const parsedId = el.aDeviceId.value.trim();
  const ffmpegSourceList = normalizeAudioDeviceListUi(
    el.aFfmpegSources ? el.aFfmpegSources.value : el.aFfmpegDevice.value,
    String(el.aFfmpegDevice.value || "").trim() ? [String(el.aFfmpegDevice.value || "").trim()] : []
  );
  const primaryApp = normalizeAudioAppNameUi(el.aAppPrimary?.value || "");
  const fallbackApp = normalizeAudioAppNameUi(el.aAppFallback?.value || "");
  return {
    inputBackend: String(el.aInputBackend.value || "auto").trim().toLowerCase(),
    deviceMatch: el.aDeviceMatch.value.trim().toLowerCase(),
    deviceId: parsedId === "" ? null : Number(parsedId),
    ffmpegPath: String(el.aFfmpegPath.value || "ffmpeg").trim(),
    ffmpegInputFormat: String(el.aFfmpegFormat.value || "dshow").trim().toLowerCase(),
    ffmpegInputDevice: ffmpegSourceList[0] || String(el.aFfmpegDevice.value || "").trim(),
    ffmpegInputDevices: ffmpegSourceList,
    ffmpegLogLevel: "error",
    ffmpegUseWallclock: true,
    ffmpegAppIsolationEnabled: el.aAppIsolationEnabled ? el.aAppIsolationEnabled.checked === true : false,
    ffmpegAppIsolationStrict: el.aAppIsolationStrict ? el.aAppIsolationStrict.checked === true : false,
    ffmpegAppIsolationPrimaryApp: primaryApp,
    ffmpegAppIsolationFallbackApp: fallbackApp,
    ffmpegAppIsolationPrimaryDevices: normalizeAudioDeviceListUi(el.aAppPrimarySources?.value || ""),
    ffmpegAppIsolationFallbackDevices: normalizeAudioDeviceListUi(el.aAppFallbackSources?.value || ""),
    ffmpegAppIsolationMultiSource: el.aAppIsolationMultiSource ? el.aAppIsolationMultiSource.checked === true : false,
    ffmpegAppIsolationCheckMs: el.aAppIsolationCheckMs ? Number(el.aAppIsolationCheckMs.value || 300000) : 300000,
    sampleRate: Number(el.aSampleRate.value),
    framesPerBuffer: Number(el.aFrames.value),
    channels: Number(el.aChannels.value),
    outputGain: Number(el.aGain.value),
    autoLevelEnabled: el.aAutoLevelEnabled ? el.aAutoLevelEnabled.checked === true : true,
    autoLevelTargetRms: Number(el.aAutoLevelTarget ? el.aAutoLevelTarget.value : "0.028"),
    autoLevelMinGain: Number(el.aAutoLevelMinGain ? el.aAutoLevelMinGain.value : "0.45"),
    autoLevelMaxGain: Number(el.aAutoLevelMaxGain ? el.aAutoLevelMaxGain.value : "1.55"),
    autoLevelGate: Number(el.aAutoLevelGate ? el.aAutoLevelGate.value : "0.007"),
    noiseFloorMin: Number(el.aNoise.value),
    peakDecay: Number(el.aPeakDecay.value),
    bandLowHz: Number(el.aBandLowHz.value),
    bandMidHz: Number(el.aBandMidHz.value),
    limiterThreshold: Number(el.aLimiterThreshold.value),
    limiterKnee: Number(el.aLimiterKnee.value),
    restartMs: Number(el.aRestartMs.value),
    logEveryTicks: Number(el.aLogTicks.value)
  };
}

function collectAudioAppIsolationPatchFromInputs() {
  const full = collectAudioConfigFromInputs();
  return {
    inputBackend: full.inputBackend,
    ffmpegInputFormat: full.ffmpegInputFormat,
    ffmpegInputDevice: full.ffmpegInputDevice,
    ffmpegInputDevices: full.ffmpegInputDevices,
    ffmpegAppIsolationEnabled: full.ffmpegAppIsolationEnabled,
    ffmpegAppIsolationStrict: full.ffmpegAppIsolationStrict,
    ffmpegAppIsolationPrimaryApp: full.ffmpegAppIsolationPrimaryApp,
    ffmpegAppIsolationFallbackApp: full.ffmpegAppIsolationFallbackApp,
    ffmpegAppIsolationPrimaryDevices: full.ffmpegAppIsolationPrimaryDevices,
    ffmpegAppIsolationFallbackDevices: full.ffmpegAppIsolationFallbackDevices,
    ffmpegAppIsolationMultiSource: full.ffmpegAppIsolationMultiSource,
    ffmpegAppIsolationCheckMs: full.ffmpegAppIsolationCheckMs
  };
}

let audioAppIsolationAutoApplyTimer = null;
let audioAppIsolationAutoApplyInFlight = false;

async function applyAudioAppIsolationPatch(reason = "APP ISO") {
  if (audioAppIsolationAutoApplyInFlight) return false;
  audioAppIsolationAutoApplyInFlight = true;
  try {
    const patch = collectAudioAppIsolationPatchFromInputs();
    const r = await postJson("/audio/config", patch);
    if (!r.ok) {
      setBadge(el.health, "bad", `${reason} APPLY FAIL`);
      return false;
    }
    if (r.data && r.data.config) {
      applyAudioConfigToInputs(r.data.config);
    }
    await loadAudioApps();
    setBadge(
      el.health,
      "ok",
      r.data && r.data.restarted ? `${reason} SAVED + RESTART` : `${reason} SAVED`
    );
    return true;
  } finally {
    audioAppIsolationAutoApplyInFlight = false;
  }
}

function queueAudioAppIsolationAutoApply(reason = "APP ISO") {
  if (audioAppIsolationAutoApplyTimer) {
    clearTimeout(audioAppIsolationAutoApplyTimer);
  }
  updateAudioAppIsolationStatusText("APP ISO UI CHANGED | PENDING APPLY");
  audioAppIsolationAutoApplyTimer = setTimeout(() => {
    audioAppIsolationAutoApplyTimer = null;
    applyAudioAppIsolationPatch(reason);
  }, 220);
}

function normalizeAudioReactivitySourceKeyUi(value) {
  const key = String(value || "").trim().toLowerCase();
  return Object.prototype.hasOwnProperty.call(audioReactivitySourceCatalogRuntime, key)
    ? key
    : "";
}

function normalizeAudioReactivitySourcesUi(value, fallback = ["smart"]) {
  const sourceList = Array.isArray(value)
    ? value
    : typeof value === "string"
      ? value.split(/[,\s]+/)
      : [];
  const out = [];
  for (const source of sourceList) {
    const key = normalizeAudioReactivitySourceKeyUi(source);
    if (!key) continue;
    if (!out.includes(key)) out.push(key);
    if (out.length >= 6) break;
  }
  if (out.length) return out;

  const fallbackList = Array.isArray(fallback) ? fallback : [fallback];
  const normalizedFallback = fallbackList
    .map(normalizeAudioReactivitySourceKeyUi)
    .filter(Boolean);
  return normalizedFallback.length ? [...new Set(normalizedFallback)] : ["smart"];
}

function normalizeMetaAutoTempoTrackersUi(input = {}, fallback = null) {
  const raw = input && typeof input === "object" ? input : {};
  const fallbackSource = (
    fallback && typeof fallback === "object"
      ? fallback
      : AUDIO_REACTIVITY_MAP_DEFAULT.metaAutoTempoTrackers
  ) || {};
  const out = {};
  for (const key of META_AUTO_TEMPO_TRACKER_KEYS) {
    out[key] = parseLooseBoolean(raw[key], parseLooseBoolean(fallbackSource[key], false));
  }
  return out;
}

function normalizeAudioReactivityMapUi(input = {}) {
  const raw = input && typeof input === "object" ? input : {};
  const rawTargets = raw.targets && typeof raw.targets === "object" ? raw.targets : {};
  const fallbackTargets = AUDIO_REACTIVITY_MAP_DEFAULT.targets || {};
  const targets = {};
  for (const target of AUDIO_REACTIVITY_TARGET_KEYS) {
    const targetRaw = rawTargets[target] && typeof rawTargets[target] === "object"
      ? rawTargets[target]
      : {};
    const fallback = fallbackTargets[target] || {};
    targets[target] = {
      enabled: parseLooseBoolean(targetRaw.enabled, parseLooseBoolean(fallback.enabled, true)),
      amount: clampNumber(targetRaw.amount, 0, 1.8, clampNumber(fallback.amount, 0, 1.8, 1)),
      sources: normalizeAudioReactivitySourcesUi(targetRaw.sources, fallback.sources || ["smart"])
    };
  }
  const fallbackTrackers = normalizeMetaAutoTempoTrackersUi(
    AUDIO_REACTIVITY_MAP_DEFAULT.metaAutoTempoTrackers,
    AUDIO_REACTIVITY_MAP_DEFAULT.metaAutoTempoTrackers
  );
  const baselineBlend = parseLooseBoolean(
    raw.metaAutoHueWizBaselineBlend,
    parseLooseBoolean(fallbackTrackers.baseline, false)
  );
  const mergedTrackerRaw = {
    ...fallbackTrackers,
    baseline: baselineBlend,
    ...(
      raw.metaAutoTempoTrackers && typeof raw.metaAutoTempoTrackers === "object"
        ? raw.metaAutoTempoTrackers
        : {}
    )
  };
  const metaAutoTempoTrackers = normalizeMetaAutoTempoTrackersUi(
    mergedTrackerRaw,
    fallbackTrackers
  );
  return {
    version: 1,
    dropEnabled: parseLooseBoolean(raw.dropEnabled, false),
    hardwareRateLimitsEnabled: parseLooseBoolean(
      raw.hardwareRateLimitsEnabled,
      parseLooseBoolean(AUDIO_REACTIVITY_MAP_DEFAULT.hardwareRateLimitsEnabled, true)
    ),
    metaAutoHueWizBaselineBlend: metaAutoTempoTrackers.baseline === true,
    metaAutoTempoTrackersAuto: parseLooseBoolean(
      raw.metaAutoTempoTrackersAuto,
      parseLooseBoolean(AUDIO_REACTIVITY_MAP_DEFAULT.metaAutoTempoTrackersAuto, false)
    ),
    metaAutoTempoTrackers,
    targets
  };
}

function getLiveOverclockBand(level = ui.overclockLevel) {
  const hzLevel = Number(level);
  if (!Number.isFinite(hzLevel) || hzLevel <= 1) return "low";
  if (hzLevel >= 4) return "high";
  return "medium";
}

function pushSourcesIntoScoreMap(scoreMap, sources = [], weight = 1) {
  const w = Number(weight);
  if (!Number.isFinite(w) || w <= 0) return;
  for (let i = 0; i < sources.length; i++) {
    const key = normalizeAudioReactivitySourceKeyUi(sources[i]);
    if (!key) continue;
    scoreMap[key] = Number(scoreMap[key] || 0) + (w * (1 - (i * 0.1)));
  }
}

function createLiveSourceScoreMap(target = "other") {
  const targetKey = AUDIO_REACTIVITY_TARGET_KEYS.includes(String(target || "").toLowerCase())
    ? String(target || "").toLowerCase()
    : "other";
  const scoreMap = {};
  for (const source of AUDIO_REACTIVITY_SOURCE_ORDER) {
    scoreMap[source] = 0;
  }
  scoreMap.smart += 1.4;
  scoreMap.groove += 0.45;
  scoreMap.beat += 0.75;

  const modeKey = String(ui.modeLock || "interpret").toLowerCase();
  const profileKey = String(ui.autoProfile || "balanced").toLowerCase();
  const reactKey = String(ui.audioReactivityPreset || "balanced").toLowerCase();
  const sceneRaw = String(ui.sceneLock || "auto").toLowerCase();
  const sceneKey = sceneRaw === "flow" ? "flow" : (sceneRaw || "auto");
  const paletteOrderKey = ui.paletteDisorder ? "disorder" : "ordered";
  const overclockBand = getLiveOverclockBand(ui.overclockLevel);
  const rave = ui.lastRaveTelemetry && typeof ui.lastRaveTelemetry === "object"
    ? ui.lastRaveTelemetry
    : {};
  const audio = ui.lastAudioTelemetry && typeof ui.lastAudioTelemetry === "object"
    ? ui.lastAudioTelemetry
    : {};
  const rms = clampNumber(Number(rave.audioSourceLevel ?? rave.rms ?? audio.level), 0, 1, 0);
  const drive = clampNumber(Number(rave.energy), 0, 1, rms);
  const transient = clampNumber(Number(rave.audioTransient ?? audio.transient), 0, 1.2, 0) / 1.2;
  const peak = clampNumber(Number(rave.audioPeak ?? audio.peak), 0, 1.5, 0) / 1.5;
  const flux = clampNumber(Number(rave.audioFlux ?? audio.spectralFlux), 0, 1, 0);
  const low = clampNumber(Number(rave.audioBandLow ?? audio.bandLow), 0, 1, 0);
  const mid = clampNumber(Number(rave.audioBandMid ?? audio.bandMid), 0, 1, 0);
  const high = clampNumber(Number(rave.audioBandHigh ?? audio.bandHigh), 0, 1, 0);
  const beat = clampNumber(Number(rave.beatConfidence), 0, 1, rave.beat ? 0.62 : 0);
  const motion = Math.max(transient, flux, peak, beat);

  pushSourcesIntoScoreMap(
    scoreMap,
    LIVE_REACTIVITY_SOURCE_BY_STATE.modeLock[modeKey] || LIVE_REACTIVITY_SOURCE_BY_STATE.modeLock.auto,
    LIVE_REACTIVITY_STATE_WEIGHT.modeLock
  );
  pushSourcesIntoScoreMap(
    scoreMap,
    LIVE_REACTIVITY_SOURCE_BY_STATE.autoProfile[profileKey] || LIVE_REACTIVITY_SOURCE_BY_STATE.autoProfile.balanced,
    LIVE_REACTIVITY_STATE_WEIGHT.autoProfile
  );
  pushSourcesIntoScoreMap(
    scoreMap,
    LIVE_REACTIVITY_SOURCE_BY_STATE.audioReactivityPreset[reactKey] || LIVE_REACTIVITY_SOURCE_BY_STATE.audioReactivityPreset.balanced,
    LIVE_REACTIVITY_STATE_WEIGHT.audioReactivityPreset
  );
  pushSourcesIntoScoreMap(
    scoreMap,
    LIVE_REACTIVITY_SOURCE_BY_STATE.sceneLock[sceneKey] || LIVE_REACTIVITY_SOURCE_BY_STATE.sceneLock.auto,
    LIVE_REACTIVITY_STATE_WEIGHT.sceneLock
  );
  pushSourcesIntoScoreMap(
    scoreMap,
    LIVE_REACTIVITY_SOURCE_BY_STATE.paletteDisorder[paletteOrderKey] || LIVE_REACTIVITY_SOURCE_BY_STATE.paletteDisorder.ordered,
    LIVE_REACTIVITY_STATE_WEIGHT.paletteDisorder
  );
  pushSourcesIntoScoreMap(
    scoreMap,
    LIVE_REACTIVITY_SOURCE_BY_STATE.overclockBand[overclockBand] || LIVE_REACTIVITY_SOURCE_BY_STATE.overclockBand.medium,
    LIVE_REACTIVITY_STATE_WEIGHT.overclockBand
  );

  if (drive > 0.24) {
    pushSourcesIntoScoreMap(scoreMap, ["drums", "transients", "beat"], 0.62);
  }
  if (drive > 0.4 || motion > 0.5) {
    pushSourcesIntoScoreMap(scoreMap, ["peaks", "transients", "drums"], 0.84);
  }
  if (transient > 0.24) {
    pushSourcesIntoScoreMap(scoreMap, ["transients", "drums", "peaks"], 0.72);
  }
  if (flux > 0.2) {
    pushSourcesIntoScoreMap(scoreMap, ["flux", "transients", "peaks"], 0.62);
  }
  if (beat > 0.32) {
    pushSourcesIntoScoreMap(scoreMap, ["beat", "drums", "peaks"], 0.68);
  }
  if (low > 0.3) {
    pushSourcesIntoScoreMap(scoreMap, ["bass", "drums", "groove"], 0.58);
  }
  if (mid > 0.32) {
    pushSourcesIntoScoreMap(scoreMap, ["mids", "vocals", "groove"], 0.42);
  }
  if (high > 0.28) {
    pushSourcesIntoScoreMap(scoreMap, ["highs", "transients", "flux"], 0.5);
  }
  if (drive < 0.13 && motion < 0.2) {
    pushSourcesIntoScoreMap(scoreMap, ["baseline", "smart"], 0.45);
  }

  const targetBias = LIVE_REACTIVITY_TARGET_BIAS[targetKey] || LIVE_REACTIVITY_TARGET_BIAS.other;
  for (const source of AUDIO_REACTIVITY_SOURCE_ORDER) {
    scoreMap[source] = Number(scoreMap[source] || 0) + Number(targetBias[source] || 0);
  }
  return scoreMap;
}

function deriveLiveCompatibleSourcesByTarget() {
  const result = {
    hue: ["smart"],
    wiz: ["smart"],
    other: ["smart"]
  };
  for (const target of AUDIO_REACTIVITY_TARGET_KEYS) {
    const scoreMap = createLiveSourceScoreMap(target);
    const sorted = AUDIO_REACTIVITY_SOURCE_ORDER.slice()
      .filter(source => normalizeAudioReactivitySourceKeyUi(source))
      .sort((a, b) => {
        const diff = Number(scoreMap[b] || 0) - Number(scoreMap[a] || 0);
        if (Math.abs(diff) > 0.0001) return diff;
        return a.localeCompare(b);
      });
    const chosen = [];
    for (const source of sorted) {
      if (chosen.length >= 4) break;
      if (!chosen.includes(source)) chosen.push(source);
    }
    if (!chosen.includes("smart")) chosen.unshift("smart");
    result[target] = normalizeAudioReactivitySourcesUi(chosen, ["smart"]);
  }
  return result;
}

function getAllowedCompatibilitySetForTarget(target = "other") {
  const compatByTarget = deriveLiveCompatibleSourcesByTarget();
  const key = AUDIO_REACTIVITY_TARGET_KEYS.includes(String(target || "").toLowerCase())
    ? String(target || "").toLowerCase()
    : "other";
  const allowed = compatByTarget[key] || ["smart"];
  return new Set(normalizeAudioReactivitySourcesUi(allowed, ["smart"]));
}

function updateAudioReactivityPolicyUi() {
  if (el.reactSmartMatchEnabled) el.reactSmartMatchEnabled.checked = ui.reactSmartMatchEnabled === true;
  if (el.reactForceLockEnabled) el.reactForceLockEnabled.checked = ui.reactForceLockEnabled === true;
  if (el.reactForceMatchOverride) el.reactForceMatchOverride.checked = ui.reactForceMatchOverride === true;
  const cfg = normalizeAudioReactivityMapUi(ui.audioReactivityMap || AUDIO_REACTIVITY_MAP_DEFAULT);
  if (el.reactHardwareRateLimitsEnabled) {
    el.reactHardwareRateLimitsEnabled.checked = cfg.hardwareRateLimitsEnabled !== false;
  }

  if (el.reactCompatSummary) {
    const compat = deriveLiveCompatibleSourcesByTarget();
    const hardwareWord = cfg.hardwareRateLimitsEnabled ? "HW CAPS ON" : "HW CAPS OFF";
    const modeWord = ui.reactSmartMatchEnabled ? "SMART MATCH ON" : "SMART MATCH OFF";
    const forceWord = ui.reactForceLockEnabled ? "FORCE SINGLE ON" : "FORCE SINGLE OFF";
    const overrideWord = ui.reactForceMatchOverride ? "OVERRIDE ON" : "OVERRIDE OFF";
    el.reactCompatSummary.textContent = [
      hardwareWord,
      modeWord,
      forceWord,
      overrideWord,
      `HUE:${compat.hue.join("/")}`,
      `WIZ:${compat.wiz.join("/")}`,
      `CUSTOM:${compat.other.join("/")}`
    ].join(" | ");
  }
}

function applyAudioReactivityPolicyConstraints(options = {}) {
  const autoMatch = options.autoMatch === true;
  const config = normalizeAudioReactivityMapUi(ui.audioReactivityMap || AUDIO_REACTIVITY_MAP_DEFAULT);
  const compatByTarget = deriveLiveCompatibleSourcesByTarget();
  let changed = false;

  for (const target of AUDIO_REACTIVITY_TARGET_KEYS) {
    const row = config.targets[target] || { enabled: true, amount: 1, sources: ["smart"] };
    const compat = normalizeAudioReactivitySourcesUi(compatByTarget[target], ["smart"]);
    let nextSources = normalizeAudioReactivitySourcesUi(row.sources, ["smart"]);

    if (autoMatch) {
      nextSources = compat.slice(0, 3);
    }

    if (ui.reactForceLockEnabled) {
      if (!ui.reactForceMatchOverride) {
        nextSources = nextSources.filter(source => compat.includes(source));
      }
      const forcedSource = normalizeAudioReactivitySourcesUi(nextSources, compat)[0] || compat[0] || "smart";
      nextSources = [forcedSource];
    }

    if (!ui.reactForceLockEnabled && !nextSources.includes("smart")) {
      nextSources.unshift("smart");
      nextSources = normalizeAudioReactivitySourcesUi(nextSources, ["smart"]);
    }

    const before = normalizeAudioReactivitySourcesUi(row.sources, ["smart"]).join(",");
    const after = nextSources.join(",");
    if (before !== after) changed = true;
    config.targets[target].sources = nextSources;
  }

  if (changed) {
    applyAudioReactivityMapToUi(config, { markDirty: true });
  } else {
    updateAudioReactivityPolicyUi();
  }
  return changed;
}

async function persistAudioReactivityMapDraft(options = {}) {
  const reason = String(options.reason || "LIVE MATCH").trim().toUpperCase();
  const full = collectAudioReactivityMapFromUi();
  // Smart/live retune should only adjust dynamic reactivity routing and must
  // never silently flip Meta H/W tracker controls.
  const payload = {
    dropEnabled: full.dropEnabled,
    hardwareRateLimitsEnabled: full.hardwareRateLimitsEnabled,
    targets: full.targets
  };
  const r = await postJson("/audio/reactivity-map", payload);
  if (!r.ok || !r.data?.config) {
    setBadge(el.health, "warn", `${reason} PENDING APPLY`);
    return false;
  }
  if (r.data.config.sourceCatalog && typeof r.data.config.sourceCatalog === "object") {
    audioReactivitySourceCatalogRuntime = {
      ...AUDIO_REACTIVITY_SOURCE_CATALOG_DEFAULT,
      ...r.data.config.sourceCatalog
    };
  }
  applyAudioReactivityMapToUi(r.data.config, { markDirty: false });
  ui.audioReactivityMapLoaded = true;
  setBadge(el.health, "ok", reason);
  return true;
}

function queueSmartMatchPersist(reason = "LIVE MATCH") {
  const normalizedReason = String(reason || "LIVE MATCH").trim().toUpperCase();
  if (liveSmartMatchSaveTimer) {
    clearTimeout(liveSmartMatchSaveTimer);
    liveSmartMatchSaveTimer = null;
  }
  liveSmartMatchSaveTimer = setTimeout(async () => {
    liveSmartMatchSaveTimer = null;
    if (liveSmartMatchSaveInFlight) {
      liveSmartMatchSaveQueued = true;
      return;
    }
    liveSmartMatchSaveInFlight = true;
    try {
      await persistAudioReactivityMapDraft({ reason: normalizedReason });
    } finally {
      liveSmartMatchSaveInFlight = false;
      if (liveSmartMatchSaveQueued) {
        liveSmartMatchSaveQueued = false;
        queueSmartMatchPersist("LIVE MATCH");
      }
    }
  }, 140);
}

function maybeApplySmartLiveReactivityPolicy(reason = "LIVE MATCH") {
  const changed = applyAudioReactivityPolicyConstraints({ autoMatch: ui.reactSmartMatchEnabled === true });
  if (ui.reactSmartMatchEnabled && changed) {
    queueSmartMatchPersist(reason);
  }
  return changed;
}

function computeSmartMatchTelemetryFingerprint() {
  const rave = ui.lastRaveTelemetry && typeof ui.lastRaveTelemetry === "object"
    ? ui.lastRaveTelemetry
    : {};
  const audio = ui.lastAudioTelemetry && typeof ui.lastAudioTelemetry === "object"
    ? ui.lastAudioTelemetry
    : {};
  const bucket = (value, low = 0.16, mid = 0.36, high = 0.62) => {
    const n = clampNumber(Number(value), 0, 1, 0);
    if (n >= high) return "x";
    if (n >= mid) return "h";
    if (n >= low) return "m";
    return "l";
  };

  const drive = clampNumber(
    Number(rave.energy),
    0,
    1,
    clampNumber(Number(rave.audioSourceLevel ?? rave.rms ?? audio.level), 0, 1, 0)
  );
  const transient = clampNumber(Number(rave.audioTransient ?? audio.transient), 0, 1.2, 0) / 1.2;
  const flux = clampNumber(Number(rave.audioFlux ?? audio.spectralFlux), 0, 1, 0);
  const lowBand = clampNumber(Number(rave.audioBandLow ?? audio.bandLow), 0, 1, 0);
  const midBand = clampNumber(Number(rave.audioBandMid ?? audio.bandMid), 0, 1, 0);
  const highBand = clampNumber(Number(rave.audioBandHigh ?? audio.bandHigh), 0, 1, 0);
  const beat = clampNumber(Number(rave.beatConfidence), 0, 1, rave.beat ? 0.62 : 0);
  const motion = Math.max(transient, flux, beat);

  return [
    String(ui.modeLock || "interpret"),
    String(ui.autoProfile || "balanced"),
    String(ui.audioReactivityPreset || "balanced"),
    String(ui.sceneLock || "auto"),
    String(ui.paletteColorsPerFamily || 3),
    String(normalizePaletteVividnessUi(ui.paletteVividness, 2)),
    getPaletteFamiliesLabelUi(ui.paletteFamilies),
    ui.paletteDisorder ? "disorder" : "ordered",
    String(Math.round(normalizePaletteDisorderAggressionUi(ui.paletteDisorderAggression, 0.35) * 100)),
    normalizePaletteCycleModeUi(ui.paletteCycleMode, "on_trigger"),
    String(normalizePaletteTimedIntervalSecUi(ui.paletteTimedIntervalSec, 5)),
    ui.paletteBeatLock ? "beatlock" : "free",
    String(normalizePaletteBeatLockGraceSecUi(ui.paletteBeatLockGraceSec, 2)),
    String(normalizePaletteReactiveMarginUi(ui.paletteReactiveMargin, 28)),
    normalizePaletteBrightnessModeUi(ui.paletteBrightnessMode, "legacy"),
    String(normalizePaletteBrightnessFollowAmountUi(ui.paletteBrightnessFollowAmount, 1).toFixed(2)),
    normalizePaletteSpectrumMapModeUi(ui.paletteSpectrumMapMode, "auto"),
    normalizePaletteSpectrumFeatureMapUi(
      ui.paletteSpectrumFeatureMap,
      PALETTE_DEFAULT_SPECTRUM_FEATURE_MAP
    ).join(","),
    getLiveOverclockBand(ui.overclockLevel),
    bucket(drive),
    bucket(motion, 0.2, 0.42, 0.66),
    bucket(lowBand, 0.2, 0.4, 0.62),
    bucket(midBand, 0.2, 0.38, 0.6),
    bucket(highBand, 0.2, 0.36, 0.58)
  ].join("|");
}

function maybeRetuneSmartMatchFromTelemetry() {
  if (!ui.reactSmartMatchEnabled) return;
  if (ui.audioReactivityMapDirty) return;
  const now = Date.now();
  if (now < Number(ui.smartMatchNextRetuneAt || 0)) return;
  ui.smartMatchNextRetuneAt = now + 1800;
  const fingerprint = computeSmartMatchTelemetryFingerprint();
  if (!fingerprint || fingerprint === ui.smartMatchFingerprint) return;
  ui.smartMatchFingerprint = fingerprint;
  maybeApplySmartLiveReactivityPolicy("SMART RETUNE");
}

function getAudioReactivityTargetUiRefs(target) {
  const key = String(target || "").trim().toLowerCase();
  if (key === "hue") {
    return {
      enabled: el.reactHueEnabled,
      amount: el.reactHueAmount,
      amountVal: el.reactHueAmountVal,
      sources: el.reactHueSources
    };
  }
  if (key === "wiz") {
    return {
      enabled: el.reactWizEnabled,
      amount: el.reactWizAmount,
      amountVal: el.reactWizAmountVal,
      sources: el.reactWizSources
    };
  }
  return {
    enabled: el.reactOtherEnabled,
    amount: el.reactOtherAmount,
    amountVal: el.reactOtherAmountVal,
    sources: el.reactOtherSources
  };
}

function setAudioReactivityMapStatus(text) {
  if (!el.reactMapStatus) return;
  el.reactMapStatus.value = String(text || "").trim();
}

function refreshAudioReactivityMapStatus() {
  const cfg = normalizeAudioReactivityMapUi(ui.audioReactivityMap || AUDIO_REACTIVITY_MAP_DEFAULT);
  ui.metaAutoTempoTrackersAuto = cfg.metaAutoTempoTrackersAuto === true;
  const dropWord = cfg.dropEnabled ? "DROP ON" : "DROP OFF";
  const hardwareWord = cfg.hardwareRateLimitsEnabled ? "HW CAPS ON" : "HW CAPS OFF";
  const trackers = normalizeMetaAutoTempoTrackersUi(cfg.metaAutoTempoTrackers, AUDIO_REACTIVITY_MAP_DEFAULT.metaAutoTempoTrackers);
  const trackerActive = [];
  if (trackers.baseline) trackerActive.push("BASE+DRUMS");
  if (trackers.peaks) trackerActive.push("PEAKS");
  if (trackers.transients) trackerActive.push("TRANS");
  if (trackers.flux) trackerActive.push("FLUX");
  const metaBlendWord = trackerActive.length
    ? `META H/W FACTORS ${trackerActive.join("+")}+HZ`
    : "META H/W FACTORS NONE";
  const autoTrackerWord = cfg.metaAutoTempoTrackersAuto ? "META H/W DOM AUTO ON" : "META H/W DOM AUTO OFF";
  const smartWord = ui.reactSmartMatchEnabled ? "SMART LIVE ON" : "SMART LIVE OFF";
  const forceWord = ui.reactForceLockEnabled ? "FORCE SINGLE ON" : "FORCE SINGLE OFF";
  const overrideWord = ui.reactForceMatchOverride ? "OVERRIDE ON" : "OVERRIDE OFF";
  const parts = [dropWord, hardwareWord, metaBlendWord, autoTrackerWord, smartWord, forceWord, overrideWord];
  for (const target of AUDIO_REACTIVITY_TARGET_KEYS) {
    const row = cfg.targets[target] || {};
    const label = target === "other" ? "CUSTOM" : target.toUpperCase();
    const sources = Array.isArray(row.sources) && row.sources.length ? row.sources.join("+") : "smart";
    const amountWord = `${clampNumber(row.amount, 0, 1.8, 1).toFixed(2)}x`;
    parts.push(`${label}:${row.enabled ? sources : "off"}@${amountWord}`);
  }
  if (ui.audioReactivityMapDirty) {
    parts.push("UNSAVED");
  }
  setAudioReactivityMapStatus(parts.join(" | "));
  updateAudioReactivityPolicyUi();
}

function syncAudioReactivityAmountLabels() {
  const rows = [
    { slider: el.reactHueAmount, label: el.reactHueAmountVal },
    { slider: el.reactWizAmount, label: el.reactWizAmountVal },
    { slider: el.reactOtherAmount, label: el.reactOtherAmountVal }
  ];
  for (const row of rows) {
    if (!row.slider || !row.label) continue;
    const amount = clampNumber(Number(row.slider.value) / 100, 0, 1.8, 1);
    row.label.textContent = `${amount.toFixed(2)}x`;
  }
}

function markAudioReactivityMapDirty() {
  ui.audioReactivityMap = collectAudioReactivityMapFromUi();
  ui.audioReactivityMapDirty = true;
  refreshAudioReactivityMapStatus();
}

function renderAudioReactivitySourceButtons() {
  const sourceEntries = Object.entries(audioReactivitySourceCatalogRuntime || {});
  for (const target of AUDIO_REACTIVITY_TARGET_KEYS) {
    const refs = getAudioReactivityTargetUiRefs(target);
    if (!refs.sources) continue;
    const rowCfg = ui.audioReactivityMap?.targets?.[target] || AUDIO_REACTIVITY_MAP_DEFAULT.targets[target];
    const selected = normalizeAudioReactivitySourcesUi(rowCfg.sources, ["smart"]);
    const compatibleSet = getAllowedCompatibilitySetForTarget(target);
    refs.sources.replaceChildren();
    for (const [sourceKey, sourceInfo] of sourceEntries) {
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "audioReactSourceBtn";
      btn.dataset.reactSource = sourceKey;
      btn.textContent = String(sourceInfo?.label || sourceKey).toUpperCase();
      btn.title = String(sourceInfo?.description || sourceKey);
      const compatible = compatibleSet.has(sourceKey);
      btn.classList.toggle("active", selected.includes(sourceKey));
      btn.classList.toggle("incompatible", !compatible);
      btn.onclick = () => {
        if (ui.reactForceLockEnabled && !ui.reactForceMatchOverride && !compatible) return;
        const cfg = normalizeAudioReactivityMapUi(ui.audioReactivityMap || AUDIO_REACTIVITY_MAP_DEFAULT);
        let list = cfg.targets[target].sources.slice();
        if (ui.reactForceLockEnabled) {
          list = [sourceKey];
        } else {
          const idx = list.indexOf(sourceKey);
          if (idx >= 0) {
            list.splice(idx, 1);
          } else {
            list.push(sourceKey);
          }
        }
        cfg.targets[target].sources = normalizeAudioReactivitySourcesUi(list, ["smart"]);
        applyAudioReactivityMapToUi(cfg, { markDirty: true });
      };
      refs.sources.appendChild(btn);
    }
    const rowEnabled = parseLooseBoolean(rowCfg.enabled, true);
    const buttons = refs.sources.querySelectorAll(".audioReactSourceBtn");
    buttons.forEach(btn => {
      const sourceKey = String(btn.dataset.reactSource || "").trim().toLowerCase();
      const compatible = compatibleSet.has(sourceKey);
      const forceLockedOut = ui.reactForceLockEnabled && !ui.reactForceMatchOverride && !compatible;
      btn.disabled = !rowEnabled || forceLockedOut;
    });
  }
}

function applyAudioReactivityMapToUi(config = {}, options = {}) {
  const normalized = normalizeAudioReactivityMapUi(config);
  ui.audioReactivityMap = normalized;
  ui.metaAutoTempoTrackersAuto = normalized.metaAutoTempoTrackersAuto === true;
  ui.metaAutoTempoTrackers = { ...normalizeMetaAutoTempoTrackersUi(normalized.metaAutoTempoTrackers) };
  if (!ui.metaAutoTempoTrackersAuto) {
    ui.metaAutoTempoTrackersActive = { ...ui.metaAutoTempoTrackers };
  } else if (!ui.metaAutoTempoTrackersActive || typeof ui.metaAutoTempoTrackersActive !== "object") {
    ui.metaAutoTempoTrackersActive = { ...ui.metaAutoTempoTrackers };
  }
  ui.metaAutoHueWizBaselineBlend = normalized.metaAutoHueWizBaselineBlend === true;
  ui.audioReactivityMapDirty = options.markDirty === true;
  if (el.reactDropEnabled) {
    el.reactDropEnabled.checked = normalized.dropEnabled === true;
  }
  if (el.reactHardwareRateLimitsEnabled) {
    el.reactHardwareRateLimitsEnabled.checked = normalized.hardwareRateLimitsEnabled !== false;
  }
  for (const target of AUDIO_REACTIVITY_TARGET_KEYS) {
    const refs = getAudioReactivityTargetUiRefs(target);
    const row = normalized.targets[target] || AUDIO_REACTIVITY_MAP_DEFAULT.targets[target];
    if (refs.enabled) refs.enabled.checked = parseLooseBoolean(row.enabled, true);
    if (refs.amount) refs.amount.value = String(Math.round(clampNumber(row.amount, 0, 1.8, 1) * 100));
    if (refs.amount) refs.amount.disabled = refs.enabled ? !refs.enabled.checked : false;
  }
  syncAudioReactivityAmountLabels();
  renderAudioReactivitySourceButtons();
  refreshAudioReactivityMapStatus();
  updateAudioReactivityPolicyUi();
}

function collectAudioReactivityMapFromUi() {
  const base = normalizeAudioReactivityMapUi(ui.audioReactivityMap || AUDIO_REACTIVITY_MAP_DEFAULT);
  base.dropEnabled = Boolean(el.reactDropEnabled?.checked);
  base.hardwareRateLimitsEnabled = el.reactHardwareRateLimitsEnabled
    ? el.reactHardwareRateLimitsEnabled.checked !== false
    : true;
  base.metaAutoTempoTrackersAuto = ui.metaAutoTempoTrackersAuto === true;
  base.metaAutoTempoTrackers = normalizeMetaAutoTempoTrackersUi(
    ui.metaAutoTempoTrackers,
    base.metaAutoTempoTrackers
  );
  base.metaAutoHueWizBaselineBlend = base.metaAutoTempoTrackers.baseline === true;
  for (const target of AUDIO_REACTIVITY_TARGET_KEYS) {
    const refs = getAudioReactivityTargetUiRefs(target);
    const enabled = refs.enabled ? refs.enabled.checked === true : true;
    const amount = refs.amount
      ? clampNumber(Number(refs.amount.value) / 100, 0, 1.8, 1)
      : 1;
    let sources = base.targets[target].sources;
    if (refs.sources) {
      const selected = Array.from(refs.sources.querySelectorAll(".audioReactSourceBtn.active"))
        .map(node => String(node.dataset.reactSource || "").trim().toLowerCase());
      sources = normalizeAudioReactivitySourcesUi(selected, sources);
    }
    base.targets[target] = {
      enabled,
      amount,
      sources
    };
  }
  return normalizeAudioReactivityMapUi(base);
}

async function loadAudioReactivityMap() {
  const r = await getJson("/audio/reactivity-map");
  if (!r || !r.ok || !r.config) return false;
  if (r.config.sourceCatalog && typeof r.config.sourceCatalog === "object") {
    audioReactivitySourceCatalogRuntime = { ...AUDIO_REACTIVITY_SOURCE_CATALOG_DEFAULT, ...r.config.sourceCatalog };
  }
  applyAudioReactivityMapToUi(r.config, { markDirty: false });
  maybeApplySmartLiveReactivityPolicy("SMART MATCH");
  ui.audioReactivityMapLoaded = true;
  return true;
}

async function saveAudioReactivityMap(options = {}) {
  const reset = options.reset === true;
  const payload = reset
    ? { reset: true }
    : collectAudioReactivityMapFromUi();
  const r = await postJson("/audio/reactivity-map", payload);
  if (!r.ok || !r.data?.config) return { ok: false, error: r.data?.error || "save failed" };
  if (r.data.config.sourceCatalog && typeof r.data.config.sourceCatalog === "object") {
    audioReactivitySourceCatalogRuntime = { ...AUDIO_REACTIVITY_SOURCE_CATALOG_DEFAULT, ...r.data.config.sourceCatalog };
  }
  applyAudioReactivityMapToUi(r.data.config, { markDirty: false });
  ui.audioReactivityMapLoaded = true;
  return { ok: true };
}

function bindAudioReactivityMapUi() {
  const rows = [
    { enabled: el.reactHueEnabled, amount: el.reactHueAmount },
    { enabled: el.reactWizEnabled, amount: el.reactWizAmount },
    { enabled: el.reactOtherEnabled, amount: el.reactOtherAmount }
  ];
  for (const row of rows) {
    if (row.enabled && row.amount) {
      row.enabled.onchange = () => {
        row.amount.disabled = !row.enabled.checked;
        renderAudioReactivitySourceButtons();
        markAudioReactivityMapDirty();
      };
    }
    if (row.amount) {
      row.amount.oninput = () => {
        syncAudioReactivityAmountLabels();
        markAudioReactivityMapDirty();
      };
      row.amount.onchange = () => {
        syncAudioReactivityAmountLabels();
        markAudioReactivityMapDirty();
      };
    }
  }

  if (el.reactDropEnabled) {
    el.reactDropEnabled.onchange = () => {
      markAudioReactivityMapDirty();
    };
  }

  if (el.reactHardwareRateLimitsEnabled) {
    el.reactHardwareRateLimitsEnabled.onchange = () => {
      markAudioReactivityMapDirty();
    };
  }

  if (el.reactSmartMatchEnabled) {
    el.reactSmartMatchEnabled.onchange = () => {
      ui.reactSmartMatchEnabled = el.reactSmartMatchEnabled.checked === true;
      localStorage.setItem(AUDIO_REACT_SMART_MATCH_KEY, ui.reactSmartMatchEnabled ? "1" : "0");
      maybeApplySmartLiveReactivityPolicy("SMART MATCH");
      refreshAudioReactivityMapStatus();
    };
  }

  if (el.reactForceLockEnabled) {
    el.reactForceLockEnabled.onchange = () => {
      ui.reactForceLockEnabled = el.reactForceLockEnabled.checked === true;
      localStorage.setItem(AUDIO_REACT_FORCE_LOCK_KEY, ui.reactForceLockEnabled ? "1" : "0");
      const changed = applyAudioReactivityPolicyConstraints({ autoMatch: ui.reactSmartMatchEnabled === true });
      if (ui.reactSmartMatchEnabled && changed) {
        queueSmartMatchPersist("FORCE LOCK");
      }
      renderAudioReactivitySourceButtons();
      refreshAudioReactivityMapStatus();
    };
  }

  if (el.reactForceMatchOverride) {
    el.reactForceMatchOverride.onchange = () => {
      ui.reactForceMatchOverride = el.reactForceMatchOverride.checked === true;
      localStorage.setItem(AUDIO_REACT_FORCE_OVERRIDE_KEY, ui.reactForceMatchOverride ? "1" : "0");
      const changed = applyAudioReactivityPolicyConstraints({ autoMatch: ui.reactSmartMatchEnabled === true });
      if (ui.reactSmartMatchEnabled && changed) {
        queueSmartMatchPersist("FORCE OVERRIDE");
      }
      renderAudioReactivitySourceButtons();
      refreshAudioReactivityMapStatus();
    };
  }

  updateAudioReactivityPolicyUi();
}

function updateAudioTelemetry(a) {
  if (!a) return;
  el.aLevel.textContent = toFixedSafe(a.level, 2, "0.00");
  el.aRaw.textContent = toFixedSafe(a.levelRaw ?? a.level, 2, "0.00");
  el.aPeak.textContent = toFixedSafe(a.peak, 2, "0.00");
  el.aTransient.textContent = toFixedSafe(a.transient, 2, "0.00");
  el.aZcr.textContent = toFixedSafe(a.zcr, 2, "0.00");
  el.aBandLow.textContent = toFixedSafe(a.bandLow, 2, "0.00");
  el.aBandMid.textContent = toFixedSafe(a.bandMid, 2, "0.00");
  el.aBandHigh.textContent = toFixedSafe(a.bandHigh, 2, "0.00");
  el.aFlux.textContent = toFixedSafe(a.spectralFlux, 2, "0.00");
  if (el.aAutoGain) {
    el.aAutoGain.textContent = toFixedSafe(a.autoLevelGain ?? 1, 2, "1.00");
  }
  if (el.aEffectiveGain) {
    const fallbackGain = a && a.config ? a.config.outputGain : 1;
    el.aEffectiveGain.textContent = toFixedSafe(a.effectiveOutputGain ?? fallbackGain, 2, "1.00");
  }
  el.aDevice.textContent = a.device || "-";
  el.aRunning.textContent = a.running ? "YES" : "NO";
  el.aRestart.textContent = a.lastRestartReason || "-";
  el.aError.textContent = a.lastError || "-";
  applyAudioAppIsolationTelemetry(a);
}

async function loadAudioConfig() {
  const r = await getJson("/audio/config");
  if (!r || !r.ok) return false;
  applyAudioConfigToInputs(r.config || {});
  updateAudioTelemetry(r.telemetry || null);
  ui.audioConfigLoaded = true;
  return true;
}

async function loadAudioDevices() {
  const r = await getJson("/audio/devices");
  if (!r || !r.ok || !Array.isArray(r.devices)) return false;

  el.aDevices.innerHTML = "";
  const autoOpt = document.createElement("option");
  autoOpt.value = "";
  autoOpt.textContent = "AUTO SELECT";
  el.aDevices.appendChild(autoOpt);

  r.devices.forEach(d => {
    const o = document.createElement("option");
    o.value = String(d.id);
    o.textContent = `${d.id} | ${d.name} | ${d.hostAPIName}`;
    el.aDevices.appendChild(o);
  });

  return true;
}

async function poll(options = {}) {
  const force = options.force === true;
  if (ui.pollPaused && !force) {
    pollTick += 1;
    if (el.netBadge && (pollTick % 16) === 0) {
      setBadge(el.netBadge, "warn", "POLL PAUSED");
    }
    return;
  }

  const [t, h, w, a] = await Promise.all([
    getJson("/rave/telemetry"),
    getJson("/hue/telemetry"),
    getJson("/wiz/telemetry"),
    getJson("/audio/telemetry")
  ]);

  const tick = pollTick++;
  const shouldPollFixtures = (tick % 8) === 0 || !ui.fixturesSnapshotLoaded;
  const shouldPollAutomation = (tick % 20) === 0 || !ui.automationConfigLoaded;
  const shouldPollMods = (ui.activeTab === "mods") &&
    ((tick % 10) === 0 || ui.modsLoadedAt === 0);
  const shouldPollColorPrefixes = (tick % 30) === 0 || !ui.colorPrefixConfigLoaded;
  const shouldPollMidi = (ui.activeTab === "midi") || (tick % 20) === 0 || !ui.midiConfigLoaded;
  const shouldPollReactMap = (tick % 40) === 0 || !ui.audioReactivityMapLoaded;
  const [f, automationSnapshot, modsSnapshot, colorPrefixSnapshot, midiSnapshot, reactMapSnapshot] = await Promise.all([
    shouldPollFixtures ? getJson("/fixtures") : Promise.resolve(null),
    shouldPollAutomation ? getJson("/automation/config") : Promise.resolve(null),
    shouldPollMods ? getJson("/mods") : Promise.resolve(null),
    shouldPollColorPrefixes ? getJson("/color/prefixes") : Promise.resolve(null),
    shouldPollMidi ? getJson("/midi/status") : Promise.resolve(null),
    shouldPollReactMap ? getJson("/audio/reactivity-map") : Promise.resolve(null)
  ]);

  if (!t || !h) {
    if (f) updateFixtures(f);
    if (automationSnapshot?.ok && automationSnapshot.config) {
      if (!ui.automationConfigLoaded) {
        applyAutomationConfigToInputs(automationSnapshot.config, automationSnapshot.meta || {});
        ui.automationConfigLoaded = true;
      } else {
        renderAutomationSummary(automationSnapshot.config, automationSnapshot.meta || {});
      }
    }
    if (modsSnapshot?.ok) {
      renderMods(modsSnapshot);
    }
    if (colorPrefixSnapshot?.ok) {
      applyColorPrefixSnapshot(colorPrefixSnapshot);
      ui.colorPrefixConfigLoaded = true;
    }
    if (midiSnapshot?.ok !== false && midiSnapshot) {
      applyMidiSnapshot(midiSnapshot);
    }
    if (reactMapSnapshot?.ok && reactMapSnapshot?.config) {
      applyMetaAutoTempoTrackersState(
        reactMapSnapshot.config.metaAutoTempoTrackers || {
          baseline: reactMapSnapshot.config.metaAutoHueWizBaselineBlend === true
        },
        {
          autoEnabled: reactMapSnapshot.config.metaAutoTempoTrackersAuto === true
        }
      );
      if (reactMapSnapshot.config.sourceCatalog && typeof reactMapSnapshot.config.sourceCatalog === "object") {
        audioReactivitySourceCatalogRuntime = {
          ...AUDIO_REACTIVITY_SOURCE_CATALOG_DEFAULT,
          ...reactMapSnapshot.config.sourceCatalog
        };
      }
      if (!ui.audioReactivityMapDirty) {
        applyAudioReactivityMapToUi(reactMapSnapshot.config, { markDirty: false });
      }
      ui.audioReactivityMapLoaded = true;
    }

    ui.pollErrors += 1;
    setBadge(el.netBadge, "bad", "NET DOWN");
    if (ui.pollErrors > 2) {
      setBadge(el.health, "bad", "ENGINE UNREACHABLE");
    }
    const fallbackT = { energy: 0.05, rms: 0.03, drop: false, scene: "-", behavior: "-" };
    const fallbackA = { level: 0.03, transient: 0, spectralFlux: 0, bandLow: 0, bandMid: 0, bandHigh: 0 };
    ui.lastRaveTelemetry = fallbackT;
    ui.lastAudioTelemetry = a && typeof a === "object" ? a : fallbackA;
    updateMainScopeInput(fallbackT, fallbackA);
    updateScopeHud(fallbackT, fallbackA);
    pushScopeSample(null, null, null, null);
    drawTelemetryScope();
    return;
  }

  ui.pollErrors = 0;
  setBadge(el.netBadge, "ok", "NET OK");
  ui.lastRaveTelemetry = t && typeof t === "object" ? t : null;
  if (a && typeof a === "object") {
    ui.lastAudioTelemetry = a;
  }

  el.rms.textContent = toFixedSafe(t.audioSourceLevel ?? t.rms, 2, "0.00");
  el.eng.textContent = toFixedSafe(t.energy, 2, "0.00");
  el.mode.textContent = "interpret";
  el.autoProfile.textContent = t.autoProfile || ui.autoProfile;
  el.audioReact.textContent = t.audioReactivityPreset || ui.audioReactivityPreset;
  el.scene.textContent = t.scene || "-";
  el.behavior.textContent = t.behavior || "-";
  el.phrase.textContent = t.phrase || "-";
  el.dropStat.textContent = t.drop ? "YES" : "NO";
  if (el.paletteStat) {
    el.paletteStat.textContent = `${getPaletteFamiliesLabelUi(ui.paletteFamilies)} x${ui.paletteColorsPerFamily} | ${formatPaletteVividnessLabelUi(ui.paletteVividness)}`;
  }
  if (el.paletteOrderStat) {
    el.paletteOrderStat.textContent = ui.paletteDisorder
      ? `DISORDER ${Math.round((ui.paletteDisorderAggression || 0) * 100)}%`
      : "ORDERED";
  }
  if (Number.isFinite(Number(t.bpm)) && Number(t.bpm) > 0) {
    ui.lastBpm = Number(t.bpm);
  }
  if (!el.standCustomCluster.classList.contains("hidden") && normalizeStandaloneMode(el.standMode.value) === "auto") {
    syncStandaloneModeUi({ enabled: !el.standMode.disabled });
  }
  if (Number.isFinite(Number(t.flowIntensity))) {
    const nextFlowIntensity = clampFlowIntensity(Number(t.flowIntensity));
    if (Date.now() > Number(ui.flowIntensityInputUntil || 0)) {
      ui.flowIntensity = nextFlowIntensity;
      applyFlowIntensityUi();
    }
  }

  ui.mode = "interpret";
  ui.modeLock = "interpret";
  if (Number.isFinite(Number(t.overclockLevel))) {
    ui.overclockLevel = Number(t.overclockLevel);
    ui.overclock = ui.overclockLevel > 0;
  }
  if (t.autoProfile) ui.autoProfile = t.autoProfile;
  if (t.audioReactivityPreset) ui.audioReactivityPreset = t.audioReactivityPreset;
  if (Object.prototype.hasOwnProperty.call(t, "paletteFamilies")) {
    ui.paletteFamilies = normalizePaletteFamiliesUi(
      Array.isArray(t.paletteFamilies) ? t.paletteFamilies : String(t.paletteFamilies || ""),
      ui.paletteFamilies || ["red", "green", "blue"]
    );
  }
  if (Number.isFinite(Number(t.paletteColorsPerFamily))) {
    ui.paletteColorsPerFamily = normalizePaletteColorCountUi(
      t.paletteColorsPerFamily,
      ui.paletteColorsPerFamily || 3
    );
  }
  if (typeof t.paletteDisorder === "boolean") {
    ui.paletteDisorder = t.paletteDisorder;
  }
  if (Object.prototype.hasOwnProperty.call(t, "paletteDisorderAggression")) {
    ui.paletteDisorderAggression = normalizePaletteDisorderAggressionUi(
      t.paletteDisorderAggression,
      ui.paletteDisorderAggression || 0.35
    );
  }
  if (Object.prototype.hasOwnProperty.call(t, "paletteCycleMode")) {
    ui.paletteCycleMode = normalizePaletteCycleModeUi(
      t.paletteCycleMode,
      ui.paletteCycleMode || "on_trigger"
    );
  }
  if (Object.prototype.hasOwnProperty.call(t, "paletteTimedIntervalSec")) {
    ui.paletteTimedIntervalSec = normalizePaletteTimedIntervalSecUi(
      t.paletteTimedIntervalSec,
      ui.paletteTimedIntervalSec || 5
    );
  }
  if (Object.prototype.hasOwnProperty.call(t, "paletteBeatLock")) {
    ui.paletteBeatLock = parseBooleanUi(t.paletteBeatLock, ui.paletteBeatLock === true);
  }
  if (Object.prototype.hasOwnProperty.call(t, "paletteBeatLockGraceSec")) {
    ui.paletteBeatLockGraceSec = normalizePaletteBeatLockGraceSecUi(
      t.paletteBeatLockGraceSec,
      ui.paletteBeatLockGraceSec || 2
    );
  }
  if (Object.prototype.hasOwnProperty.call(t, "paletteReactiveMargin")) {
    ui.paletteReactiveMargin = normalizePaletteReactiveMarginUi(
      t.paletteReactiveMargin,
      ui.paletteReactiveMargin || 28
    );
  }
  if (Object.prototype.hasOwnProperty.call(t, "paletteBrightnessMode")) {
    ui.paletteBrightnessMode = normalizePaletteBrightnessModeUi(
      t.paletteBrightnessMode,
      ui.paletteBrightnessMode || "legacy"
    );
  }
  if (Object.prototype.hasOwnProperty.call(t, "paletteBrightnessFollowAmount")) {
    ui.paletteBrightnessFollowAmount = normalizePaletteBrightnessFollowAmountUi(
      t.paletteBrightnessFollowAmount,
      ui.paletteBrightnessFollowAmount ?? 1
    );
  }
  if (Object.prototype.hasOwnProperty.call(t, "paletteVividness")) {
    ui.paletteVividness = normalizePaletteVividnessUi(
      t.paletteVividness,
      ui.paletteVividness || 2
    );
  }
  if (Object.prototype.hasOwnProperty.call(t, "paletteSpectrumMapMode")) {
    ui.paletteSpectrumMapMode = normalizePaletteSpectrumMapModeUi(
      t.paletteSpectrumMapMode,
      ui.paletteSpectrumMapMode || "auto"
    );
  }
  if (Object.prototype.hasOwnProperty.call(t, "paletteSpectrumFeatureMap")) {
    ui.paletteSpectrumFeatureMap = normalizePaletteSpectrumFeatureMapUi(
      t.paletteSpectrumFeatureMap,
      ui.paletteSpectrumFeatureMap || PALETTE_DEFAULT_SPECTRUM_FEATURE_MAP
    );
  }
  if (typeof t.metaAutoEnabled === "boolean") ui.metaAutoEnabled = t.metaAutoEnabled;
  if (typeof t.metaAutoReason === "string" && t.metaAutoReason) ui.metaAutoReason = t.metaAutoReason;
  if (typeof t.metaAutoGenre === "string" && t.metaAutoGenre) ui.metaAutoGenre = t.metaAutoGenre;
  if (Number.isFinite(Number(t.metaAutoHz))) ui.metaAutoHz = Number(t.metaAutoHz);
  if (t.metaAutoTempoTrackersActive && typeof t.metaAutoTempoTrackersActive === "object") {
    ui.metaAutoTempoTrackersActive = normalizeMetaAutoTempoTrackersUi(
      t.metaAutoTempoTrackersActive,
      ui.metaAutoTempoTrackersActive
    );
  } else if (t.metaAutoTempoTrackers && typeof t.metaAutoTempoTrackers === "object") {
    ui.metaAutoTempoTrackersActive = normalizeMetaAutoTempoTrackersUi(
      t.metaAutoTempoTrackers,
      ui.metaAutoTempoTrackersActive
    );
  }
  if (typeof t.overclockAutoEnabled === "boolean") ui.overclockAutoEnabled = t.overclockAutoEnabled;
  if (typeof t.overclockAutoReason === "string" && t.overclockAutoReason) ui.overclockAutoReason = t.overclockAutoReason;
  if (Number.isFinite(Number(t.overclockAutoHz))) ui.overclockAutoHz = Number(t.overclockAutoHz);
  if (typeof t.wizSceneSync === "boolean") {
    ui.wizSceneSync = t.wizSceneSync;
    ui.sceneSyncStrategy = ui.wizSceneSync ? "linked" : "standalone";
  } else if (typeof t.sceneSync === "boolean") {
    ui.wizSceneSync = t.sceneSync;
    ui.sceneSyncStrategy = ui.wizSceneSync ? "linked" : "standalone";
  }

  el.hSent.textContent = String(h.sent ?? 0);
  el.hSkip.textContent = String(h.skipped ?? 0);
  el.hLat.textContent = String(h.lastDurationMs ?? 0);
  const desiredEnt = h.transportDesired === "entertainment";
  const activeEnt = h.transportActive === "entertainment" || h?.entertainment?.active === true;
  let hueStateText = "REST";
  if (activeEnt) {
    hueStateText = "ENT ON";
  } else if (desiredEnt) {
    hueStateText = h.transportFallbackReason ? "ENT RETRY" : "ENT WAIT";
  } else if (h.transportFallbackReason) {
    hueStateText = "REST FB";
  }
  el.hState.textContent = hueStateText;

  el.wSent.textContent = String(w?.sent ?? 0);
  el.wSkip.textContent = String(w?.skipped ?? 0);
  el.wLat.textContent = String(w?.lastDurationMs ?? 0);
  el.wState.textContent = (w && (w.sendErrors || 0) > 0) ? "WARN" : "OK";

  if (h.transportDesired === "entertainment" && h.transportActive !== "entertainment") {
    setBadge(el.health, "warn", "HUE ENT FALLBACK");
  } else {
    setBadge(el.health, "ok", "ENGINE OK");
  }

  if (a) {
    updateAudioTelemetry(a);
    if (a.config) {
      ui.limiterPreset = detectLimiterPreset(a.config);
    }
    if (!ui.audioConfigLoaded && a.config) {
      applyAudioConfigToInputs(a.config);
      ui.audioConfigLoaded = true;
    }
  }

  if (f) updateFixtures(f);
  if (automationSnapshot?.ok && automationSnapshot.config) {
    if (!ui.automationConfigLoaded) {
      applyAutomationConfigToInputs(automationSnapshot.config, automationSnapshot.meta || {});
      ui.automationConfigLoaded = true;
    } else {
      renderAutomationSummary(automationSnapshot.config, automationSnapshot.meta || {});
    }
  }
  if (modsSnapshot?.ok) {
    renderMods(modsSnapshot);
  }
  if (colorPrefixSnapshot?.ok) {
    applyColorPrefixSnapshot(colorPrefixSnapshot);
    ui.colorPrefixConfigLoaded = true;
  }
  if (midiSnapshot?.ok !== false && midiSnapshot) {
    applyMidiSnapshot(midiSnapshot);
  }
  if (reactMapSnapshot?.ok && reactMapSnapshot?.config) {
    applyMetaAutoTempoTrackersState(
      reactMapSnapshot.config.metaAutoTempoTrackers || {
        baseline: reactMapSnapshot.config.metaAutoHueWizBaselineBlend === true
      },
      {
        autoEnabled: reactMapSnapshot.config.metaAutoTempoTrackersAuto === true
      }
    );
    if (reactMapSnapshot.config.sourceCatalog && typeof reactMapSnapshot.config.sourceCatalog === "object") {
      audioReactivitySourceCatalogRuntime = {
        ...AUDIO_REACTIVITY_SOURCE_CATALOG_DEFAULT,
        ...reactMapSnapshot.config.sourceCatalog
      };
    }
    if (!ui.audioReactivityMapDirty) {
      applyAudioReactivityMapToUi(reactMapSnapshot.config, { markDirty: false });
    }
    ui.audioReactivityMapLoaded = true;
  }
  maybeRetuneSmartMatchFromTelemetry();

  if (ui.engineModeTargets > 0) {
    if (ui.engineReadyTargets <= 0) {
      setBadge(el.health, "warn", "NO CONFIGURED ENGINE TARGETS");
    } else if (Number(ui.connectivitySummary?.unreachable || 0) > 0) {
      setBadge(el.health, "warn", "ENGINE TARGET UNREACHABLE");
    }
  }

  el.dropOverlay.style.display = t.drop ? "flex" : "none";
  updateMainScopeInput(t, a);
  updateScopeHud(t, a);
  pushScopeSample(t, h, w, a);
  if (monitorsActive()) drawTelemetryScope();

  sync();
}

let pollInFlight = false;
let pollTimer = null;
async function pollLoop() {
  if (pollInFlight) {
    pollTimer = setTimeout(pollLoop, pollIntervalMs);
    return;
  }

  pollInFlight = true;
  try {
    await poll();
  } finally {
    pollInFlight = false;
    pollTimer = setTimeout(pollLoop, pollIntervalMs);
  }
}

window.addEventListener("beforeunload", () => {
  if (pollTimer) clearTimeout(pollTimer);
  if (flowIntensityCommitTimer) clearTimeout(flowIntensityCommitTimer);
  if (guidedTourAutoStartTimer) clearTimeout(guidedTourAutoStartTimer);
  clearGuidedTourFocus();
  if (mainScopeAnim) cancelAnimationFrame(mainScopeAnim);
});
document.addEventListener("visibilitychange", updateMonitorRenderingState);

ui.startTabPreference = normalizeStartTabPreference(ui.startTabPreference);
ui.activeTab = normalizeStartTabPreference(ui.startTabPreference);
applySystemSettingsUi();
loadSystemServerConfig();
applyApiBaseUi();
applyFlowIntensityUi();
applyReactorSliderUi();
applyAudioReactivityMapToUi(AUDIO_REACTIVITY_MAP_DEFAULT, { markDirty: false });
initThemeSettings();
initObsDockMode();
initCollapsiblePanels();
applyUiTooltips();
initLiveProfileControls();
el.modActionModId.value = "hello-mod";
el.modActionName.value = "status";
resetFixtureForm();
setCustomClusterVisible(false);
initCustomControlTabMount();
applyStandaloneEntryToControls(null);
syncStandaloneValueLabels();
showTab(ui.activeTab);
initOnboardingGate();
initHueEntGuideGate();
initGuidedOnboarding();
loadPaletteConfig().then(() => {
  applyUiTooltips();
  sync();
});
syncAudioQuickPresetButtons();
loadAudioConfig();
loadAudioReactivityMap();
loadAudioDevices();
loadAudioApps();
loadAudioOptionalToolsStatus();
loadMidiStatus();
refreshStandaloneFixtures();
refreshFixturesFromServer({ attempts: 3 });
loadMods();
loadColorPrefixConfig();
syncAutomationPercentLabels();
loadAutomationConfig();
updateMainScopeInput(
  { energy: 0.05, rms: 0.03, drop: false },
  { level: 0.03, transient: 0, spectralFlux: 0, bandLow: 0, bandMid: 0, bandHigh: 0 }
);
updateScopeHud(
  { energy: 0.05, rms: 0.03, drop: false, scene: "-", behavior: "-" },
  { level: 0.03, transient: 0, spectralFlux: 0, bandLow: 0, bandMid: 0, bandHigh: 0 }
);
updateMonitorRenderingState();
pollLoop();
sync();
</script>
</body>
</html>
